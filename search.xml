<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NEAR SDK - 回调函数</title>
      <link href="//post/NEAR%20SDK%20-%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.html"/>
      <url>//post/NEAR%20SDK%20-%20%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<p>与工作量证明区块链不同,NEAR 协议是分片的,权益证明的区块链网络,当使用原生Rust(编译成 WASM)与智能合约交互时,跨合约调用是异步的.回调用来获取跨合约调用的结果或者用来获取跨合约调用是成功还是失败.</p><p>这里有两种进行跨合约调用的技术:<a href="https://github.com/near/near-sdk-rs/tree/master/examples/cross-contract-high-level">高级调用</a>和<a href="https://github.com/near/near-sdk-rs/tree/master/examples/cross-contract-low-level">低级调用</a>.本文档将聚焦于高级调用.Rust SDK 库中有两个示例演示了这些内容.如上面的连接所示.注意这些例子使用跨合约调用他们自身.我们将使用两个示例来演示高级调用.</p><h3 id="计算器示例"><a href="#计算器示例" class="headerlink" title="计算器示例"></a>计算器示例</h3><p><code>#[ext_contract(...)]</code>宏可以帮助你创建一个跨合约调用.它将使用一个 Rust Trait 并且转化为一个具有静态方法的模块.每个静态方法都接受 Trait 定义的位置参数,然后是 receiver_id,附带的存款和 gas 数量然后返回一个 <code>Promiss</code></p><p>例如,让我们定义一个计算器合约 Trait</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[ext_contract(ext_calculator)]</span><span class="token keyword">trait</span> <span class="token type-definition class-name">Calculator</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">mult</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token constant">U128</span><span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">sum</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token constant">U128</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token constant">U128</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token constant">U128</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等价于:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">mod</span> <span class="token module-declaration namespace">ext_calculator</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">mult</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">,</span> receiver_id<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">AccountId</span><span class="token punctuation">,</span> deposit<span class="token punctuation">:</span> <span class="token class-name">Balance</span><span class="token punctuation">,</span> gas<span class="token punctuation">:</span> <span class="token class-name">Gas</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Promise</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Promise</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>receiver_id<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">function_call</span><span class="token punctuation">(</span>                <span class="token string">b"mult"</span><span class="token punctuation">,</span>                <span class="token macro property">json!</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> <span class="token string">"a"</span><span class="token punctuation">:</span> a<span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">:</span> b <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                deposit<span class="token punctuation">,</span>                gas<span class="token punctuation">,</span>            <span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token constant">U128</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token constant">U128</span><span class="token punctuation">,</span> receiver_id<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token class-name">AccountId</span><span class="token punctuation">,</span> deposit<span class="token punctuation">:</span> <span class="token class-name">Balance</span><span class="token punctuation">,</span> gas<span class="token punctuation">:</span> <span class="token class-name">Gas</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Promise</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们假设计算器合约已经部署在了账户<code>calc.near</code>上,我们接下来可以这么做:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">const</span> <span class="token constant">CALCULATOR_ACCOUNT_ID</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span> <span class="token operator">=</span> <span class="token string">"calc.near"</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token constant">NO_DEPOSIT</span><span class="token punctuation">:</span> <span class="token class-name">Balance</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token constant">BASE_GAS</span><span class="token punctuation">:</span> <span class="token class-name">Gas</span> <span class="token operator">=</span> <span class="token number">5_000_000_000_000</span><span class="token punctuation">;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">sum_a_b</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token constant">U128</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token constant">U128</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Promise</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> calculator_account_id<span class="token punctuation">:</span> <span class="token class-name">AccountId</span> <span class="token operator">=</span> <span class="token constant">CALCULATOR_ACCOUNT_ID</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token namespace">ext_calculator<span class="token punctuation">::</span></span><span class="token function">sum</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token operator">&amp;</span>calculator_account_id<span class="token punctuation">,</span> <span class="token constant">NO_DEPOSIT</span><span class="token punctuation">,</span> <span class="token constant">BASE_GAS</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="白名单示例"><a href="#白名单示例" class="headerlink" title="白名单示例"></a>白名单示例</h3><p>接下来我来看白名单智能合约的一个简单的跨合约调用,返回给定的用户是否在白名单里.<br>跨合约调用的常见模式是首先调用外部智能合约的方法.然后使用.then 语法来标记一个回调.最后在 promiss 中取回数据或状态.回调将在同样的环境中调用只能合约.回调函数使用了特殊的宏<code>#[privette]</code>.我们将在下面看到这个模式<br>下面的示例演示两个使用高级调用进行跨和调用的方式.当编写高级跨合约调用时,被调用的智能合约接口被设置为特殊的 trait .并且(通常的)由当前合约进行这个调用(在那里存在回调逻辑).按照惯例,第二个 trait 被称为 <code>ext_self</code>.</p><p>下面我们会看到一个简单的使用了两个 trait的示例:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[ext_contract(ext_self)]</span><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">ExtSelf</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">callback_promise_result</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span><span class="token punctuation">;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">callback_arg_macro</span><span class="token punctuation">(</span><span class="token attribute attr-name">#[callback]</span> val<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[ext_contract(ext_whitelist)]</span><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">ExtWhitelist</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">is_whitelisted</span><span class="token punctuation">(</span>staking_pool_account_id<span class="token punctuation">:</span> <span class="token class-name">AccountId</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在创建这些 trait 后,我们展示两个简单的函数,他们将进行白名单合约的跨合约调用.询问账户 <code>mike.testnet</code> 是否在白名单中.这两个方法都返回 bool 值.首先我们来看看方法,然后让我们来看看回调函数的区别.注意,简单起见,本例中的值是硬编码的.</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">const</span> <span class="token constant">XCC_GAS</span><span class="token punctuation">:</span> <span class="token class-name">Gas</span> <span class="token operator">=</span> <span class="token number">20000000000000</span><span class="token punctuation">;</span><span class="token keyword">fn</span> <span class="token function-definition function">get_whitelist_contract</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">AccountId</span> <span class="token punctuation">&#123;</span>    <span class="token string">"whitelist.demo.testnet"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">fn</span> <span class="token function-definition function">get_account_to_check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">AccountId</span> <span class="token punctuation">&#123;</span>    <span class="token string">"mike.testnet"</span><span class="token punctuation">.</span><span class="token function">to_string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">xcc_use_promise_result</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Promise</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">ext_whitelist<span class="token punctuation">::</span></span><span class="token function">is_whitelisted</span><span class="token punctuation">(</span><span class="token function">get_account_to_check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token function">get_whitelist_contract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">XCC_GAS</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>            <span class="token namespace">ext_self<span class="token punctuation">::</span></span><span class="token function">callback_promise_result</span><span class="token punctuation">(</span>                <span class="token operator">&amp;</span><span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">current_account_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token number">0</span><span class="token punctuation">,</span>                <span class="token constant">XCC_GAS</span><span class="token punctuation">,</span>            <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">xcc_use_arg_macro</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Promise</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">ext_whitelist<span class="token punctuation">::</span></span><span class="token function">is_whitelisted</span><span class="token punctuation">(</span><span class="token function">get_account_to_check</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token function">get_whitelist_contract</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token constant">XCC_GAS</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>            <span class="token namespace">ext_self<span class="token punctuation">::</span></span><span class="token function">callback_arg_macro</span><span class="token punctuation">(</span>                <span class="token operator">&amp;</span><span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">current_account_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token number">0</span><span class="token punctuation">,</span>                <span class="token constant">XCC_GAS</span><span class="token punctuation">,</span>            <span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从<code>ext_whitelist::is_whitelisted..</code>开始的语法给我们展示了如何使用 trait 来调用方法<code>is_whitelisted</code>.然而,该 trait 只有一个参数,我们却传入了 4 个参数.其中后面 3 个参数将在幕后使用:</p><ol><li>目标合约账户(例如:<code>whitelist.demo.testnet</code>)</li><li>附带的 Ⓝ存款,单位为 yocto Ⓝ(1 Ⓝ &#x3D; 1000000000000000000000000 yoctoⓃ.)</li><li>gas 数量</li></ol><p>代码片段中的两个方法非常相似,除了他们各自使用了不同的回调 <code>callback_promise_result</code> 和 <code>callback_arg_macro</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[private]</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">callback_promise_result</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>    <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span><span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">promise_results_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"ERR_TOO_MANY_RESULTS"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">match</span> <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">promise_result</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">PromiseResult</span><span class="token punctuation">::</span><span class="token class-name">NotReady</span> <span class="token operator">=></span> <span class="token macro property">unreachable!</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token class-name">PromiseResult</span><span class="token punctuation">::</span><span class="token class-name">Successful</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Ok</span><span class="token punctuation">(</span>is_whitelisted<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span>serde_json<span class="token punctuation">::</span></span><span class="token function">from_slice</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                is_whitelisted            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">b"ERR_WRONG_VAL_RECEIVED"</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">,</span>        <span class="token class-name">PromiseResult</span><span class="token punctuation">::</span><span class="token class-name">Failed</span> <span class="token operator">=></span> <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">b"ERR_CALL_FAILED"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[private]</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">callback_arg_macro</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> <span class="token attribute attr-name">#[callback]</span> val<span class="token punctuation">:</span> <span class="token keyword">bool</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>    val<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这两个回调展示了如何获得值.第一个方法从 promise result 中获取值,第二个在参数中使用了宏来将值转化为所需的值.请注意,第二种方式没有第一种方式那么容易捕获错误.</p><p>这两种方式最大的不同是参数是如何定义的.</p><p>这就是所有的内容了.理解如何创建一个跨合约调用并且接收返回值是在 NEAR 上开发智能合约非常重要的一部分.</p>]]></content>
      
      
      <categories>
          
          <category> 文档翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NEAR </tag>
            
            <tag> near-sdk-rs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NEAR SDK - 合约接口</title>
      <link href="//post/NEAR%20SDK%20-%20%E5%90%88%E7%BA%A6%E6%8E%A5%E5%8F%A3.html"/>
      <url>//post/NEAR%20SDK%20-%20%E5%90%88%E7%BA%A6%E6%8E%A5%E5%8F%A3.html</url>
      
        <content type="html"><![CDATA[<h3 id="公共方法类型"><a href="#公共方法类型" class="headerlink" title="公共方法类型"></a>公共方法类型</h3><h4 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h4><p>在#[near_bindgen]宏包裹下的函数可以使用 <code>pub</code>标识符修饰,这样当它编译成<code>WASM</code>字节码以后就可以被外部调用 </p><p>只讲能在外部调用的方法标记成<code>public</code>是很重要的.如果你需要合约自身来调用,你可以标记该方法为公共的但是添加<code>#[private]</code>修饰,这样除了合约自身的调用,任何调用都会导致<code>panic</code></p><p>基本的用法如下所示:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">MyContractStructure</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">some_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// .. method logic here</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这将从WASM二进制码中公开some_method,任何人都可以访问它</p><details class="custom-details"><summary>展开显示生成的代码</summary><p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[cfg(target_arch = <span class="token string">"wasm32"</span>)]</span><span class="token attribute attr-name">#[no_mangle]</span><span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token keyword">fn</span> <span class="token function-definition function">some_method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">setup_panic_hook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">attached_deposit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Method some_method doesn\'t accept deposit"</span><span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> contract<span class="token punctuation">:</span> <span class="token class-name">MyContractStructure</span> <span class="token operator">=</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">state_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or_default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    contract<span class="token punctuation">.</span><span class="token function">some_method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">state_write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>contract<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></details><h4 id="公开trait实现"><a href="#公开trait实现" class="headerlink" title="公开trait实现"></a>公开trait实现</h4><p>函数也能够公开自己的trait实现.这有助于在合约中实现共有的接口或标准.下面的代码与<code>pub</code>的基础用法很相似,除了<code>#[near_bindgen]</code>宏只需要附属在trait的实现上,而无需附属与trait本身.</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">MyTrait</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">trait_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">MyTrait</span> <span class="token keyword">for</span> <span class="token class-name">MyContractStructure</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">trait_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// .. method logic here</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中,生成的代码与前一个例子相同,只是方法名不一样</p><details class="custom-details"><summary>展开显示生成的代码</summary><p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[cfg(target_arch = <span class="token string">"wasm32"</span>)]</span><span class="token attribute attr-name">#[no_mangle]</span><span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token keyword">fn</span> <span class="token function-definition function">trait_method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">setup_panic_hook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">attached_deposit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Method trait_method doesn\'t accept deposit"</span><span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> contract<span class="token punctuation">:</span> <span class="token class-name">MyContractStructure</span> <span class="token operator">=</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">state_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or_default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    contract<span class="token punctuation">.</span><span class="token function">trait_method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">state_write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>contract<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></details><h3 id="合约状态可变性"><a href="#合约状态可变性" class="headerlink" title="合约状态可变性"></a>合约状态可变性</h3><p>合约状态可变性是通过函数参数中的<code>self</code>参数是怎样的来自动处理的.根据使用的是哪一个,<code>#[near_bindgen]</code>宏将生成相应的代码来加载&#x2F;反序列化任何使用<code>self</code>的函数的状态，序列化&#x2F;存储状态只在使用<code>&amp;mut self</code>时使用。</p><h4 id="只读函数"><a href="#只读函数" class="headerlink" title="只读函数"></a>只读函数</h4><p>以不可变的方式调用合约时,交易结束时不会覆写任何状态.你可以通过使用&amp;self 或者 self 作为参数.他们都将生成同样的代码去加载并反序列化状态到结构体中,然后调用函数.不同的是,self 会将变量的所有权移动进函数中,&amp;self 仅仅将 self 的引用移动进函数中.</p><p>下面是一个例子:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token attribute attr-name">#[derive(BorshDeserialize, BorshSerialize, Default)]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">MyContractStructure</span> <span class="token punctuation">&#123;</span>    integer<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span>    message<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">MyContractStructure</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_values</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span><span class="token keyword">u64</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>integer<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">log_state_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有适用于所有情况的通用准则,但有一些核心规则需要遵守:</p><ul><li><p><code>self</code> 如果在函数中移动了 self 的值或者其包含的值时使用 <code>self</code> 作为参数是很有用的,因为这样减少了 <code>copy</code> 和 <code>clone</code> 的操作</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// View method. More efficient, but can't be reused internally, because it consumes self.</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_owner_id</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">AccountId</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">self</span><span class="token punctuation">.</span>owner_id<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>&amp;self</code>当值需要只读的合约状态,或者函数使用了一些方法来获得了可用的所有权时使用<code>&amp;self</code>.如果结构体使用了大量内存,这很有用,可以避免将大量的数据转移进函数作用域中.</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// View method. Requires cloning the account id.</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_owner_id</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">AccountId</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">self</span><span class="token punctuation">.</span>owner_id<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>返回派生数据</code></p><p>有些少见的情况需要我们通过只读的方式来返回从存储中获取并修改的数据.如下面所示:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// View method that "modifies" state, for code structure or computational</span><span class="token comment">/// efficiency reasons. Changes state in-memory, but does NOT save the new</span><span class="token comment">/// state. If called internally by a change method, WILL result in updated</span><span class="token comment">/// contract state.</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">update_stats</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> account_id<span class="token punctuation">:</span> <span class="token class-name">AccountId</span><span class="token punctuation">,</span> score<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Account</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> account <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>accounts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>account_id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or_else</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">panic_str</span><span class="token punctuation">(</span><span class="token string">"ERR_ACCT_NOT_FOUND"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    account<span class="token punctuation">.</span>total <span class="token operator">+=</span> score<span class="token punctuation">;</span>    account<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h4><p>可变的函数允许加载存在的状态,然后对它进行修改,最后当方法调用结束后重新将状态写入</p><p>这应该用于任何修改合约状态的交易中.注意,序列化的合约数据存在键 <code>STATE</code> 下持久化存储中.</p><p>一个可变函数的例子:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token attribute attr-name">#[derive(BorshDeserialize, BorshSerialize, Default)]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">MyContractStructure</span> <span class="token punctuation">&#123;</span>    integer<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">MyContractStructure</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">modify_value</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> new_value<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>integer <span class="token operator">=</span> new_value<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">increment_value</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>integer <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><p>这一类函数根本不使用 self,也不需要从存储中读取或者写入合约状态</p><p>使用公共的纯函数的情况很少,但是返回嵌入到合约代码中的数据或执行一些不依赖合约状态的静态共享逻辑时可能很有用</p><p>一个纯函数的例子:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">const</span> <span class="token constant">SOME_VALUE</span><span class="token punctuation">:</span> <span class="token keyword">u64</span> <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">MyContractStructure</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">log_message</span><span class="token punctuation">(</span><span class="token comment">/* Parameters here */</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">near_sdk<span class="token punctuation">::</span></span><span class="token macro property">log!</span><span class="token punctuation">(</span><span class="token string">"inside log message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">log_u64</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">near_sdk<span class="token punctuation">::</span></span><span class="token macro property">log!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">return_static_u64</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">u64</span> <span class="token punctuation">&#123;</span>        <span class="token constant">SOME_VALUE</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><h4 id="何时使用回调"><a href="#何时使用回调" class="headerlink" title="何时使用回调"></a>何时使用回调</h4><p>通常,当合约必须为一个远程交叉合约调用进行回调时,这个回调方法必须只能被合约自身调用.这能避免有人直接调用它而搞乱合约状态.更常见的模式是使用断言来验证直接调用者(predecessor account ID)是否是合约自己的账户(current account ID).<code>#[private]</code>宏会简化这个操作,提高代码可读性.</p><p>在<code>near_bindgen</code>宏包裹的代码里使用这个标注,例如:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[private]</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">my_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    …<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码等价于</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">my_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">current_account_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">predecessor_account_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Method method is private"</span><span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在通过这个标注,只有合约账户本身可以调用这个方法,可以直接调用也可以通过哦Promise</p><h4 id="编写内部方法"><a href="#编写内部方法" class="headerlink" title="编写内部方法"></a>编写内部方法</h4><p>不是所有的方法都需要暴露为公开的,为 helper 或 uility 函数编写私有的方法也许更加有益.下面是三种编写内部方法的途径</p><ul><li><p>使用 <code>fn</code> 替换 <code>pub fn</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">helper_method</span><span class="token punctuation">(</span>a<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token keyword">u8</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  …<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>使用<code>pub(crate) fn</code>.这将有助于在不同的模块中使用内部函数</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// Function that can be called in another Rust file</span><span class="token keyword">pub</span><span class="token punctuation">(</span><span class="token keyword">crate</span><span class="token punctuation">)</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_first_name</span><span class="token punctuation">(</span>account<span class="token punctuation">:</span> <span class="token class-name">Account</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  …<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>分散的<code>impl</code>块</p><p>另外一种不暴露方法的方式是有一个单独的<code>impl Contract</code>部分,并且这部分不使用<code>#[near_bindgen]</code>宏</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">increment</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">internal_increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token comment">/// This methods is still not exported.</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">internal_increment</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>counter <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="可支付方法"><a href="#可支付方法" class="headerlink" title="可支付方法"></a>可支付方法</h3><p>我们可以允许方法在函数调用时接受代币转移.这样做是为了让合约能够使用的时候定义其需要的代币费用.默认的方法是不可支付的,如果调用时尝试转移代币会导致 panic.这样做是因为安全原因,以免有人在函数调用时意外地转移代币</p><p>使用#[payable]标注来申明方法是可支付的.</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[payable]</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">my_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这将允许通过调用my_method方法来转移资产给合约</p><p>例子:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token attribute attr-name">#[payable]</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">take_my_money</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">log_str</span><span class="token punctuation">(</span><span class="token string">"Thanks!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">do_not_take_my_money</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">log_str</span><span class="token punctuation">(</span><span class="token string">"Thanks!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>等价于:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">take_my_money</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">log_str</span><span class="token punctuation">(</span><span class="token string">"Thanks!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">do_not_take_my_money</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">attached_deposit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">b"Method do_not_take_my_money doesn't accept deposit"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">log_str</span><span class="token punctuation">(</span><span class="token string">"Thanks!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="序列化协议"><a href="#序列化协议" class="headerlink" title="序列化协议"></a>序列化协议</h3><p>SDK 中的序列化规则定义了结构体数据如何转化成字节,当需要传输数据到合约方法中或存储数据到状态中时.对于方法参数,SDK 接受JSON(默认)和 Borsh,对于存储数据在链上,使用 Borsh.</p><h4 id="JSON-和-Borsh-的特点如下"><a href="#JSON-和-Borsh-的特点如下" class="headerlink" title="JSON 和 Borsh 的特点如下:"></a>JSON 和 Borsh 的特点如下:</h4><p>JSON:</p><ul><li>人类可读</li><li>自解释样式(不需要知道底层类型)</li><li>与 JavaScript 的易互操作性</li><li>低效率的(反)序列化<br>Borsh</li><li>紧凑的二进制格式可以高效率的进行数据的序列化和反序列化</li><li>需要知道数据格式或者有一个模板来反序列化数据</li><li>严格规范的二进制表示</li><li>在大多数情况下,快速并且开销更小<br>通常来说,JSON 用于合约调用和交叉合约调用以实现更好的适用性,Borsh 被用于优化合约中更小的参数序列化和更少的反序列化计算开销,以减少 gas 使用.</li></ul><h4 id="重载默认的序列化协议"><a href="#重载默认的序列化协议" class="headerlink" title="重载默认的序列化协议"></a>重载默认的序列化协议</h4><p>结果和参数的序列化可以分开选择.但是所有的参数必须使用同样的样式(不能使用 borsh 序列化一部分参数,另外的参数使用 JSON 序列化).<br>下面的例子是同时使用 borsh 来序列化返回值和参数</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[result_serializer(borsh)]</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">sum_borsh</span><span class="token punctuation">(</span><span class="token attribute attr-name">#[serializer(borsh)]</span> a<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">,</span> <span class="token attribute attr-name">#[serializer(borsh)]</span> b<span class="token punctuation">:</span> <span class="token keyword">u32</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">u32</span> <span class="token punctuation">&#123;</span>    a <span class="token operator">+</span> b<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-result_serializer(borsh)```标注会重载默认的返回值的序列化协议,从" data-language="result_serializer(borsh)```标注会重载默认的返回值的序列化协议,从"><div class="caption"><span>JSON 重载为 borsh,```serializer(borsh)```标注将重载参数的序列化协议</span></div><code class="language-result_serializer(borsh)```标注会重载默认的返回值的序列化协议,从">下面是在单元测试中使用 Borsh 序列化,并且使用 base64 编码的方法&#96;&#96;&#96;rust&#x2F;&#x2F;&#x2F; This test is simply a helper to print out the base64 value.#[test]fn borsh_simple() &#123;    let status_message &#x3D; &quot;Aloha honua!&quot;.to_string();    let borsh_input &#x3D; SetMessageInput &#123;        msg: status_message.clone()    &#125;;    let borsh_serialized: Vec&lt;u8&gt; &#x3D; borsh_input.try_to_vec().unwrap();    let base64_encoded &#x3D; near_primitives::serialize::to_base64(borsh_serialized.as_slice());    println!(&quot;Using NEAR CLI, this is the base64-encoded value to use: &#123;:?&#125;&quot;, base64_encoded);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面展示了在 CLI 中使用这个值的代码片段.注意,该方法没有返回值,所以不需要使用#[result_serializer(borsh)]来标注返回值</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">set_status_borsh</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> <span class="token attribute attr-name">#[serializer(borsh)]</span> message<span class="token punctuation">:</span> <span class="token class-name">SetMessageInput</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">self</span><span class="token punctuation">.</span>records<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">signer_account_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>他们使用了这个简单的结构体:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[derive(BorshDeserialize, BorshSerialize)]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">SetMessageInput</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Note that the key does not have to be "message" like the argument name.</span>    msg<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在NEAR CLI中调用方法如下:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">near call rust-status-message.demo.testnet set_status_borsh --base64 &#39;DAAAAEFsb2hhIGhvbnVhIQ&#x3D;&#x3D;&#39; --accountId demo.testnet<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="JSON-包装类型"><a href="#JSON-包装类型" class="headerlink" title="JSON 包装类型"></a>JSON 包装类型</h4><p>为了帮助将某些类型序列化为 JSON,这些类型有意想不到或低效的默认格式,在 <code>near_sdk::json_types</code> 里有一些包装器类型可以使用<br>因为 JavaScript 只支持整数类型的值到 2^53-1,如果反序列化 JSON 整型超过了这个范围,你将丢失精度.为了抵消这种影响,你可以使用 <code>I64</code>,<code>U64</code>,<code>I128</code> 和 <code>U128</code> 类型来代替这些参数或结果的本地类型,将值序列化为字符串.默认情况下,所有整数类型都将序列化为 JSON 中的整型<br>你能使用 <code>std::convert::Into</code> 来将 <code>U64</code> 转化为 <code>u64</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">mult</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token constant">U128</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> a<span class="token punctuation">:</span> <span class="token keyword">u64</span> <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> b<span class="token punctuation">:</span> <span class="token keyword">u64</span> <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> product <span class="token operator">=</span> <span class="token keyword">u128</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">u128</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        product<span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你也可以使用<code>.0</code>来访问内部值</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">mult</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token constant">U128</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//let a: u64 = a.into();</span>        <span class="token keyword">let</span> a <span class="token operator">=</span> a<span class="token number">.0</span><span class="token punctuation">;</span>        <span class="token comment">//let b: u64 = b.into();</span>        <span class="token keyword">let</span> b <span class="token operator">=</span> b<span class="token number">.0</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> product <span class="token operator">=</span> <span class="token keyword">u128</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">u128</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        product<span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>同时,你还可以使用<code>U64(...)</code>和<code>U128(...)</code>来转化<code>u64</code>和<code>u128</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span> <span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>     <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">mult</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token constant">U128</span> <span class="token punctuation">&#123;</span>         <span class="token keyword">let</span> a <span class="token operator">=</span> a<span class="token number">.0</span><span class="token punctuation">;</span>         <span class="token keyword">let</span> b <span class="token operator">=</span> b<span class="token number">.0</span><span class="token punctuation">;</span>         <span class="token keyword">let</span> product <span class="token operator">=</span> <span class="token keyword">u128</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">u128</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//product.into()</span>         <span class="token constant">U128</span><span class="token punctuation">(</span>product<span class="token punctuation">)</span>     <span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结合起来使用:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">mult</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> a<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">,</span> b<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token constant">U128</span> <span class="token punctuation">&#123;</span>        <span class="token constant">U128</span><span class="token punctuation">(</span><span class="token keyword">u128</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>a<span class="token number">.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token keyword">u128</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span>b<span class="token number">.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管JSON 包装类型只包含在 SDK 中,但是任何类型都可以使用,只要它各自实现了 serder 序列化和反序列化.所有这些类型都覆写了 JSON 格式并且与内部类型具有一致的 borsh 序列化和反序列特性</p><h4 id="Base64VecU8"><a href="#Base64VecU8" class="headerlink" title="Base64VecU8"></a>Base64VecU8</h4><p>另外一个覆写默认序列化的例子是 Vec<u8>,它用来表示 Rust 中的字节.默认实现下,它将序列化为整型数组,这是不紧凑而且很难使用的.有一个包装类型Base64VecU8,它能序列化和反序列化 Base64 字符串再 JSON 的序列化中获得更多的紧凑性</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token attribute attr-name">#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// Notice, internally we store `Vec&lt;u8>` </span>    <span class="token keyword">pub</span> data<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">u8</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token attribute attr-name">#[init]</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">new</span><span class="token punctuation">(</span>data<span class="token punctuation">:</span> <span class="token class-name">Base64VecU8</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">Self</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">Self</span> <span class="token punctuation">&#123;</span>            data<span class="token punctuation">:</span> data<span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_data</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Base64VecU8</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">self</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span><span class="token function">into</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 文档翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NEAR </tag>
            
            <tag> near-sdk-rs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NEAR-SDK Promise</title>
      <link href="//post/NEAR%20SDK%20-%20Promise.html"/>
      <url>//post/NEAR%20SDK%20-%20Promise.html</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>合约能够通过 Promise 异步的发送交易.就像其他编程语言中的Promise 一样,它可以让代码在未来执行.”在未来”意味着交易将在下一个区块(或附近)执行,而不会在初始调用的区块执行.<br>你可以使用 Promise实现任何跨合约调用链.它介于之前所说的高级调用和低级调用之间.查阅上面完整的 Promise 文档以获得更多细节<br>当然,在很少的情况下,Promise 拥有特殊的能力,因为这些情况都不需要函数调用</p><ul><li>发送 NEAR 代币</li><li>创建账户</li><li>部署合约</li></ul><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">提示</p><p>为什么要等待</p><p>为什么不让交易是同步进行的.在同样的区块完成方法调用?为什么 NEAR 需要 Promise 来发送代币,创建账户和部署合约?<br>他们需要在单独的块中进行调度,因为发送者和接收者可能位于不同的分片中,跨分片通信发生在多个块之间,通过 收据(receipts),你可以将收据理解为 NEAR 的内部交易.你能在 <a href="https://hexo.io/docs/one-command-deployment.html">NEAR Explorer</a> 中看到收据是怎么从一个块传输到另一个块中.</p></div><h4 id="发送-NEAR"><a href="#发送-NEAR" class="headerlink" title="发送$NEAR"></a>发送$NEAR</h4><p>你可能有很多原因想要从合约发送代币:</p><ul><li>合约使用了类似存储标准的协议,需要再用户注销时返还资金</li><li>用户支付 token 给合约,然后合约稍后支付费用给维护人员,重新分配给用户或者通过用户投票的结果支付给其他人</li><li>更多…</li></ul><p>区块链给了我们可编程的货币,智能合约支付货币是这种能力的核心<br>NEAR 让这变的简单,如果你想要从合约中转移代币,下面是你需要做的全部:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> amount<span class="token punctuation">:</span> <span class="token keyword">u128</span> <span class="token operator">=</span> <span class="token number">1_000_000_000_000_000_000_000_000</span><span class="token punctuation">;</span> <span class="token comment">// 1 $NEAR as yoctoNEAR</span><span class="token keyword">let</span> account_id<span class="token punctuation">:</span> <span class="token class-name">AccountId</span> <span class="token operator">=</span> <span class="token string">"example.near"</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Promise</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>account_id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">提示</p><p><p>本文档描述的 AccountId 行为是 neaer-sdk-rs v4 的特性.这个功能在 v3 中依然可以使用,但如果你想使用更干净的 v4 语法,编写你的Cargo.toml</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token punctuation">[</span>dependencies<span class="token punctuation">]</span>near<span class="token operator">-</span>sdk <span class="token operator">=</span> <span class="token string">"4.0.0-pre.2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></p></div><p>完整的合约上下文像下面这样</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span></span><span class="token punctuation">&#123;</span><span class="token namespace">json_types<span class="token punctuation">::</span></span><span class="token constant">U128</span><span class="token punctuation">,</span> near_bindgen<span class="token punctuation">,</span> <span class="token class-name">AccountId</span><span class="token punctuation">,</span> <span class="token class-name">Promise</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Contract</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">pay</span><span class="token punctuation">(</span>amount<span class="token punctuation">:</span> <span class="token constant">U128</span><span class="token punctuation">,</span> to<span class="token punctuation">:</span> <span class="token class-name">AccountId</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Promise</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Promise</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>amount<span class="token number">.0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中大部分是你已经熟悉的样板.像 imports,设置 near_bindgen,borsh.下面是一些与转账有关的有趣细节:</p><ul><li><p>大写的 U 的 U128,这里的 pay 方法定义了接受 JSON 作为输入,但是 JSON 数字不能超过 2^53,也就是 9 后面只跟了 15 个 0,因为传输时使用的数量是以 yoctoNEAR 为单位,似乎需要比 2^53 大的多的数字<br>  当方法接受 U128 位输入时,这意味着调用者需要将数字转化成 string.near-sdk-rs 将 string 转化为 U128,它是 Rust 原生的 u128 的包装类.底层的 u128 可以通过.0 来使用.例如 transfer(amount.0)</p></li><li><p>AccountId:这个类型会自动的检查提供的 string 是否很好的匹配了 NEAR 账户 ID 的规则.当不匹配时 panic</p></li><li><p>返回 Promise:这将允许 NEAR Explorer,near-cli,near-api-js.和其他工具正确的判断整个交易链是否成功.如果你的函数没有返回 Promise.类似于 near-cli 会在你的调用后立刻返回.并且即使 transfer 失败,你的函数调用也会确认为成功.<a href="https://github.com/near-examples/rust-high-level-cross-contract/pull/73#issuecomment-902849410">这里</a>有相关的例子.<br>使用 near-cli 来调用函数:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">near call $CONTRACT pay &#39;&#123;&quot;amount&quot;: &quot;1000000000000000000000000&quot;, &quot;to&quot;: &quot;example.near&quot;&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="发送-NEAR-1"><a href="#发送-NEAR-1" class="headerlink" title="发送$NEAR"></a>发送$NEAR</h3><p>你可能有很多原因想要从合约发送代币:</p><ul><li>合约使用了类似存储标准的协议,需要再用户注销时返还资金</li><li>用户支付 token 给合约,然后合约稍后支付费用给维护人员,重新分配给用户或者通过用户投票的结果支付给其他人</li><li>更多…</li></ul><p>区块链给了我们可编程的货币,智能合约支付货币是这种能力的核心<br>NEAR 让这变的简单,如果你想要从合约中转移代币,你只需要:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> amount<span class="token punctuation">:</span> <span class="token keyword">u128</span> <span class="token operator">=</span> <span class="token number">1_000_000_000_000_000_000_000_000</span><span class="token punctuation">;</span> <span class="token comment">// 1 $NEAR as yoctoNEAR</span><span class="token keyword">let</span> account_id<span class="token punctuation">:</span> <span class="token class-name">AccountId</span> <span class="token operator">=</span> <span class="token string">"example.near"</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Promise</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>account_id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在一个完整的合约和函数上下文中,你可以这样发送$NEAR</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span></span><span class="token punctuation">&#123;</span><span class="token namespace">json_types<span class="token punctuation">::</span></span><span class="token constant">U128</span><span class="token punctuation">,</span> near_bindgen<span class="token punctuation">,</span> <span class="token class-name">AccountId</span><span class="token punctuation">,</span> <span class="token class-name">Promise</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Contract</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">pay</span><span class="token punctuation">(</span>amount<span class="token punctuation">:</span> <span class="token constant">U128</span><span class="token punctuation">,</span> to<span class="token punctuation">:</span> <span class="token class-name">AccountId</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Promise</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Promise</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>amount<span class="token number">.0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>例子中的大部分内容你应该已经很熟悉了.比如<code>near_bindgen</code>,<code>borsh</code>,下面是一些与$NEAR的发送有关的细节:</p><ul><li>大写的 <code>U</code> 的 <code>U128</code>,这里的 <code>pay</code> 方法定义了接受 JSON 作为输入,但是 JSON 数字不能超过 2^53,也就是 9 后面跟15 个 0,因为传输时使用的数量是以 yoctoNEAR 为单位,我们似乎需要比 2^53 大的多的数字<br>  当方法接受 <code>U128</code> 位输入时,这意味着调用者需要将数字转化成 <code>string</code>.<code>near-sdk-rs</code> 将 <code>string</code> 转化为 <code>U128</code>,它是 Rust 原生的 <code>u128</code> 的包装类.底层的 <code>u128</code> 可以通过<code>.0</code> 来使用.例如 <code>transfer(amount.0)</code></li><li><code>AccountId</code>:这个类型会自动的检查提供的 string 是否很好的匹配了 NEAR 账户 ID 的规则.当不匹配时 panic</li><li>返回 <code>Promise</code>:这将允许 NEAR Explorer,near-cli,near-api-js.和其他工具正确的判断整个交易链是否成功.如果你的函数没有返回 <code>Promise</code>.near-cli这样的工具 会在你的调用后立刻返回.并且即使 transfer 失败,你的函数调用也会确认为成功.你能看到相关例子在<a href="https://github.com/near-examples/rust-high-level-cross-contract/pull/73#issuecomment-902849410">这里</a></li></ul><p>使用 near-cli 来调用函数:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">near call $CONTRACT pay &#39;&#123;&quot;amount&quot;: &quot;1000000000000000000000000&quot;, &quot;to&quot;: &quot;example.near&quot;&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><p>你可能会有很多原因需要从合约中创建账户.一个例子;你想要用户渐进式的参与,在一开始时隐藏 NEAR 的概念,然后自动为他们创建账户(可能是你的账户的子账户,类似于 user123.some-cool-game.near).<br>因为没有余额的账户几乎不能使用,你可能想要将其与上一页中的代币转移结合使用.你需要给定这个账户一个访问秘钥.就像下面做的这样</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token class-name">Promise</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token string">"subaccount.example.near"</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">create_account</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">add_full_access_key</span><span class="token punctuation">(</span><span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">signer_account_pk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token number">250_000_000_000_000_000_000_000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2.5e23yN, 0.25N</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>完整的合约上下文如下:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span></span><span class="token punctuation">&#123;</span>env<span class="token punctuation">,</span> near_bindgen<span class="token punctuation">,</span> <span class="token class-name">AccountId</span><span class="token punctuation">,</span> <span class="token class-name">Balance</span><span class="token punctuation">,</span> <span class="token class-name">Promise</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token constant">INITIAL_BALANCE</span><span class="token punctuation">:</span> <span class="token class-name">Balance</span> <span class="token operator">=</span> <span class="token number">250_000_000_000_000_000_000_000</span><span class="token punctuation">;</span> <span class="token comment">// 2.5e23yN, 0.25N</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Contract</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token attribute attr-name">#[private]</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">create_subaccount</span><span class="token punctuation">(</span>prefix<span class="token punctuation">:</span> <span class="token class-name">AccountId</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Promise</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> subaccount_id <span class="token operator">=</span> <span class="token class-name">AccountId</span><span class="token punctuation">::</span><span class="token function">new_unchecked</span><span class="token punctuation">(</span>          <span class="token macro property">format!</span><span class="token punctuation">(</span><span class="token string">"&#123;&#125;.&#123;&#125;"</span><span class="token punctuation">,</span> prefix<span class="token punctuation">,</span> <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">current_account_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Promise</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>subaccount_id<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">create_account</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">add_full_access_key</span><span class="token punctuation">(</span><span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">signer_account_pk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span><span class="token constant">INITIAL_BALANCE</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意的事:</p><ul><li><code>add_full_access_key</code> - 该示例使用了进行方法调用并签署了原始交易的人或app的公钥(<code>singner_account_pk</code>),你也可以使用<code>add_access_key</code>来添加<code>Function Call</code>访问键,该访问键允许用户调用预先定义好的一组合约方法.</li><li><code>#[private]</code> - 如果你有一个方法将会使用你的合约存款.你可能希望以某种方式保护它不被攻击.这里例子用了一个过于简单的方法–标注<code>#[private]</code>宏</li><li><code>INITTIAL_BALANCE</code>使用near-sdk-rs中的<code>Balance</code>类型.现在它简单的等价于<code>u128</code>,但它将来可能会扩展出额外的方法,就像最近对<a href="https://github.com/near/near-sdk-rs/pull/471"><code>Gas</code>类型做的那样</a>类型做的那样</li></ul><h3 id="部署合约"><a href="#部署合约" class="headerlink" title="部署合约"></a>部署合约</h3><p>出于一下几种原因,你可能希望你的智能合约能部署后续的智能合约代码:</p><ul><li>该合约使用工厂模式,在这个模式中,父合约创建很多子合约(Mintbase使用这种模式为任何想要创建NFT商店的人创建一个NFT商店,彩虹桥也使用这种模式为每个桥接代币创建特定的代币合约)</li><li>合约等待投票通过后更新其自身的代码</li><li>你可以实现一个”合约用户化”系统为每个用户创建特定应用的子账户并且为他们部署同样的合约</li></ul>]]></content>
      
      
      <categories>
          
          <category> 文档翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NEAR </tag>
            
            <tag> near-sdk-rs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
