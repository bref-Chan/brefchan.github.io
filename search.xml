<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NEAR SDK - 合约接口</title>
      <link href="//post/NEAR%20SDK%20-%20%E5%90%88%E7%BA%A6%E6%8E%A5%E5%8F%A3.html"/>
      <url>//post/NEAR%20SDK%20-%20%E5%90%88%E7%BA%A6%E6%8E%A5%E5%8F%A3.html</url>
      
        <content type="html"><![CDATA[<h3 id="公共方法类型"><a href="#公共方法类型" class="headerlink" title="公共方法类型"></a>公共方法类型</h3><h4 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h4><p>在#[near_bindgen]宏包裹下的函数可以使用 <code>pub</code>标识符修饰,这样当它编译成<code>WASM</code>字节码以后就可以被外部调用 </p><p>只讲能在外部调用的方法标记成<code>public</code>是很重要的.如果你需要合约自身来调用,你可以标记该方法为公共的但是添加<code>#[private]</code>修饰,这样除了合约自身的调用,任何调用都会导致<code>panic</code></p><p>基本的用法如下所示:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">MyContractStructure</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">some_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// .. method logic here</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这将从WASM二进制码中公开some_method,任何人都可以访问它</p><details class="custom-details"><summary>展开显示生成的代码</summary><p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[cfg(target_arch = <span class="token string">"wasm32"</span>)]</span><span class="token attribute attr-name">#[no_mangle]</span><span class="token keyword">pub</span> <span class="token keyword">extern</span> <span class="token string">"C"</span> <span class="token keyword">fn</span> <span class="token function-definition function">some_method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">setup_panic_hook</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">attached_deposit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Method some_method doesn\'t accept deposit"</span><span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> contract<span class="token punctuation">:</span> <span class="token class-name">MyContractStructure</span> <span class="token operator">=</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">state_read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or_default</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    contract<span class="token punctuation">.</span><span class="token function">some_method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">state_write</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>contract<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></p></details><h4 id="公开trait实现"><a href="#公开trait实现" class="headerlink" title="公开trait实现"></a>公开trait实现</h4><p>函数也能够公开自己的trait实现.这有助于在合约中实现共有的接口或标准.下面的代码与<code>pub</code>的基础用法很相似,除了<code>#[near_bindgen]</code>宏只需要附属在trait的实现上,而无需附属与trait本身.</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">pub</span> <span class="token keyword">trait</span> <span class="token type-definition class-name">MyTrait</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">trait_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">MyTrait</span> <span class="token keyword">for</span> <span class="token class-name">MyContractStructure</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">trait_method</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// .. method logic here</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在这个例子中,生成的代码与前一个例子相同,只是方法名不一样</p><details class="custom-details"><summary>展开显示生成的代码</summary><p>#[cfg(target_arch &#x3D; “wasm32”)]</p><p>#[no_mangle]</p><p><em>pub</em> <em>extern</em> “C” <em>fn</em> trait_method() {</p><p>​    near_sdk::env::setup_panic_hook();</p><p>​    <em>if</em> near_sdk::env::attached_deposit() !&#x3D; 0 {</p><p>​        near_sdk::env::panic(“Method trait_method doesn&#39;t accept deposit”.as_bytes());</p><p>​    }</p><p>​    <em>let</em> <em>mut</em> contract: MyContractStructure &#x3D; near_sdk::env::state_read().unwrap_or_default();</p><p>​    contract.trait_method();</p><p>​    near_sdk::env::state_write(&amp;contract);</p><p>}</p></details><h3 id="合约状态可变性"><a href="#合约状态可变性" class="headerlink" title="合约状态可变性"></a>合约状态可变性</h3><p>合约状态可变性是通过函数参数中的<code>self</code>参数是怎样的来自动处理的.根据使用的是哪一个,<code>#[near_bindgen]</code>宏将生成相应的代码来加载&#x2F;反序列化任何使用<code>self</code>的函数的状态，序列化&#x2F;存储状态只在使用<code>&amp;mut self</code>时使用。</p><h4 id="只读函数"><a href="#只读函数" class="headerlink" title="只读函数"></a>只读函数</h4><p>以不可变的方式调用合约时,交易结束时不会覆写任何状态.你可以通过使用&amp;self 或者 self 作为参数.他们都将生成同样的代码去加载并反序列化状态到结构体中,然后调用函数.不同的是,self 会将变量的所有权移动进函数中,&amp;self 仅仅将 self 的引用移动进函数中.</p><p>下面是一个例子:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token attribute attr-name">#[near_bindgen]</span><span class="token attribute attr-name">#[derive(BorshDeserialize, BorshSerialize, Default)]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">MyContractStructure</span> <span class="token punctuation">&#123;</span>    integer<span class="token punctuation">:</span> <span class="token keyword">u64</span><span class="token punctuation">,</span>    message<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token punctuation">,</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">MyContractStructure</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_values</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token punctuation">(</span><span class="token keyword">u64</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>integer<span class="token punctuation">,</span> <span class="token keyword">self</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">log_state_string</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token namespace">near_sdk<span class="token punctuation">::</span>env<span class="token punctuation">::</span></span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">.</span>message<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>没有适用于所有情况的通用准则,但有一些核心规则需要遵守:</p><ul><li><p><code>self</code> 如果在函数中移动了 self 的值或者其包含的值时使用 <code>self</code> 作为参数是很有用的,因为这样减少了 <code>copy</code> 和 <code>clone</code> 的操作</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// View method. More efficient, but can't be reused internally, because it consumes self.</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_owner_id</span><span class="token punctuation">(</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">AccountId</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">self</span><span class="token punctuation">.</span>owner_id<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>&amp;self</code>当值需要只读的合约状态,或者函数使用了一些方法来获得了可用的所有权时使用<code>&amp;self</code>.如果结构体使用了大量内存,这很有用,可以避免将大量的数据转移进函数作用域中.</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// View method. Requires cloning the account id.</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_owner_id</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">AccountId</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">self</span><span class="token punctuation">.</span>owner_id<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>返回派生数据</code></p><p>有些少见的情况需要我们通过只读的方式来返回从存储中获取并修改的数据.如下面所示:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// View method that "modifies" state, for code structure or computational</span><span class="token comment">/// efficiency reasons. Changes state in-memory, but does NOT save the new</span><span class="token comment">/// state. If called internally by a change method, WILL result in updated</span><span class="token comment">/// contract state.</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">update_stats</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> account_id<span class="token punctuation">:</span> <span class="token class-name">AccountId</span><span class="token punctuation">,</span> score<span class="token punctuation">:</span> <span class="token constant">U64</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Account</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> account <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>accounts<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>account_id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap_or_else</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token closure-punctuation punctuation">|</span></span> <span class="token namespace">env<span class="token punctuation">::</span></span><span class="token function">panic_str</span><span class="token punctuation">(</span><span class="token string">"ERR_ACCT_NOT_FOUND"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    account<span class="token punctuation">.</span>total <span class="token operator">+=</span> score<span class="token punctuation">;</span>    account<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Promise</title>
      <link href="//post/Promise.html"/>
      <url>//post/Promise.html</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>合约能够通过 Promise 异步的发送交易.就像其他编程语言中的Promise 一样,它可以让代码在未来执行.”在未来”意味着交易将在下一个区块(或附近)执行,而不会在初始调用的区块执行.<br>你可以使用 Promise实现任何跨合约调用链.它介于之前所说的高级调用和低级调用之间.查阅上面完整的 Promise 文档以获得更多细节<br>当然,在很少的情况下,Promise 拥有特殊的能力,因为这些情况都不需要函数调用</p><ul><li>发送 NEAR 代币</li><li>创建账户</li><li>部署合约</li></ul><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">提示</p><p><p>为什么要等待</p><p>为什么不让交易是同步进行的.在同样的区块完成方法调用?为什么 NEAR 需要 Promise 来发送代币,创建账户和部署合约?<br>他们需要在单独的块中进行调度,因为发送者和接收者可能位于不同的分片中,跨分片通信发生在多个块之间,通过 收据(receipts),你可以将收据理解为 NEAR 的内部交易.你能在 <a href="https://hexo.io/docs/one-command-deployment.html">NEAR Explorer</a> 中看到收据是怎么从一个块传输到另一个块中.</p></p></div><h4 id="发送-NEAR"><a href="#发送-NEAR" class="headerlink" title="发送$NEAR"></a>发送$NEAR</h4><p>你可能有很多原因想要从合约发送代币:</p><ul><li>合约使用了类似存储标准的协议,需要再用户注销时返还资金</li><li>用户支付 token 给合约,然后合约稍后支付费用给维护人员,重新分配给用户或者通过用户投票的结果支付给其他人</li><li>更多…</li></ul><p>区块链给了我们可编程的货币,智能合约支付货币是这种能力的核心<br>NEAR 让这变的简单,如果你想要从合约中转移代币,下面是你需要做的全部:</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> amount<span class="token punctuation">:</span> <span class="token keyword">u128</span> <span class="token operator">=</span> <span class="token number">1_000_000_000_000_000_000_000_000</span><span class="token punctuation">;</span> <span class="token comment">// 1 $NEAR as yoctoNEAR</span><span class="token keyword">let</span> account_id<span class="token punctuation">:</span> <span class="token class-name">AccountId</span> <span class="token operator">=</span> <span class="token string">"example.near"</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Promise</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>account_id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>amount<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>:::tip</p><p>本文档描述的 AccountId 行为是 neaer-sdk-rs v4 的特性.这个功能在 v3 中依然可以使用,但如果你想使用更干净的 v4 语法,编写你的Cargo.toml</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token punctuation">[</span>dependencies<span class="token punctuation">]</span>near<span class="token operator">-</span>sdk <span class="token operator">=</span> <span class="token string">"4.0.0-pre.2"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>:::<br>完整的合约上下文像下面这样</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">near_sdk<span class="token punctuation">::</span></span><span class="token punctuation">&#123;</span><span class="token namespace">json_types<span class="token punctuation">::</span></span><span class="token constant">U128</span><span class="token punctuation">,</span> near_bindgen<span class="token punctuation">,</span> <span class="token class-name">AccountId</span><span class="token punctuation">,</span> <span class="token class-name">Promise</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">Contract</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token attribute attr-name">#[near_bindgen]</span><span class="token keyword">impl</span> <span class="token class-name">Contract</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">pay</span><span class="token punctuation">(</span>amount<span class="token punctuation">:</span> <span class="token constant">U128</span><span class="token punctuation">,</span> to<span class="token punctuation">:</span> <span class="token class-name">AccountId</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Promise</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Promise</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">transfer</span><span class="token punctuation">(</span>amount<span class="token number">.0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中大部分是你已经熟悉的样板.像 imports,设置 near_bindgen,borsh.下面是一些与转账有关的有趣细节:</p><ul><li><p>大写的 U 的 U128,这里的 pay 方法定义了接受 JSON 作为输入,但是 JSON 数字不能超过 2^53,也就是 9 后面只跟了 15 个 0,因为传输时使用的数量是以 yoctoNEAR 为单位,似乎需要比 2^53 大的多的数字<br>  当方法接受 U128 位输入时,这意味着调用者需要将数字转化成 string.near-sdk-rs 将 string 转化为 U128,它是 Rust 原生的 u128 的包装类.底层的 u128 可以通过.0 来使用.例如 transfer(amount.0)</p></li><li><p>AccountId:这个类型会自动的检查提供的 string 是否很好的匹配了 NEAR 账户 ID 的规则.当不匹配时 panic</p></li><li><p>返回 Promise:这将允许 NEAR Explorer,near-cli,near-api-js.和其他工具正确的判断整个交易链是否成功.如果你的函数没有返回 Promise.类似于 near-cli 会在你的调用后立刻返回.并且即使 transfer 失败,你的函数调用也会确认为成功.<a href="https://github.com/near-examples/rust-high-level-cross-contract/pull/73#issuecomment-902849410">这里</a>有相关的例子.<br>使用 near-cli 来调用函数:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">near call $CONTRACT pay &#39;&#123;&quot;amount&quot;: &quot;1000000000000000000000000&quot;, &quot;to&quot;: &quot;example.near&quot;&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
