{"title":"Promise","uid":"b468f3c3ac71ea2b71e5a5059fe38476","slug":"Promise","date":"2022-03-10T11:08:00.000Z","updated":"2022-03-11T08:45:46.010Z","comments":true,"path":"api/articles/Promise.json","cover":null,"content":"<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>合约能够通过 Promise 异步的发送交易.就像其他编程语言中的Promise 一样,它可以让代码在未来执行.”在未来”意味着交易将在下一个区块(或附近)执行,而不会在初始调用的区块执行.<br>你可以使用 Promise实现任何跨合约调用链.它介于之前所说的高级调用和低级调用之间.查阅上面完整的 Promise 文档以获得更多细节<br>当然,在很少的情况下,Promise 拥有特殊的能力,因为这些情况都不需要函数调用</p>\n<ul>\n<li>发送 NEAR 代币</li>\n<li>创建账户</li>\n<li>部署合约</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">提示</p>\n<p>为什么要等待</p>\n<p>为什么不让交易是同步进行的.在同样的区块完成方法调用?为什么 NEAR 需要 Promise 来发送代币,创建账户和部署合约?<br>他们需要在单独的块中进行调度,因为发送者和接收者可能位于不同的分片中,跨分片通信发生在多个块之间,通过 收据(receipts),你可以将收据理解为 NEAR 的内部交易.你能在 <a href=\"https://hexo.io/docs/one-command-deployment.html\">NEAR Explorer</a> 中看到收据是怎么从一个块传输到另一个块中.</p>\n\n</div>\n<h4 id=\"发送-NEAR\"><a href=\"#发送-NEAR\" class=\"headerlink\" title=\"发送$NEAR\"></a>发送$NEAR</h4><p>你可能有很多原因想要从合约发送代币:</p>\n<ul>\n<li>合约使用了类似存储标准的协议,需要再用户注销时返还资金</li>\n<li>用户支付 token 给合约,然后合约稍后支付费用给维护人员,重新分配给用户或者通过用户投票的结果支付给其他人</li>\n<li>更多…</li>\n</ul>\n<p>区块链给了我们可编程的货币,智能合约支付货币是这种能力的核心<br>NEAR 让这变的简单,如果你想要从合约中转移代币,下面是你需要做的全部:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token keyword\">let</span> amount<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u128</span> <span class=\"token operator\">=</span> <span class=\"token number\">1_000_000_000_000_000_000_000_000</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 1 $NEAR as yoctoNEAR</span>\n<span class=\"token keyword\">let</span> account_id<span class=\"token punctuation\">:</span> <span class=\"token class-name\">AccountId</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"example.near\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token class-name\">Promise</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>account_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>:::tip</p>\n<p>本文档描述的 AccountId 行为是 neaer-sdk-rs v4 的特性.这个功能在 v3 中依然可以使用,但如果你想使用更干净的 v4 语法,编写你的Cargo.toml</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token punctuation\">[</span>dependencies<span class=\"token punctuation\">]</span>\nnear<span class=\"token operator\">-</span>sdk <span class=\"token operator\">=</span> <span class=\"token string\">\"4.0.0-pre.2\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>:::<br>完整的合约上下文像下面这样</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span></span><span class=\"token punctuation\">&#123;</span><span class=\"token namespace\">json_types<span class=\"token punctuation\">::</span></span><span class=\"token constant\">U128</span><span class=\"token punctuation\">,</span> near_bindgen<span class=\"token punctuation\">,</span> <span class=\"token class-name\">AccountId</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span><span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">pay</span><span class=\"token punctuation\">(</span>amount<span class=\"token punctuation\">:</span> <span class=\"token constant\">U128</span><span class=\"token punctuation\">,</span> to<span class=\"token punctuation\">:</span> <span class=\"token class-name\">AccountId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Promise</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>to<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">transfer</span><span class=\"token punctuation\">(</span>amount<span class=\"token number\">.0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>其中大部分是你已经熟悉的样板.像 imports,设置 near_bindgen,borsh.下面是一些与转账有关的有趣细节:</p>\n<ul>\n<li><p>大写的 U 的 U128,这里的 pay 方法定义了接受 JSON 作为输入,但是 JSON 数字不能超过 2^53,也就是 9 后面只跟了 15 个 0,因为传输时使用的数量是以 yoctoNEAR 为单位,似乎需要比 2^53 大的多的数字<br>  当方法接受 U128 位输入时,这意味着调用者需要将数字转化成 string.near-sdk-rs 将 string 转化为 U128,它是 Rust 原生的 u128 的包装类.底层的 u128 可以通过.0 来使用.例如 transfer(amount.0)</p>\n</li>\n<li><p>AccountId:这个类型会自动的检查提供的 string 是否很好的匹配了 NEAR 账户 ID 的规则.当不匹配时 panic</p>\n</li>\n<li><p>返回 Promise:这将允许 NEAR Explorer,near-cli,near-api-js.和其他工具正确的判断整个交易链是否成功.如果你的函数没有返回 Promise.类似于 near-cli 会在你的调用后立刻返回.并且即使 transfer 失败,你的函数调用也会确认为成功.<a href=\"https://github.com/near-examples/rust-high-level-cross-contract/pull/73#issuecomment-902849410\">这里</a>有相关的例子.<br>使用 near-cli 来调用函数:</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">near call $CONTRACT pay &#39;&#123;&quot;amount&quot;: &quot;1000000000000000000000000&quot;, &quot;to&quot;: &quot;example.near&quot;&#125;&#39;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre></li>\n</ul>\n","text":"介绍合约能够通过 Promise 异步的发送交易.就像其他编程语言中的Promise 一样,它可以让代码在未来执行.”在未来”意味着交易将在下一个区块(或附近)执行,而不会在初始调用的区块执行.你可以使用 Promise实现任何跨合约调用链.它介于之前所说的高级调用和低级调用之间...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[],"tags":[],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">介绍</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%91%E9%80%81-NEAR\"><span class=\"toc-text\">发送$NEAR</span></a></li></ol>","author":{"name":"Bref","slug":"blog-author","avatar":"https://avatarfiles.alphacoders.com/700/70031.gif","link":"/","description":"Nothing is true,Everything is permitted.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"NEAR SDK - 合约接口","uid":"0d7a924133f95db56db161e3fcf8a116","slug":"NEAR SDK - 合约接口","date":"2022-03-11T08:48:13.455Z","updated":"2022-03-11T09:36:01.976Z","comments":true,"path":"api/articles/NEAR SDK - 合约接口.json","cover":null,"text":"公共方法类型基础实现在#[near_bindgen]宏包裹下的函数可以使用 pub标识符修饰,这样当它编译成WASM字节码以后就可以被外部调用 只讲能在外部调用的方法标记成public是很重要的.如果你需要合约自身来调用,你可以标记该方法为公共的但是添加#[private]修饰,...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[],"tags":[],"author":{"name":"Bref","slug":"blog-author","avatar":"https://avatarfiles.alphacoders.com/700/70031.gif","link":"/","description":"Nothing is true,Everything is permitted.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}