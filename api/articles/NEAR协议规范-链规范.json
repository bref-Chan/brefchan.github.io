{"title":"NEAR 协议规范 - 链规范","uid":"afa5c84143f6c6cd1bcd166aafa8f4ba","slug":"NEAR协议规范-链规范","date":"2022-03-17T05:37:04.895Z","updated":"2022-03-18T06:33:10.675Z","comments":true,"path":"api/articles/NEAR协议规范-链规范.json","keywords":"区块链, NEAR Protocol, 智能合约, 夜影协议, NEAR","cover":null,"content":"<h3 id=\"共识\"><a href=\"#共识\" class=\"headerlink\" title=\"共识\"></a>共识</h3><h4 id=\"定义和符号\"><a href=\"#定义和符号\" class=\"headerlink\" title=\"定义和符号\"></a>定义和符号</h4><p>为了维护共识,交易被分组成一个个区块(<code>block</code>).有一个预先配置的区块<strong>G</strong>被成为创世区块(<code>genesis block</code>).除了<strong>G</strong>以外的每个区块都有一个连接指向前一个区块<strong>prev(B)</strong>,<strong>B</strong>为当前区块.并且任何区块沿着连接最终都会到达<strong>G</strong>(也就是说,没有循环).</p>\n<p>区块之间的连接产生了顺序:对区块<strong>A</strong>和区块<strong>B</strong>来说,<strong>A</strong>＜<strong>B</strong>意味着<strong>A</strong>≠<strong>B</strong>并且<strong>B</strong>可以沿着与前一个区块的连接最终找到<strong>A</strong>,而<strong>A</strong>≤<strong>B</strong>意味着<strong>A</strong>＜<strong>B</strong>或<strong>A</strong>&#x3D;<strong>B</strong>.</p>\n<p><strong>＞</strong>和<strong>≥</strong>各自被定义为<strong>＜</strong>和<strong>≤</strong>相反.最后 <strong>A</strong>~<strong>B</strong>意味着<strong>A</strong>,<strong>B</strong>之间的关系为＞、＜、&#x3D;之一,<strong>A</strong>≁<strong>B</strong>意味着相反的含义.</p>\n<p>链 <strong>chain(<em>T</em>)</strong> 是一个区块集合,里面的每个区块都可以从区块<strong>T</strong>追溯到.所以,<strong>chain(<em>T</em>)</strong> &#x3D; {<strong>B</strong> | <strong>B</strong> ≤ <em><strong>T</strong></em> }.对于区块<strong>A</strong>和区块<strong>B</strong>,存在一条链让<strong>A</strong>和<strong>B</strong>都属于并且<strong>A</strong>~<strong>B</strong>.这时我们可以说,<strong>A</strong>和<strong>B</strong>在同一条链上.</p>\n<p>每个区块都有一个整数类型的高度<strong>h(<em>B</em>)</strong>.它保证区块的高度是单调的(在这里,任何非创世区块的区块B,都满足<strong>h(<em>B</em>)<strong>＞</strong>h(prev(<em>B</em>))</strong>),但他们不一定是连续的.也就是说, <strong>h(<em>G</em>)</strong> 可能不为0.每个节点都跟踪一个它知道的最大高度的有效块,这个高度被称为它的 <strong>head</strong> .</p>\n<p>区块们被分组成一个个纪元(<code>epoch</code>).在一条链中,属于同一个纪元的区块集合形成了一个连续的范围:如果区块<strong>A</strong>和区块<strong>B</strong>属于同一个纪元并且满足<strong>A</strong>＜<strong>B</strong>,那么每个满足<strong>A</strong>＜<strong>X</strong>＜<strong>B</strong>的区块也属于这个纪元.纪元也可以使用顺序索引来标识:<strong>G</strong>属于索引0,对于其他的每个区块,他的纪元索引要么与**prev(<em>B</em>)**相同,要么比其大一位.</p>\n<p>每个纪元都与一组在该纪元验证区块的块生产者(<code>block producer</code>)相关联.并且将区块高度分配给负责在该高度生产块的生产者.负责生产区块高度<em>h</em>的块生产者被称为<em>h</em>区块提议人(<code>block proposer at h</code>). 索引 <em>i≥2</em>的纪元的信息(验证人集合和高度分配)是由索引<em>i-2</em>的纪元的最后一个区块决定.对于索引为0和1的纪元,这些信息是预先配置的.所以,如果两条链共享某个纪元的最后一个块,那么它们将在两个纪元后拥有同样的验证人集合和高度分配,但在那之后的纪元就不一定了.</p>\n<p>共识协议定义了确定性(<code>finality</code>)概念.简单的说,一旦区块<strong>B</strong>被确定,那么任何未来的确定的区块只能建立在<strong>B</strong>之上.也就是说,<strong>B</strong>和其之前的块中的交易将永远无法撤销.确定性不是区块本身的方法,更确切的说,一个块在它所属的链中可能是确定的,也有可能是不确定的,具体来说,<strong>final(<em>B</em>,<em>T</em>)<strong>同时</strong>B</strong>≤<strong>T</strong>,意味着区块<strong>B</strong>在链 <strong>chain(<em>T</em>)</strong> 中被确定.一个区块在一条链中是确认的,那么在这条链的所有衍生链中也是确认的.换句话说:如果 <strong>final(<em>B,T</em>)</strong> 为真,那么 <strong>final(<em>B,T</em>)</strong> 在所有 <strong>T’</strong> ≥ <strong>T</strong> 的情况中都为真.</p>\n<h4 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h4><p>区块头中与共识相关的部分如下:</p>\n<pre class=\"line-numbers language-rus\" data-language=\"rus\"><code class=\"language-rus\">struct BlockHeader &#123;\n    ...\n    prev_hash: BlockHash,\n    height: BlockHeight,\n    epoch_id: EpochId,\n    last_final_block_hash: BlockHash,\n    approvals: Vec&lt;Option&lt;Signature&gt;&gt;\n    ...\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>同一纪元的区块生产者交换许多类型的信息.与共识有关的两种消息分别为<strong>Blocks</strong>和<strong>Approvals</strong>.<strong>Approval</strong>包含下面字段:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token keyword\">enum</span> <span class=\"token type-definition class-name\">ApprovalInner</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">Endorsement</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BlockHash</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">Skip</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">BlockHeight</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Approval</span> <span class=\"token punctuation\">&#123;</span>\n    inner<span class=\"token punctuation\">:</span> <span class=\"token class-name\">ApprovalInner</span><span class=\"token punctuation\">,</span>\n    target_height<span class=\"token punctuation\">:</span> <span class=\"token class-name\">BlockHeight</span><span class=\"token punctuation\">,</span>\n    signature<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Signature</span><span class=\"token punctuation\">,</span>\n    account_id<span class=\"token punctuation\">:</span> <span class=\"token class-name\">AccountId</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>枚举值背书(<code>Endorsement</code>)的参数是被许可的区块的hash,枚举值跳过(<code>Skip</code>)的参数是被许可的区块的高度.<code>target_height</code>是可以使用许可的特定高度(具有指定的<code>target_height</code>的许可只能被包含于<code>height==target_height</code>的区块的许可集合中).<code>account_id</code>创建许可的区块生产者的账户名,<code>signature</code>是元组<code>(inner,target_height)</code>的签名.</p>\n<h4 id=\"许可要求-Approvals-Requirements\"><a href=\"#许可要求-Approvals-Requirements\" class=\"headerlink\" title=\"许可要求 Approvals Requirements\"></a>许可要求 Approvals Requirements</h4><p>除创世区块以外,每个区块B逻辑上必须包含一些来自区块生产者许可(其格式在下一段中进行描述),并且这些许可的批准方质押的权益超过本纪元总权益的三分之二.此外,在下面描写的纪元切换情况下,还需要获得下一个纪元的超过三分之二质押量的区块生产者的许可.</p>\n<p>逻辑上区块中包含的许可都必须是背书许可并且携带的哈希值参数是当前区块前一个区块的哈希值.(the hash of prev⁡(B) if and only if h⁡(B)&#x3D;h⁡(prev⁡(B))+1),否则它必须是一个跳过许可,高度为<strong>prev(<em>B</em>)</strong>.关于为什么背书许可必须包含前一个块的哈希值,以及跳过许可必须包含高度的详细信息.参阅后面的<em>许可条件</em>小节</p>\n<p>请注意,由于逻辑上存储在区块的中的每个许可的字段对于每个区块生产者来说都是相同的(除了发送方的account_id和signature).因此存储完整的许可是多余的.实际上,我们只存储许可的签名.他们存储的具体方式如下:首先从当前纪元获得有序的区块生产者集合.如果区块在纪元边界上,并且需要包含下一个纪元的区块生产者的许可,则添加新的纪元的区块生产者.</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">get_accounts_for_block_ordered</span><span class=\"token punctuation\">(</span>h<span class=\"token punctuation\">,</span> prev_block<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    cur_epoch <span class=\"token operator\">=</span> get_next_block_epoch<span class=\"token punctuation\">(</span>prev_block<span class=\"token punctuation\">)</span>\n    next_epoch <span class=\"token operator\">=</span> get_next_block_next_epoch<span class=\"token punctuation\">(</span>prev_block<span class=\"token punctuation\">)</span>\n\n    account_ids <span class=\"token operator\">=</span> get_epoch_block_producers_ordered<span class=\"token punctuation\">(</span>cur_epoch<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> next_block_needs_approvals_from_next_epoch<span class=\"token punctuation\">(</span>prev_block<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">for</span> account_id <span class=\"token keyword\">in</span> get_epoch_block_producers_ordered<span class=\"token punctuation\">(</span>next_epoch<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n            <span class=\"token keyword\">if</span> account_id <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> account_ids<span class=\"token punctuation\">:</span>\n                account_ids<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>account_id<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> account_ids<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h4><p>当收到许可消息时,参与者将其存储到许可消息集合中:</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">on_approval</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> approval<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    self<span class=\"token punctuation\">.</span>approvals<span class=\"token punctuation\">.</span>append<span class=\"token punctuation\">(</span>approval<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>当参与者接收到一个区块时,与共识有关的操作是更新<code>head</code>然后初始化一个定时器来开始在连续的<code>target_height</code>中发送这个区块的许可给区块的生产者.定时器的延迟取决于最后一个区块的高度,所以信息将会持久化</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">on_block</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> block<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    header <span class=\"token operator\">=</span> block<span class=\"token punctuation\">.</span>header\n\n    <span class=\"token keyword\">if</span> header<span class=\"token punctuation\">.</span>height <span class=\"token operator\">&lt;=</span> self<span class=\"token punctuation\">.</span>head_height<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span>\n\n    last_final_block <span class=\"token operator\">=</span> store<span class=\"token punctuation\">.</span>get_block<span class=\"token punctuation\">(</span>header<span class=\"token punctuation\">.</span>last_final_block_hash<span class=\"token punctuation\">)</span>\n\n    self<span class=\"token punctuation\">.</span>head_height <span class=\"token operator\">=</span> header<span class=\"token punctuation\">.</span>height\n    self<span class=\"token punctuation\">.</span>head_hash <span class=\"token operator\">=</span> block<span class=\"token punctuation\">.</span><span class=\"token builtin\">hash</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    self<span class=\"token punctuation\">.</span>largest_final_height <span class=\"token operator\">=</span> last_final_block<span class=\"token punctuation\">.</span>height\n\n    self<span class=\"token punctuation\">.</span>timer_height <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head_height <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n    self<span class=\"token punctuation\">.</span>timer_started <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    self<span class=\"token punctuation\">.</span>endorsement_pending <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>定时器需要定期检查,并且包含以下逻辑:</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">get_delay</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token builtin\">min</span><span class=\"token punctuation\">(</span>MAX_DELAY<span class=\"token punctuation\">,</span> MIN_DELAY <span class=\"token operator\">+</span> DELAY_STEP <span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">process_timer</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    now <span class=\"token operator\">=</span> time<span class=\"token punctuation\">.</span>time<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n    skip_delay <span class=\"token operator\">=</span> get_delay<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>timer_height <span class=\"token operator\">-</span> self<span class=\"token punctuation\">.</span>largest_final_height<span class=\"token punctuation\">)</span>\n\t\t\n    <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>endorsement_pending <span class=\"token keyword\">and</span> now <span class=\"token operator\">></span> self<span class=\"token punctuation\">.</span>timer_started <span class=\"token operator\">+</span> ENDORSEMENT_DELAY<span class=\"token punctuation\">:</span>\n\n        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>head_height <span class=\"token operator\">>=</span> self<span class=\"token punctuation\">.</span>largest_target_height<span class=\"token punctuation\">:</span>\n            self<span class=\"token punctuation\">.</span>largest_target_height <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>head_height <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n            self<span class=\"token punctuation\">.</span>send_approval<span class=\"token punctuation\">(</span>head_height <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n        self<span class=\"token punctuation\">.</span>endorsement_pending <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span>\n\n    <span class=\"token keyword\">if</span> now <span class=\"token operator\">></span> self<span class=\"token punctuation\">.</span>timer_started <span class=\"token operator\">+</span> skip_delay<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">assert</span> <span class=\"token keyword\">not</span> self<span class=\"token punctuation\">.</span>endorsement_pending\n\n        self<span class=\"token punctuation\">.</span>largest_target_height <span class=\"token operator\">=</span> <span class=\"token builtin\">max</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>largest_target_height<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">.</span>timer_height <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n        self<span class=\"token punctuation\">.</span>send_approval<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>timer_height <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n\n        self<span class=\"token punctuation\">.</span>timer_started <span class=\"token operator\">=</span> now\n        self<span class=\"token punctuation\">.</span>timer_height <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">send_approval</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> target_height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> target_height <span class=\"token operator\">==</span> self<span class=\"token punctuation\">.</span>head_height <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n        inner <span class=\"token operator\">=</span> Endorsement<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>head_hash<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        inner <span class=\"token operator\">=</span> Skip<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>head_height<span class=\"token punctuation\">)</span>\n\n    approval <span class=\"token operator\">=</span> Approval<span class=\"token punctuation\">(</span>inner<span class=\"token punctuation\">,</span> target_height<span class=\"token punctuation\">)</span>\n    send<span class=\"token punctuation\">(</span>approval<span class=\"token punctuation\">,</span> to_whom <span class=\"token operator\">=</span> get_block_proposer<span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">.</span>head_hash<span class=\"token punctuation\">,</span> target_height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其中<code>get_block_proposer</code>根据前一个区块和下一个区块的高度返回区块提议人.</p>\n<p><code>ENDORSEMENT_DELAY &lt; MIN_DELAY</code>是必须的.此外,虽然对于正确性来说不是必须的,但我们要求<code>ENDORSEMENT_DELAY * 2 &lt;= MIN_DELAY</code></p>\n<h4 id=\"区块生产者\"><a href=\"#区块生产者\" class=\"headerlink\" title=\"区块生产者\"></a>区块生产者</h4><p>首先,我们定义了一个方便的函数来获取包含在指定高度的区块中的许可</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">get_approvals</span><span class=\"token punctuation\">(</span>self<span class=\"token punctuation\">,</span> target_height<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>approval <span class=\"token keyword\">for</span> approval\n                     <span class=\"token keyword\">in</span> self<span class=\"token punctuation\">.</span>approvals\n                     <span class=\"token keyword\">if</span> approval<span class=\"token punctuation\">.</span>target_height <span class=\"token operator\">==</span> target_height <span class=\"token keyword\">and</span>\n                        <span class=\"token punctuation\">(</span><span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>approval<span class=\"token punctuation\">.</span>inner<span class=\"token punctuation\">,</span> Skip<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> approval<span class=\"token punctuation\">.</span>prev_height <span class=\"token operator\">==</span> self<span class=\"token punctuation\">.</span>head_height <span class=\"token keyword\">or</span>\n                         <span class=\"token builtin\">isinstance</span><span class=\"token punctuation\">(</span>approval<span class=\"token punctuation\">.</span>inner<span class=\"token punctuation\">,</span> Endorsement<span class=\"token punctuation\">)</span> <span class=\"token keyword\">and</span> approval<span class=\"token punctuation\">.</span>prev_hash <span class=\"token operator\">==</span> self<span class=\"token punctuation\">.</span>head_hash<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>每当区块提议人使用<code>get_approvals</code>收到的许可的签名方的质押量超过当前纪元总质押量的三分之二时,就在该高度产生一个块.</p>\n<h4 id=\"确定性条件\"><a href=\"#确定性条件\" class=\"headerlink\" title=\"确定性条件\"></a>确定性条件</h4><p>一个区块<strong>B</strong>在链 <strong>chain(<em>T</em>)</strong> 中是确定的.当<strong>B</strong>等于<strong>G</strong>或者有一个区块<strong>X</strong> ≤ <strong>T</strong>,同时满足 <strong>B&#x3D;prev(prev(X))</strong> 和  <strong>h(X) &#x3D; h(prev(X))+1&#x3D;h(B)+2</strong> .也就是说,要么<strong>B</strong>是创世区块,要么 <strong>chain(<em>T</em>)</strong> 至少包含了基于 <strong>B</strong> 的两个区块,这三个区块(<strong>B</strong>和后面的两个区块)具有连续的高度.</p>\n<h4 id=\"纪元切换\"><a href=\"#纪元切换\" class=\"headerlink\" title=\"纪元切换\"></a>纪元切换</h4><p>有一个参数<code>epoch_length ≥ 3</code>定义了纪元的最小长度.假设一个特定的纪元<strong>ecur</strong>从高度<strong>h</strong>开始.并且假设下一个纪元是<strong>enext</strong>.假设**BP(e)<strong>是纪元e的区块生产者集合.假设</strong>lastfinal(<em>T</em>)<strong>是</strong>chain(<em>T</em>)**中最新确认的区块.下面是区块应该包含哪些区块生产者的许可,以及他们属于哪个纪元的规则:</p>\n<ul>\n<li><p>任何在纪元<strong>ecur</strong>中并符合<strong>h(prev(B))</strong> ＜ <strong>h</strong>+<strong>epoch_length</strong> - 3的区块<strong>B</strong>都必须拥有超过纪元总质押量三分之二的**BP(ecur)**的许可</p>\n<p>(说人话:每个纪元除了最后两个区块以外的所有区块都只需要本纪元区块生产者提供的许可)</p>\n</li>\n<li><p>任何在纪元<strong>ecur</strong>符合<strong>h(prev(<em>B</em>)) &gt;&#x3D;</strong> <strong>h</strong> + <strong>epochlength</strong> - 3 并且 <strong>h(lastfinal(prev(<em>B</em>))) &lt;  h+epoch_length - 3</strong> 的区块<strong>B</strong>逻辑上必须包含超过总质押量三分之二的 <strong>BP(ecur)</strong> 的许可和总质押量超过的 <strong>BP(enext)</strong> 的许可.</p>\n<p>(说人话:每个纪元的最后两个区块(因为当前区块的最好情况,last_final_height是前面的第二个区块,所以<strong>h(lastfinal(prev(<em>B</em>)))</strong> &#x3D;&#x3D; 当前当区块为最后两个时,当前区块的前两个区块必须小于 <strong>h</strong>+<strong>epoch_length</strong> - 3是一定成立的))</p>\n</li>\n<li><p>任何在纪元<strong>enext</strong>中并符合<strong>h(prev(B))</strong> ＜ <strong>h</strong>+<strong>epoch_length</strong> - 3的区块<strong>B</strong>都必须拥有超过纪元总质押量三分之二的**BP(enext)**的许可</p>\n</li>\n</ul>\n<h4 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h4><p>注意在上面的实现中,一个诚实的区块生产者不会产出两个具有相同<code>prev_height</code>的背书(这被称为背书冲突).它也不会产生跳过消息s和背书e同时满足<code>s.prev_height &lt; e.prev_height</code>并且<code>s.target_height &gt;= e.target_height</code></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>说人话:即一个诚实的参与者如果在一个背书许可之前发出了一个跳过许可,那么跳过许可的target_height必然小于背书许可的target_height</p></blockquote>\n<p><strong>定理</strong>:假设有区块<strong>B1</strong>、<strong>B2</strong>,<strong>T1</strong>和<strong>T2</strong>,使得<strong>B1</strong>≁<strong>B2</strong>,并且<strong>final(<em>B1</em>,<em>T1</em>)</strong> ,<strong>final(<em>B2</em>,<em>T2</em>)</strong> ,此时,超过三分之一的区块生产者必须签署过相互冲突的背书或相互冲突的跳过和背书.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>说人话:如果有区块<strong>B1</strong>,<strong>B2</strong>,<strong>T1</strong>,<strong>T2</strong>,<strong>B1</strong>和<strong>B2</strong>不在同一条链上(即链在他们之前进行了分叉).同时<strong>T1</strong>在<strong>B1</strong>后,<strong>T2</strong>在<strong>B2</strong>后,并且在**链(T1)<strong>中,<strong>B1</strong>被确定,在</strong>链(T2)**中,<strong>B2</strong>被确定(即分叉上的两个区块都拥有确定性).那么意味着超过三分之一的区块生产者作恶了.要倒霉了.</p></blockquote>\n<p><strong>证明</strong>:在不丧失普遍性的情况下,我们可以假设这些区块的高度是尽可能小.明确的说,我们可以假设<strong>h(T1)</strong> &#x3D; <strong>h(B1)</strong> + 2并且<strong>h(T2)</strong> &#x3D; <strong>h(B2)</strong>+2.同时,<strong>Bc</strong>是<strong>B1</strong>和<strong>B2</strong>共同的祖先中最高的块.我们可以确定,不存在区块<strong>X</strong>同时满足<strong>final(<em>X</em>,<em>T1</em>)<strong>和</strong>Bc</strong>＜<strong>X</strong>&lt;<strong>B1</strong>以及<strong>final(<em>X</em>,<em>T2</em>)<strong>和</strong>Bc</strong>＜<strong>X</strong>＜<strong>B2</strong>.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>说人话:现在已知<strong>B1</strong>和<strong>B2</strong>分叉了.那么假设一个区块<strong>Bc</strong>是他们分叉的那个区块,那么在该区块后,不存在一个区块<strong>X</strong>同时存在于两条链中,所以不能同时满足: <strong>final(<em>X</em>,<em>T1</em>)<strong>和</strong>Bc</strong>＜<strong>X</strong>&lt;<strong>B1</strong>以及<strong>final(<em>X</em>,<em>T2</em>)<strong>和</strong>Bc</strong>＜<strong>X</strong>＜<strong>B2</strong>.</p></blockquote>\n<p><strong>辅助定理</strong>:必然存在一个纪元<strong>E</strong>,里面有任意区块<strong>X</strong>,只要满足<strong>Bc</strong>&lt;<strong>X</strong>≤<strong>T1</strong>或<strong>Bc</strong>&lt;<strong>X</strong>≤<strong>T2</strong>,那么该区块一定包含有<strong>E</strong>中超过三分之二个区块生产者的许可.</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>说人话:如果出现了定理中假设的情况,那么肯定有一个纪元中的区块生产者中出了叛徒,而且叛徒数量超过总量的三分之一</p></blockquote>\n<p><strong>证明</strong>:有两种情况:</p>\n<p><strong>第一种情况</strong>:区块<strong>Bc</strong>,<strong>T1</strong>,<strong>T2</strong>在同一纪元中.</p>\n<p>因为在指定纪元中的指定链上的区块是连续的,所以他们之间的区块(区块 <strong>X</strong> 满足 <strong>Bc</strong> ＜ <strong>X</strong> ＜ <strong>T1</strong> 或者 <strong>Bc</strong> ＜ <strong>X</strong> ＜ <strong>T2</strong> )也位于同一纪元.</p>\n<p><strong>第二种情况</strong>:区块 <strong>Bc</strong> 、<strong>T1</strong> 和 <strong>T2</strong> 不全在同一个纪元中.</p>\n<p>假设 <strong>Bc</strong> 和 <strong>T1</strong> 不在同一个纪元中,设 <strong>E</strong> 是 <strong>T1</strong> 所在的纪元, <strong>E</strong> 之前的纪元设为 <strong>Ep</strong> (所以 <strong>T1</strong> 不能处于创世区块所在的纪元).假设 <strong>R</strong> 和 <strong>S</strong> 分别为 <strong>链(T1)</strong> 在<strong>Ep</strong>中的第一个和最后一个区块.此时,<strong>Ep</strong>中一定存在一个区块 <strong>F</strong> 满足 <strong>h(F)</strong> + 2 &#x3D; <strong>h(S)</strong> ＜ <strong>h(T1)</strong>.因为 <strong>h(F)</strong> ＜ <strong>h(T1)</strong> - 2,我们能得到<strong>F</strong> &lt; <strong>B1</strong>,并且因为不存在一个确定的区块<strong>X</strong>满足 <strong>Bc</strong> &lt; <strong>X</strong> &lt; <strong>B1</strong>, 我们得出结论:<strong>F</strong> ≤ <strong>Bc</strong>.因为在<strong>E</strong>和<strong>Ep</strong>之间没有其他的纪元了,我们可以得出结论:<strong>Bc</strong>在纪元<strong>Ep</strong>中.同样因为 <strong>h(Bc)</strong> ≥ <strong>h(F)</strong> ≥ <strong>h(R)</strong> + <strong>epochlength</strong> - 3.这样可以得出, <strong>Bc</strong> 之后直到 <strong>E</strong> 结束的所有区块都包含超过 <strong>E</strong> 中三分之二的区块生产者的许可.</p>\n<p>应用同样的参数给 <strong>chain(T2)</strong> ,我们能确定 <strong>T2</strong> 同时存在于 <strong>E</strong> 和 <strong>Ep</strong> 中,这样在 <strong>E</strong> 中任何区块 <strong>X</strong> 只要满足 <strong>Bc</strong> &lt; <strong>X</strong> ≤  <strong>T2</strong> ,就都包含了 <strong>E</strong> 中超过三分之二的区块生产者的许可( <strong>E</strong> 中的生产者集合在 <strong>链(T1)</strong> 和 <strong>链(T2)</strong> 中是一样的.因为 <strong>Ep</strong> 之前的纪元的最后一个区块一定在 <strong>Bc</strong> 之前,所以 <strong>E</strong> 中区块生产者由两条链共享).对于 <strong>Bc</strong> 和 <strong>T1</strong> 在同一纪元,而 <strong>Bc</strong> 和 <strong>T2</strong> 在不同纪元的情况,处理方法类似.这样,辅助定理就被证明了.</p>\n<p>现在我们回到 <strong>定理</strong> .在不丧失普遍性的情况下.假设 <strong>h(B1)</strong> ≤ <strong>h(B2)</strong> .一方面,如果 <strong>链(<em>T2</em>)</strong> 不包括高度为 <strong>h(B1)</strong> 的区块 ,那么链中第一个区块的高度就一定比 <strong>h(B1)</strong> 大.并且该区块包含了 <strong>E</strong> 中超过三分之二的区块生产者发出的跳过许可,并且一定与 <strong>T1</strong> 之前的一个区块冲突.所以,<strong>E</strong>中超过三分之一的区块生产者签署了相互冲突的跳过许可和背书许可.同样, <strong>链(<em>T2</em>)</strong> 不能包含高度为 <strong>h(B1)</strong> +1的区块.那么在<strong>E</strong>中有超过三分之一的区块生产者在 <strong>T1</strong> 中签署的背书,在 <strong>T2</strong> 中高度大于第一个区块中签署了跳过.另一方面,如果 <strong>链(<em>T2</em>)</strong> 包含的有高度为 <strong>h(B1)</strong> 和 <strong>h(B1)</strong> +1的区块.那么后者必须包括前者的背书,这与对 <strong>B1</strong> 的背书冲突.所以,在 <strong>E</strong> 中有超过三分之一的区块生产者签署了冲突的背书,所以. <strong>定理</strong> 成立.</p>\n<h4 id=\"活性\"><a href=\"#活性\" class=\"headerlink\" title=\"活性\"></a>活性</h4><p>你可以在<a href=\"https://near.ai/doomslug\">near.ai&#x2F;doomslug</a>看到关于活性的证明.本节中的共识与它的不同之处在于,它需要通过连续两次背书.链接文件中的证明进行了简单的拓展,通过观察发现,一旦延迟足够长,一个诚实的区块生产者总是可以收集到足够的背书,下一个区块生产者也应该有足够的时间收集背书.</p>\n<h4 id=\"许可条件\"><a href=\"#许可条件\" class=\"headerlink\" title=\"许可条件\"></a>许可条件</h4><p>前面提到的许可条件是:</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>任何有效的区块逻辑上必须包含超过当前纪元三分之二的区块生产者的许可.对于区块 B 和它前一个区块 B’ 来说,有且仅有<code>B.height ==B&#39;.height+1</code>时, B 中的每个许可都必须是背书许可并包含有 B’ 的hash,此外的所有情况, B 中的所有许可必须是 B’ 的跳过许可</p></blockquote>\n<p>这比预想的要复杂的多,人们经常会把这两个条件同意起来.但不幸的是,他们不能同统一.</p>\n<p>对于背书许可来说,每个许可的<code>prev_hash</code>都等于前一个区块的哈希值,这一点很关键,否则上面的安全证明就不起作用了.在上面所说的第二种情况中,<strong>B1</strong>和<strong>Bx</strong>中的背书就可以是完全相同的.</p>\n<p>对于跳过消息,我们不要求许可中的哈希值和前一个哈希值匹配,这一点很关键.因为恶意的参与者可以创建两个高度相同的块,并将他们分别分配给一半的区块生产者.两个半区的区块生产者向未来的区块提议人发送带有不同<code>prev_hash</code>但是具有相同<code>prev_height</code>的跳过消息.如果要求跳过消息中<code>prev_hash</code>和区块的<code>prev_hash</code>完全匹配,那么没有一个区块生产者可以创建他们的区块.</p>\n","feature":true,"text":"共识定义和符号为了维护共识,交易被分组成一个个区块(block).有一个预先配置的区块G被成为创世区块(genesis block).除了G以外的每个区块都有一个连接指向前一个区块prev(B),B为当前区块.并且任何区块沿着连接最终都会到达G(也就是说,没有循环). 区块之间的...","link":"","photos":[],"count_time":{"symbolsCount":"8.9k","symbolsTime":"8 mins."},"categories":[{"name":"NEAR协议规范","slug":"NEAR协议规范","count":1,"path":"api/categories/NEAR协议规范.json"}],"tags":[{"name":"NEAR","slug":"NEAR","count":8,"path":"api/tags/NEAR.json"},{"name":"NEAR Protocol","slug":"NEAR-Protocol","count":1,"path":"api/tags/NEAR-Protocol.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B1%E8%AF%86\"><span class=\"toc-text\">共识</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89%E5%92%8C%E7%AC%A6%E5%8F%B7\"><span class=\"toc-text\">定义和符号</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">数据结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%B8%E5%8F%AF%E8%A6%81%E6%B1%82-Approvals-Requirements\"><span class=\"toc-text\">许可要求 Approvals Requirements</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">消息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%9D%97%E7%94%9F%E4%BA%A7%E8%80%85\"><span class=\"toc-text\">区块生产者</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A1%AE%E5%AE%9A%E6%80%A7%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">确定性条件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%AA%E5%85%83%E5%88%87%E6%8D%A2\"><span class=\"toc-text\">纪元切换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8%E6%80%A7\"><span class=\"toc-text\">安全性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B4%BB%E6%80%A7\"><span class=\"toc-text\">活性</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%B8%E5%8F%AF%E6%9D%A1%E4%BB%B6\"><span class=\"toc-text\">许可条件</span></a></li></ol></li></ol>","author":{"name":"Bref","slug":"blog-author","avatar":"https://avatarfiles.alphacoders.com/700/70031.gif","link":"/","description":"Nothing is true,Everything is permitted.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"NEAR SDK - 减小合约尺寸","uid":"4d320b648a660e01f33dcb34ec3dc14e","slug":"NEAR SDK - 减小合约尺寸","date":"2022-03-16T09:39:28.918Z","updated":"2022-03-16T10:26:36.117Z","comments":true,"path":"api/articles/NEAR SDK - 减小合约尺寸.json","keywords":"区块链, NEAR Protocol, 智能合约, 夜影协议, NEAR","cover":null,"text":"建议和示例本文是为熟悉低级概念的开发人员编写的,这些开发人员希望以牺牲代码可读性为代价,显著的减少合约的尺寸. 这些方法可能有用的一些常见场景: 与个人账户管理绑定的合约 使用工厂部署的合约 未来的发展,比如运行在NEAR上的EVM Small wins使用标记当编译合约时,确保...","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"文档翻译","slug":"文档翻译","count":7,"path":"api/categories/文档翻译.json"}],"tags":[{"name":"NEAR","slug":"NEAR","count":8,"path":"api/tags/NEAR.json"},{"name":"near-sdk-rs","slug":"near-sdk-rs","count":7,"path":"api/tags/near-sdk-rs.json"}],"author":{"name":"Bref","slug":"blog-author","avatar":"https://avatarfiles.alphacoders.com/700/70031.gif","link":"/","description":"Nothing is true,Everything is permitted.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}