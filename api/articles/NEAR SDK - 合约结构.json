{"title":"NEAR SDK - 合约结构","uid":"5e99360b3a18af11a239b4863047980f","slug":"NEAR SDK - 合约结构","date":"2022-03-14T06:18:47.231Z","updated":"2022-03-14T10:33:22.576Z","comments":true,"path":"api/articles/NEAR SDK - 合约结构.json","keywords":"区块链, NEAR Protocol, 智能合约, 夜影协议, NEAR","cover":null,"content":"<h3 id=\"near-bindgen\"><a href=\"#near-bindgen\" class=\"headerlink\" title=\"near_bindgen\"></a>near_bindgen</h3><pre class=\"line-numbers language-#[near_bindgen]```宏被用于结构体和方法实现中以生成必要的代码使其成为一个可用的NEAR合约并且暴露想要公开的方法并使其能够被外部调用\" data-language=\"#[near_bindgen]```宏被用于结构体和方法实现中以生成必要的代码使其成为一个可用的NEAR合约并且暴露想要公开的方法并使其能够被外部调用\"><code class=\"language-#[near_bindgen]```宏被用于结构体和方法实现中以生成必要的代码使其成为一个可用的NEAR合约并且暴露想要公开的方法并使其能够被外部调用\">\n例如,下面是一个简单的计数合约,&#96;&#96;&#96;#[near_bindgen]&#96;&#96;&#96;宏被这样使用:\n\n&#96;&#96;&#96;rust\nuse near_sdk::borsh::&#123;self, BorshDeserialize, BorshSerialize&#125;;\nuse near_sdk::near_bindgen;\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct Counter &#123;\n    value: u64,\n&#125;\n\n#[near_bindgen]\nimpl Counter &#123;\n    pub fn increment(&amp;mut self) &#123;\n        self.value +&#x3D; 1;\n    &#125;\n\n    pub fn get_count(&amp;self) -&gt; u64 &#123;\n        self.value\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<p>在上面的例子中,<code>Counter</code>结构体相当于智能合约的状态,可以包含任何实现了BorshDeserialize和BorshSerialize的成员,甚至是集合,我们将在后面讨论它.当方法被调用时,合约状态将被加载并反序列化,因此,保证加载的数据尽可能少是很重要的.</p>\n<pre class=\"line-numbers language-#[near_bindgen]```同样可以注释```Counter```的方法实现,这将生成必要的模板文件来暴露这些方法.我们必须牢记核心的交互规则:\" data-language=\"#[near_bindgen]```同样可以注释```Counter```的方法实现,这将生成必要的模板文件来暴露这些方法.我们必须牢记核心的交互规则:\"><code class=\"language-#[near_bindgen]```同样可以注释```Counter```的方法实现,这将生成必要的模板文件来暴露这些方法.我们必须牢记核心的交互规则:\">\n* 任何&#96;&#96;&#96;pub&#96;&#96;&#96;方法都能在外部被账户&#x2F;合约调用.\n  * 更多的信息,查看[公共方法类型](https:&#x2F;&#x2F;www.near-sdk.io&#x2F;contract-interface&#x2F;public-methods)\n* &#96;&#96;&#96;self&#96;&#96;&#96;有多种用法来控制合约的可变性\n  * 使用&#96;&#96;&#96;&amp;self&#96;&#96;&#96;和&#96;&#96;&#96;self&#96;&#96;&#96;的方法将是只读的.并且不会写入和更新存储中的状态\n  * 使用&#96;&#96;&#96;&amp;mut self&#96;&#96;&#96;的方法将允许改变状态,状态将在合约调用结束后写入存储\n* 如果公开的函数的参数不包括&#96;&#96;&#96;self&#96;&#96;&#96;.那么它的调用可以省略状态读写\n  * 这对于一些静态功能或返回嵌入在合约代码中的数据可能很有用.\n* 如果函数有返回值,它将被序列化并且通过&#96;&#96;&#96;env::value_return&#96;&#96;&#96;作为结果附加\n\n#### 初始化方法\n\n默认的,合约的&#96;&#96;&#96;Default::default()&#96;&#96;&#96;实现会用于合约的初始化.也可以有一个自定义的初始化函数,它接受参数并执行自定义逻辑.初始化韩式放在&#96;&#96;&#96;#[init]&#96;&#96;&#96;标注下\n\n&#96;&#96;&#96;rust\n#[near_bindgen]\nimpl Counter &#123;\n    #[init]\n    pub fn new(value: u64) -&gt; Self &#123;\n        log!(&quot;Custom counter initialization!&quot;);\n        Self &#123; value &#125;\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>所有合约都预先实现了<code>Default</code>,如果你想要禁止使用default实现,<code>PanicOnDefault</code>宏可以做到这一点:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token attribute attr-name\">#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Counter</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"可支付方法\"><a href=\"#可支付方法\" class=\"headerlink\" title=\"可支付方法\"></a>可支付方法</h4><p>方法可以标注为<code>#[payable]</code>以允许方法在调用时进行通证的转移.更多的信息,查看<a href=\"https://www.near-sdk.io/contract-interface/payable-methods\">可支付方法</a></p>\n<p>下面的例子使用<code>#[payable]</code>注释宣告了函数是可支付的:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[payable]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">my_method</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h4><p>有些方法需要公开以允许合约通过<code>Promise</code>调用自身的方法,但是又不允许其他任何合约&#x2F;账户调用它.为此,使用<code>#[private]</code>注释方法以使得外部合约&#x2F;账户的调用会导致<code>panic</code>.更多的信息,查看<a href=\"https://www.near-sdk.io/contract-interface/payable-methods\">私有方法</a></p>\n<p>该注释通过以下的方式应用</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[private]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">my_method</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>当决定应用程序数据使用的数据结构时,重要的是尽可能减少读取和写入存储的数据量,以及反序列化和序列化的数据量,以尽可能的减少交易成本.理解智能合约中的不同数据结构的侧重点非常重要,因为随着程序的扩展,它将成为瓶颈,并且将状态迁移至新的数据结构会付出代价.</p>\n<pre class=\"line-numbers language-near-sdk```中的容易被设计成将数据分割成块,并且只会在需要时才进行读取和写入.这些数据结构负责和存储的低级交互并且被设计成与```std::collections```具有相同的API.\" data-language=\"near-sdk```中的容易被设计成将数据分割成块,并且只会在需要时才进行读取和写入.这些数据结构负责和存储的低级交互并且被设计成与```std::collections```具有相同的API.\"><code class=\"language-near-sdk```中的容易被设计成将数据分割成块,并且只会在需要时才进行读取和写入.这些数据结构负责和存储的低级交互并且被设计成与```std::collections```具有相同的API.\">\n&gt; &#96;&#96;&#96;near_sdk::collections&#96;&#96;&#96;将迁移至&#96;&#96;&#96;near_sdk::store&#96;&#96;&#96;并更新了API.如果你想要访问这些更新的结构体实现,启用&#96;&#96;&#96;unstable&#96;&#96;&#96;特性在&#96;&#96;&#96;near-sdk&#96;&#96;&#96;中.\n\n在使用&#96;&#96;&#96;std::collections&#96;&#96;&#96;时需要牢记,每次状态被加载时,数据结构中的所有数据都将被读取和反序列化.这将为使用任何非少量的数据带来巨大的开销.所以为了最小化gas使用量,大多数情况下,应该是用SDK中的集合.\n\nSDK中存在如下数据结构:\n\n| SDK集合                 | &#96;&#96;&#96;std&#96;&#96;&#96;等价物     | 描述                                                         |\n| ----------------------- | ------------------- | ------------------------------------------------------------ |\n| &#96;&#96;&#96;LazyOption&lt;T&gt;&#96;&#96;&#96;     | &#96;&#96;&#96;Option&lt;T&gt;&#96;&#96;&#96;     | 存储中可选的值.该类型只会在交互时才从存储中读取.当值存在于存储中时,会以 Some&lt;T&gt;的类型提供,当不存在时返回 None |\n| &#96;&#96;&#96;Vecttor&lt;T&gt;&#96;&#96;&#96;        | &#96;&#96;&#96;Vec&lt;T&gt;&#96;&#96;&#96;        | 可增长的数组类型.这些值在内存中分片,可以被迭代,并且索引值是可以动态调整大小的 |\n| &#96;&#96;&#96;LookupMap&lt;K,V&gt;&#96;&#96;&#96;    | &#96;&#96;&#96;HashMap&lt;K,V&gt;&#96;&#96;&#96;  | 该结构相当于一个合约可用的 map的廋包装体.该结构不包含任何关于 map 中元素的元数据,因此不可迭代 |\n| &#96;&#96;&#96;unorderedMap&lt;K,V&gt;&#96;&#96;&#96; | &#96;&#96;&#96;HashMap&lt;K,V&gt;&#96;&#96;&#96;  | 与 LookupMap 类似,除了该结构保存能让内部元素进行迭代的额外数据 |\n| &#96;&#96;&#96;TreeMap&lt;K,V&gt;&#96;&#96;&#96;      | &#96;&#96;&#96;BTreeMap&lt;K,V&gt;&#96;&#96;&#96; | UnorderedMap 的有序等价物.当需要一致的顺序或者访问最小,最大键时,应该使用这个结构.底层实现基于 AVL tree |\n| &#96;&#96;&#96;LookupSet&lt;T&gt;&#96;&#96;&#96;      | &#96;&#96;&#96;HashSet&lt;T&gt;&#96;&#96;&#96;    | 类似于 LookupMap 的 Set,但不存储和值.只被用来检查特定值是否存在.该结构不能迭代并且只能用来查找 |\n| &#96;&#96;&#96;UnorderedSet&lt;T&gt;&#96;&#96;&#96;   | &#96;&#96;&#96;HashSet&lt;T&gt;&#96;&#96;&#96;    | LookupMap 的可迭代等价物,它存储了一些关于 Set 内部元素的额外信息 |\n\n\n\n#### 内存中的 &#96;&#96;&#96;HashMap&#96;&#96;&#96; vs 持久化的 &#96;&#96;&#96;UnorderedMap&#96;&#96;&#96;\n\n* &#96;&#96;&#96;HashMap&#96;&#96;&#96; 保持所有数据在内存中,为了访问它,合约需要反序列化整个 Map\n* &#96;&#96;&#96;UnorderedMap&#96;&#96;&#96; 保持所有数据在存储中,访问任何元素只需要反序列化该元素.\n\n在什么时候使用 &#96;&#96;&#96;HashMap&#96;&#96;&#96;?\n\n* 需要在一次方法调用中迭代集合中的所有元素\n* 元素数量小或固定.例如小于 10 个\n\n在什么时候使用 &#96;&#96;&#96;UnorrderedMap&#96;&#96;&#96;?\n\n* 需要访问整个集合中有限的子集合,例如每次调用只需要访问 1 个或 2 个元素\n* 无法将整个集合放入内存,例如数据量过大\n\n原因是 &#96;&#96;&#96;HashMap&#96;&#96;&#96;&#96; 在一个存储操作中反序列化(或序列化)整个集合.比通过 &#96;&#96;&#96;N&#96;&#96;&#96; 个存储操作访问所有元素更加节约 gas 费\n\n使用&#96;&#96;&#96;HashMap&#96;&#96;&#96;的示例:\n\n&#96;&#96;&#96;rust\n&#x2F;&#x2F;&#x2F; Using Default initialization.\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct Contract &#123;\n    pub status_updates: HashMap&lt;AccountId, String&gt;,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn set_status(&amp;mut self, status: String) &#123;\n        self.status_updates.insert(env::predecessor_account_id(), status);\n        assert!(self.status_updates.len() &lt;&#x3D; 10, &quot;Too many messages&quot;);\n    &#125;\n\n    pub fn clear(&amp;mut self) &#123;\n        &#x2F;&#x2F; Effectively iterating through all removing them.\n        self.status_updates.clear();\n    &#125;\n\n    pub fn get_all_updates(self) -&gt; HashMap&lt;AccountId, String&gt; &#123;\n        self.status_updates\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>使用<code>UnorderedMap</code>的示例:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token attribute attr-name\">#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">pub</span> status_updates<span class=\"token punctuation\">:</span> <span class=\"token class-name\">UnorderedMap</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">AccountId</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token attribute attr-name\">#[init]</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// Initializing `status_updates` with unique key prefix.</span>\n        <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">&#123;</span>\n            status_updates<span class=\"token punctuation\">:</span> <span class=\"token class-name\">UnorderedMap</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token string\">b\"s\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">to_vec</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">set_status</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> status<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>status_updates<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">predecessor_account_id</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>status<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// Note, don't need to check size, since `UnorderedMap` doesn't store all data in memory.</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">delete_status</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>status_updates<span class=\"token punctuation\">.</span><span class=\"token function\">remove</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">predecessor_account_id</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get_status</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> account_id<span class=\"token punctuation\">:</span> <span class=\"token class-name\">AccountId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Option</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token operator\">></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>status_updates<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>account_id<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"使用持久化集合进行分页\"><a href=\"#使用持久化集合进行分页\" class=\"headerlink\" title=\"使用持久化集合进行分页\"></a>使用持久化集合进行分页</h4><p>分页集合例如 <code>UnorderedMap</code>,<code>UnorderedSet</code>,和 <code>Vector</code> 可能包含的元素数量超过了 gas 限制下的读取数量.为了通过<code>view</code>调用来公开显示他们,我们可以实现分页.</p>\n<pre class=\"line-numbers language-Vector```\" data-language=\"Vector```\"><div class=\"caption\"><span>通过使用```.get(index)```来获取指定下标的元素</span></div><code class=\"language-Vector```\">\n要在 &#96;&#96;&#96;UnorderedSet&#96;&#96;&#96; 使用下标来访问元素.我们可以使用&#96;&#96;&#96; .as_vector()&#96;&#96;&#96;方法,该方法将返回元素的 &#96;&#96;&#96;Vector&#96;&#96;&#96;\n\n关于 &#96;&#96;&#96;UnoderedMap&#96;&#96;&#96; 我们需要将 keys 和 values 转换成 &#96;&#96;&#96;Vector&#96;&#96;&#96;,分别使用&#96;&#96;&#96;.keys_as_vector()&#96;&#96;&#96;和&#96;&#96;&#96;.values_as_vector()&#96;&#96;&#96;\n\n使用&#96;&#96;&#96;UnorderedMap&#96;&#96;&#96;实现分页的示例:\n\n&#96;&#96;&#96;rust\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract &#123;\n    pub status_updates: UnorderedMap&lt;AccountId, String&gt;,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    &#x2F;&#x2F;&#x2F; Retrieves multiple elements from the &#96;UnorderedMap&#96;.\n    &#x2F;&#x2F;&#x2F; - &#96;from_index&#96; is the index to start from.\n    &#x2F;&#x2F;&#x2F; - &#96;limit&#96; is the maximum number of elements to return.\n    pub fn get_updates(&amp;self, from_index: u64, limit: u64) -&gt; Vec&lt;(AccountId, String)&gt; &#123;\n        let keys &#x3D; self.status_updates.keys_as_vector();\n        let values &#x3D; self.status_updates.values_as_vector();\n        (from_index..std::cmp::min(from_index + limit, self.status_updates.len()))\n            .map(|index| (keys.get(index).unwrap(), values.get(index).unwrap()))\n            .collect()\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"LookupMapvsUnorderedMap\"><a href=\"#LookupMapvsUnorderedMap\" class=\"headerlink\" title=\"LookupMapvsUnorderedMap\"></a><code>LookupMap</code>vs<code>UnorderedMap</code></h4><h5 id=\"功能性\"><a href=\"#功能性\" class=\"headerlink\" title=\"功能性\"></a>功能性</h5><ul>\n<li><code>UnorderedMap</code>支持迭代keys和values,并且支持分页.在内部,它拥有三个存储结构<ul>\n<li>一个存储key与index关系的map</li>\n<li>一个keys的数组</li>\n<li>一个values的数组</li>\n</ul>\n</li>\n<li><code>LookupMap</code>只拥有一个存储key和value关系的map.没有存储keys的数组,所以它没有能力进行keys的迭代</li>\n</ul>\n<h5 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h5><pre class=\"line-numbers language-LookupMap```比```UnorderedMap```拥有更好的性能和存储更少的数据\" data-language=\"LookupMap```比```UnorderedMap```拥有更好的性能和存储更少的数据\"><code class=\"language-LookupMap```比```UnorderedMap```拥有更好的性能和存储更少的数据\">\n* &#96;&#96;&#96;UnorderedMap&#96;&#96;&#96;获取数据时需要2次读取操作,写入或插入数据时需要3次写入操作\n* &#96;&#96;&#96;LookupMap&#96;&#96;&#96;读取时需要1次读取操作,写入时需要1次写入操作\n\n##### 存储空间\n\n&#96;&#96;&#96;UnorderedMap&#96;&#96;&#96;比&#96;&#96;&#96;LookupMap&#96;&#96;&#96;需要更多的存储空间\n\n* &#96;&#96;&#96;UnorderedMap&#96;&#96;&#96;存储key两次(一次在map中,一次在数组中)和value一次.同时需要更高级别的常量来存储数组的长度和前缀\n* &#96;&#96;&#96;LookupMap&#96;&#96;&#96;存储key,value各一次\n\n\n\n#### &#96;&#96;&#96;LazyOption&#96;&#96;&#96;\n\n这是一个只存储单个值的持久化集合,目标是阻止合约在不需要使用该值时进行反序列化.一个例子是存在一个大的元数据块,它只在&#96;&#96;&#96;view&#96;&#96;&#96;调用中使用,在大多数合约操作中不需要使用.\n\n它的作用类似于&#96;&#96;&#96;Option&#96;&#96;&#96;,可以保存值们也可以不保存值,同时还需要一个唯一的前缀,就像其他持久化集合一样.\n\n与其他集合一样,LazyOption只允许在初始化过程中初始化值.\n\n&#96;&#96;&#96;rust\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract &#123;\n    pub metadata: LazyOption&lt;Metadata&gt;,\n&#125;\n\n#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]\n#[serde(crate &#x3D; &quot;near_sdk::serde&quot;)]\npub struct Metadata &#123;\n    data: String,\n    image: Base64Vec,\n    blobs: Vec&lt;String&gt;,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new(metadata: Metadata) -&gt; Self &#123;\n        Self &#123;\n            metadata: LazyOption::new(b&quot;m&quot;, Some(metadata)),\n        &#125;\n    &#125;\n\n    pub fn get_metadata(&amp;self) -&gt; Metadata &#123;\n        &#x2F;&#x2F; &#96;.get()&#96; reads and deserializes the value from the storage. \n        self.metadata.get().unwrap()\n    &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n<h4 id=\"集合嵌套\"><a href=\"#集合嵌套\" class=\"headerlink\" title=\"集合嵌套\"></a>集合嵌套</h4><h5 id=\"使用传统方式构造唯一前缀\"><a href=\"#使用传统方式构造唯一前缀\" class=\"headerlink\" title=\"使用传统方式构造唯一前缀\"></a>使用传统方式构造唯一前缀</h5><p>在构造函数中使用一个硬编码的短字母前缀,该前缀将转换为字节 vector.使用嵌套集合,该前缀必须手动构造</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token attribute attr-name\">#[init]</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">&#123;</span>\n            accounts<span class=\"token punctuation\">:</span> <span class=\"token class-name\">UnorderedMap</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token string\">b\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            tokens<span class=\"token punctuation\">:</span> <span class=\"token class-name\">LookupMap</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token string\">b\"t\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            metadata<span class=\"token punctuation\">:</span> <span class=\"token class-name\">LazyOption</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token string\">b\"m\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get_tokens</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> account_id<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token class-name\">AccountId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">UnorderedSet</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token operator\">></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">let</span> tokens <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>accounts<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>account_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap_or_else</span><span class=\"token punctuation\">(</span><span class=\"token closure-params\"><span class=\"token closure-punctuation punctuation\">|</span><span class=\"token closure-punctuation punctuation\">|</span></span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">// Constructing a unique prefix for a nested UnorderedSet.</span>\n            <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> prefix <span class=\"token operator\">=</span> <span class=\"token class-name\">Vec</span><span class=\"token punctuation\">::</span><span class=\"token function\">with_capacity</span><span class=\"token punctuation\">(</span><span class=\"token number\">33</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// Adding unique prefix.</span>\n            prefix<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token char\">b's'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token comment\">// Adding the hash of the account_id (key of the outer map) to the prefix.</span>\n            <span class=\"token comment\">// This is needed to differentiate across accounts.</span>\n            prefix<span class=\"token punctuation\">.</span><span class=\"token function\">extend</span><span class=\"token punctuation\">(</span><span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">sha256</span><span class=\"token punctuation\">(</span>account_id<span class=\"token punctuation\">.</span><span class=\"token function\">as_bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token class-name\">UnorderedSet</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>prefix<span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        tokens\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h5 id=\"为持久化容器生产前缀\"><a href=\"#为持久化容器生产前缀\" class=\"headerlink\" title=\"为持久化容器生产前缀\"></a>为持久化容器生产前缀</h5><p>每个持久化容器都需要一个唯一的前缀.该前缀被用于生成内部的键以持久化的存储数据.这些内部的键必须是唯一的以避免冲突(包括 <code>STATE</code> 的键冲突)<br>当一个合约变的复杂,可能会有多个不同的集合,他们不是主结构的全部组成部分.而是子结构或嵌套容易,他们都需要唯一的前缀<br>我们可以引入一个 <code>enum</code> 来追踪存储前缀和键.然后它们使用 borsh 序列化来为每个容器构造一个唯一的前缀.<br>它与手工构造一样高效,因为 borsh 序列化,一个<code>enum</code>只需要 1 个 字节</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token keyword\">use</span> <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span></span><span class=\"token class-name\">BorshStorageKey</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token attribute attr-name\">#[derive(BorshStorageKey, BorshSerialize)]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">enum</span> <span class=\"token type-definition class-name\">StorageKeys</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token class-name\">Accounts</span><span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">SubAccount</span> <span class=\"token punctuation\">&#123;</span> account_hash<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Vec</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">u8</span><span class=\"token operator\">></span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">Tokens</span><span class=\"token punctuation\">,</span>\n    <span class=\"token class-name\">Metadata</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token attribute attr-name\">#[init]</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">new</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">&#123;</span>\n            accounts<span class=\"token punctuation\">:</span> <span class=\"token class-name\">UnorderedMap</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StorageKeys</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">Accounts</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            tokens<span class=\"token punctuation\">:</span> <span class=\"token class-name\">LookupMap</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StorageKeys</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">Tokens</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n            metadata<span class=\"token punctuation\">:</span> <span class=\"token class-name\">LazyOption</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">StorageKeys</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">Metadata</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    \n    <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get_tokens</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> account_id<span class=\"token punctuation\">:</span> <span class=\"token operator\">&amp;</span><span class=\"token class-name\">AccountId</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">UnorderedSet</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token operator\">></span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">let</span> tokens <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>accounts<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>account_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap_or_else</span><span class=\"token punctuation\">(</span><span class=\"token closure-params\"><span class=\"token closure-punctuation punctuation\">|</span><span class=\"token closure-punctuation punctuation\">|</span></span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token class-name\">UnorderedSet</span><span class=\"token punctuation\">::</span><span class=\"token function\">new</span><span class=\"token punctuation\">(</span>\n                <span class=\"token class-name\">StorageKeys</span><span class=\"token punctuation\">::</span><span class=\"token class-name\">SubAccount</span> <span class=\"token punctuation\">&#123;</span> account_hash<span class=\"token punctuation\">:</span> <span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">sha256</span><span class=\"token punctuation\">(</span>account_id<span class=\"token punctuation\">.</span><span class=\"token function\">as_bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#125;</span>\n            <span class=\"token punctuation\">)</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        tokens\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n\n\n","feature":true,"text":"near_bindgen 例如,下面是一个简单的计数合约,&#96;&#96;&#96;#[near_bindgen]&#96;&#96;&#96;宏被这样使用: &#96;&#96;&#96;rust use near_sdk::borsh::&#123;self, Borsh...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"文档翻译","slug":"文档翻译","count":4,"path":"api/categories/文档翻译.json"}],"tags":[{"name":"NEAR","slug":"NEAR","count":4,"path":"api/tags/NEAR.json"},{"name":"near-sdk-rs","slug":"near-sdk-rs","count":4,"path":"api/tags/near-sdk-rs.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#near-bindgen\"><span class=\"toc-text\">near_bindgen</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E6%94%AF%E4%BB%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">可支付方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">私有方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88\"><span class=\"toc-text\">集合</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%8C%81%E4%B9%85%E5%8C%96%E9%9B%86%E5%90%88%E8%BF%9B%E8%A1%8C%E5%88%86%E9%A1%B5\"><span class=\"toc-text\">使用持久化集合进行分页</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#LookupMapvsUnorderedMap\"><span class=\"toc-text\">LookupMapvsUnorderedMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8A%9F%E8%83%BD%E6%80%A7\"><span class=\"toc-text\">功能性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">性能</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E5%B5%8C%E5%A5%97\"><span class=\"toc-text\">集合嵌套</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E4%BC%A0%E7%BB%9F%E6%96%B9%E5%BC%8F%E6%9E%84%E9%80%A0%E5%94%AF%E4%B8%80%E5%89%8D%E7%BC%80\"><span class=\"toc-text\">使用传统方式构造唯一前缀</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E6%8C%81%E4%B9%85%E5%8C%96%E5%AE%B9%E5%99%A8%E7%94%9F%E4%BA%A7%E5%89%8D%E7%BC%80\"><span class=\"toc-text\">为持久化容器生产前缀</span></a></li></ol></li></ol></li></ol>","author":{"name":"Bref","slug":"blog-author","avatar":"https://avatarfiles.alphacoders.com/700/70031.gif","link":"/","description":"Nothing is true,Everything is permitted.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"NEAR SDK - 回调函数","uid":"9520473b9d226eac24e0870f8d1ab299","slug":"NEAR SDK - 回调函数","date":"2022-03-11T12:11:22.994Z","updated":"2022-03-11T14:33:15.726Z","comments":true,"path":"api/articles/NEAR SDK - 回调函数.json","keywords":"区块链, NEAR Protocol, 智能合约, 夜影协议, NEAR","cover":null,"text":"与工作量证明区块链不同,NEAR 协议是分片的,权益证明的区块链网络,当使用原生Rust(编译成 WASM)与智能合约交互时,跨合约调用是异步的.回调用来获取跨合约调用的结果或者用来获取跨合约调用是成功还是失败. 这里有两种进行跨合约调用的技术:高级调用和低级调用.本文档将聚焦于...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"文档翻译","slug":"文档翻译","count":4,"path":"api/categories/文档翻译.json"}],"tags":[{"name":"NEAR","slug":"NEAR","count":4,"path":"api/tags/NEAR.json"},{"name":"near-sdk-rs","slug":"near-sdk-rs","count":4,"path":"api/tags/near-sdk-rs.json"}],"author":{"name":"Bref","slug":"blog-author","avatar":"https://avatarfiles.alphacoders.com/700/70031.gif","link":"/","description":"Nothing is true,Everything is permitted.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}