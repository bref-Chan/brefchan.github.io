{"title":"NEAR SDK - 合约接口","uid":"0d7a924133f95db56db161e3fcf8a116","slug":"NEAR SDK - 合约接口","date":"2022-03-11T08:48:13.455Z","updated":"2022-03-11T12:10:32.483Z","comments":true,"path":"api/articles/NEAR SDK - 合约接口.json","keywords":"区块链, NEAR-Protocol, 智能合约, 夜影协议, NEAR","cover":null,"content":"<h3 id=\"公共方法类型\"><a href=\"#公共方法类型\" class=\"headerlink\" title=\"公共方法类型\"></a>公共方法类型</h3><h4 id=\"基础实现\"><a href=\"#基础实现\" class=\"headerlink\" title=\"基础实现\"></a>基础实现</h4><p>在#[near_bindgen]宏包裹下的函数可以使用 <code>pub</code>标识符修饰,这样当它编译成<code>WASM</code>字节码以后就可以被外部调用 </p>\n<p>只讲能在外部调用的方法标记成<code>public</code>是很重要的.如果你需要合约自身来调用,你可以标记该方法为公共的但是添加<code>#[private]</code>修饰,这样除了合约自身的调用,任何调用都会导致<code>panic</code></p>\n<p>基本的用法如下所示:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">MyContractStructure</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">some_method</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// .. method logic here</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这将从WASM二进制码中公开some_method,任何人都可以访问它</p>\n<details class=\"custom-details\">\n<summary>展开显示生成的代码</summary>\n<p><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[cfg(target_arch = <span class=\"token string\">\"wasm32\"</span>)]</span>\n<span class=\"token attribute attr-name\">#[no_mangle]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">some_method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">setup_panic_hook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">attached_deposit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Method some_method doesn\\'t accept deposit\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">as_bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> contract<span class=\"token punctuation\">:</span> <span class=\"token class-name\">MyContractStructure</span> <span class=\"token operator\">=</span> <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">state_read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap_or_default</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    contract<span class=\"token punctuation\">.</span><span class=\"token function\">some_method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">state_write</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>contract<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</p>\n</details>\n<h4 id=\"公开trait实现\"><a href=\"#公开trait实现\" class=\"headerlink\" title=\"公开trait实现\"></a>公开trait实现</h4><p>函数也能够公开自己的trait实现.这有助于在合约中实现共有的接口或标准.下面的代码与<code>pub</code>的基础用法很相似,除了<code>#[near_bindgen]</code>宏只需要附属在trait的实现上,而无需附属与trait本身.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token keyword\">pub</span> <span class=\"token keyword\">trait</span> <span class=\"token type-definition class-name\">MyTrait</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">trait_method</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span>\n\n<span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">MyTrait</span> <span class=\"token keyword\">for</span> <span class=\"token class-name\">MyContractStructure</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">trait_method</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// .. method logic here</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在这个例子中,生成的代码与前一个例子相同,只是方法名不一样</p>\n<details class=\"custom-details\">\n<summary>展开显示生成的代码</summary>\n<p><pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[cfg(target_arch = <span class=\"token string\">\"wasm32\"</span>)]</span>\n<span class=\"token attribute attr-name\">#[no_mangle]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">extern</span> <span class=\"token string\">\"C\"</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">trait_method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">setup_panic_hook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">attached_deposit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Method trait_method doesn\\'t accept deposit\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">as_bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">let</span> <span class=\"token keyword\">mut</span> contract<span class=\"token punctuation\">:</span> <span class=\"token class-name\">MyContractStructure</span> <span class=\"token operator\">=</span> <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">state_read</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap_or_default</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    contract<span class=\"token punctuation\">.</span><span class=\"token function\">trait_method</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">state_write</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>contract<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</p>\n</details>\n<h3 id=\"合约状态可变性\"><a href=\"#合约状态可变性\" class=\"headerlink\" title=\"合约状态可变性\"></a>合约状态可变性</h3><p>合约状态可变性是通过函数参数中的<code>self</code>参数是怎样的来自动处理的.根据使用的是哪一个,<code>#[near_bindgen]</code>宏将生成相应的代码来加载/反序列化任何使用<code>self</code>的函数的状态，序列化/存储状态只在使用<code>&amp;mut self</code>时使用。</p>\n<h4 id=\"只读函数\"><a href=\"#只读函数\" class=\"headerlink\" title=\"只读函数\"></a>只读函数</h4><p>以不可变的方式调用合约时,交易结束时不会覆写任何状态.你可以通过使用&amp;self 或者 self 作为参数.他们都将生成同样的代码去加载并反序列化状态到结构体中,然后调用函数.不同的是,self 会将变量的所有权移动进函数中,&amp;self 仅仅将 self 的引用移动进函数中.</p>\n<p>下面是一个例子:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token attribute attr-name\">#[derive(BorshDeserialize, BorshSerialize, Default)]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">MyContractStructure</span> <span class=\"token punctuation\">&#123;</span>\n    integer<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u64</span><span class=\"token punctuation\">,</span>\n    message<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">MyContractStructure</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get_values</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">u64</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>integer<span class=\"token punctuation\">,</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">log_state_string</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>message<span class=\"token punctuation\">.</span><span class=\"token function\">as_bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>没有适用于所有情况的通用准则,但有一些核心规则需要遵守:</p>\n<ul>\n<li><p><code>self</code> 如果在函数中移动了 self 的值或者其包含的值时使用 <code>self</code> 作为参数是很有用的,因为这样减少了 <code>copy</code> 和 <code>clone</code> 的操作</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token comment\">/// View method. More efficient, but can't be reused internally, because it consumes self.</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get_owner_id</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">AccountId</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>owner_id\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>&amp;self</code>当值需要只读的合约状态,或者函数使用了一些方法来获得了可用的所有权时使用<code>&amp;self</code>.如果结构体使用了大量内存,这很有用,可以避免将大量的数据转移进函数作用域中.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token comment\">/// View method. Requires cloning the account id.</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get_owner_id</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">AccountId</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>owner_id<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p><code>返回派生数据</code></p>\n<p>有些少见的情况需要我们通过只读的方式来返回从存储中获取并修改的数据.如下面所示:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token comment\">/// View method that \"modifies\" state, for code structure or computational</span>\n<span class=\"token comment\">/// efficiency reasons. Changes state in-memory, but does NOT save the new</span>\n<span class=\"token comment\">/// state. If called internally by a change method, WILL result in updated</span>\n<span class=\"token comment\">/// contract state.</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">update_stats</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> account_id<span class=\"token punctuation\">:</span> <span class=\"token class-name\">AccountId</span><span class=\"token punctuation\">,</span> score<span class=\"token punctuation\">:</span> <span class=\"token constant\">U64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Account</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">let</span> account <span class=\"token operator\">=</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>accounts<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>account_id<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unwrap_or_else</span><span class=\"token punctuation\">(</span><span class=\"token closure-params\"><span class=\"token closure-punctuation punctuation\">|</span><span class=\"token closure-punctuation punctuation\">|</span></span> <span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">panic_str</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"ERR_ACCT_NOT_FOUND\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    account<span class=\"token punctuation\">.</span>total <span class=\"token operator\">+=</span> score<span class=\"token punctuation\">;</span>\n    account\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<h4 id=\"可变函数\"><a href=\"#可变函数\" class=\"headerlink\" title=\"可变函数\"></a>可变函数</h4><p>可变的函数允许加载存在的状态,然后对它进行修改,最后当方法调用结束后重新将状态写入</p>\n<p>这应该用于任何修改合约状态的交易中.注意,序列化的合约数据存在键 <code>STATE</code> 下持久化存储中.</p>\n<p>一个可变函数的例子:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token attribute attr-name\">#[derive(BorshDeserialize, BorshSerialize, Default)]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">MyContractStructure</span> <span class=\"token punctuation\">&#123;</span>\n    integer<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u64</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">MyContractStructure</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">modify_value</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> new_value<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>integer <span class=\"token operator\">=</span> new_value<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">increment_value</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>integer <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h4 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h4><p>这一类函数根本不使用 self,也不需要从存储中读取或者写入合约状态</p>\n<p>使用公共的纯函数的情况很少,但是返回嵌入到合约代码中的数据或执行一些不依赖合约状态的静态共享逻辑时可能很有用</p>\n<p>一个纯函数的例子:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token keyword\">const</span> <span class=\"token constant\">SOME_VALUE</span><span class=\"token punctuation\">:</span> <span class=\"token keyword\">u64</span> <span class=\"token operator\">=</span> <span class=\"token number\">8</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">MyContractStructure</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">log_message</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/* Parameters here */</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span></span><span class=\"token macro property\">log!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"inside log message\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">log_u64</span><span class=\"token punctuation\">(</span>value<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span></span><span class=\"token macro property\">log!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&#123;&#125;\"</span><span class=\"token punctuation\">,</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">return_static_u64</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">u64</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token constant\">SOME_VALUE</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"私有方法\"><a href=\"#私有方法\" class=\"headerlink\" title=\"私有方法\"></a>私有方法</h3><h4 id=\"何时使用回调\"><a href=\"#何时使用回调\" class=\"headerlink\" title=\"何时使用回调\"></a>何时使用回调</h4><p>通常,当合约必须为一个远程交叉合约调用进行回调时,这个回调方法必须只能被合约自身调用.这能避免有人直接调用它而搞乱合约状态.更常见的模式是使用断言来验证直接调用者(predecessor account ID)是否是合约自己的账户(current account ID).<code>#[private]</code>宏会简化这个操作,提高代码可读性.</p>\n<p>在<code>near_bindgen</code>宏包裹的代码里使用这个标注,例如:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[private]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">my_method</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    …\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>上面的代码等价于</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">my_method</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">current_account_id</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">predecessor_account_id</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Method method is private\"</span><span class=\"token punctuation\">.</span><span class=\"token function\">as_bytes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>现在通过这个标注,只有合约账户本身可以调用这个方法,可以直接调用也可以通过哦Promise</p>\n<h4 id=\"编写内部方法\"><a href=\"#编写内部方法\" class=\"headerlink\" title=\"编写内部方法\"></a>编写内部方法</h4><p>不是所有的方法都需要暴露为公开的,为 helper 或 uility 函数编写私有的方法也许更加有益.下面是三种编写内部方法的途径</p>\n<ul>\n<li><p>使用 <code>fn</code> 替换 <code>pub fn</code></p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">helper_method</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u8</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u8</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  …\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>使用<code>pub(crate) fn</code>.这将有助于在不同的模块中使用内部函数</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token comment\">// Function that can be called in another Rust file</span>\n<span class=\"token keyword\">pub</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">crate</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get_first_name</span><span class=\"token punctuation\">(</span>account<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Account</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n  …\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n<li><p>分散的<code>impl</code>块</p>\n<p>另外一种不暴露方法的方式是有一个单独的<code>impl Contract</code>部分,并且这部分不使用<code>#[near_bindgen]</code>宏</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">internal_increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">/// This methods is still not exported.</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">internal_increment</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>counter <span class=\"token operator\">+=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n</li>\n</ul>\n<h3 id=\"可支付方法\"><a href=\"#可支付方法\" class=\"headerlink\" title=\"可支付方法\"></a>可支付方法</h3><p>我们可以允许方法在函数调用时接受代币转移.这样做是为了让合约能够使用的时候定义其需要的代币费用.默认的方法是不可支付的,如果调用时尝试转移代币会导致 panic.这样做是因为安全原因,以免有人在函数调用时意外地转移代币</p>\n<p>使用#[payable]标注来申明方法是可支付的.</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[payable]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">my_method</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n<span class=\"token punctuation\">...</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>这将允许通过调用my_method方法来转移资产给合约</p>\n<p>例子:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token attribute attr-name\">#[payable]</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">take_my_money</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">log_str</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thanks!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">do_not_take_my_money</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">log_str</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thanks!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>等价于:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">take_my_money</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">log_str</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thanks!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">do_not_take_my_money</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">attached_deposit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token namespace\">near_sdk<span class=\"token punctuation\">::</span>env<span class=\"token punctuation\">::</span></span><span class=\"token function\">panic</span><span class=\"token punctuation\">(</span><span class=\"token string\">b\"Method do_not_take_my_money doesn't accept deposit\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">log_str</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Thanks!\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"序列化协议\"><a href=\"#序列化协议\" class=\"headerlink\" title=\"序列化协议\"></a>序列化协议</h3><p>SDK 中的序列化规则定义了结构体数据如何转化成字节,当需要传输数据到合约方法中或存储数据到状态中时.对于方法参数,SDK 接受JSON(默认)和 Borsh,对于存储数据在链上,使用 Borsh.</p>\n<h4 id=\"JSON-和-Borsh-的特点如下\"><a href=\"#JSON-和-Borsh-的特点如下\" class=\"headerlink\" title=\"JSON 和 Borsh 的特点如下:\"></a>JSON 和 Borsh 的特点如下:</h4><p>JSON:</p>\n<ul>\n<li>人类可读</li>\n<li>自解释样式(不需要知道底层类型)</li>\n<li>与 JavaScript 的易互操作性</li>\n<li>低效率的(反)序列化<br>Borsh</li>\n<li>紧凑的二进制格式可以高效率的进行数据的序列化和反序列化</li>\n<li>需要知道数据格式或者有一个模板来反序列化数据</li>\n<li>严格规范的二进制表示</li>\n<li>在大多数情况下,快速并且开销更小<br>通常来说,JSON 用于合约调用和交叉合约调用以实现更好的适用性,Borsh 被用于优化合约中更小的参数序列化和更少的反序列化计算开销,以减少 gas 使用.</li>\n</ul>\n<h4 id=\"重载默认的序列化协议\"><a href=\"#重载默认的序列化协议\" class=\"headerlink\" title=\"重载默认的序列化协议\"></a>重载默认的序列化协议</h4><p>结果和参数的序列化可以分开选择.但是所有的参数必须使用同样的样式(不能使用 borsh 序列化一部分参数,另外的参数使用 JSON 序列化).<br>下面的例子是同时使用 borsh 来序列化返回值和参数</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[result_serializer(borsh)]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">sum_borsh</span><span class=\"token punctuation\">(</span><span class=\"token attribute attr-name\">#[serializer(borsh)]</span> a<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u32</span><span class=\"token punctuation\">,</span> <span class=\"token attribute attr-name\">#[serializer(borsh)]</span> b<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u32</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">u32</span> <span class=\"token punctuation\">&#123;</span>\n    a <span class=\"token operator\">+</span> b\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<pre class=\"line-numbers language-result_serializer(borsh)```标注会重载默认的返回值的序列化协议,从\" data-language=\"result_serializer(borsh)```标注会重载默认的返回值的序列化协议,从\"><div class=\"caption\"><span>JSON 重载为 borsh,```serializer(borsh)```标注将重载参数的序列化协议</span></div><code class=\"language-result_serializer(borsh)```标注会重载默认的返回值的序列化协议,从\">\n下面是在单元测试中使用 Borsh 序列化,并且使用 base64 编码的方法\n\n&#96;&#96;&#96;rust\n&#x2F;&#x2F;&#x2F; This test is simply a helper to print out the base64 value.\n#[test]\nfn borsh_simple() &#123;\n    let status_message &#x3D; &quot;Aloha honua!&quot;.to_string();\n    let borsh_input &#x3D; SetMessageInput &#123;\n        msg: status_message.clone()\n    &#125;;\n\n    let borsh_serialized: Vec&lt;u8&gt; &#x3D; borsh_input.try_to_vec().unwrap();\n    let base64_encoded &#x3D; near_primitives::serialize::to_base64(borsh_serialized.as_slice());\n    println!(&quot;Using NEAR CLI, this is the base64-encoded value to use: &#123;:?&#125;&quot;, base64_encoded);\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>下面展示了在 CLI 中使用这个值的代码片段.注意,该方法没有返回值,所以不需要使用#[result_serializer(borsh)]来标注返回值</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">set_status_borsh</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">mut</span> <span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> <span class=\"token attribute attr-name\">#[serializer(borsh)]</span> message<span class=\"token punctuation\">:</span> <span class=\"token class-name\">SetMessageInput</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>records<span class=\"token punctuation\">.</span><span class=\"token function\">insert</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token namespace\">env<span class=\"token punctuation\">::</span></span><span class=\"token function\">signer_account_id</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>message<span class=\"token punctuation\">.</span>msg<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n<p>他们使用了这个简单的结构体:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[derive(BorshDeserialize, BorshSerialize)]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">SetMessageInput</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// Note that the key does not have to be \"message\" like the argument name.</span>\n    msg<span class=\"token punctuation\">:</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>在NEAR CLI中调用方法如下:</p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">near call rust-status-message.demo.testnet set_status_borsh --base64 &#39;DAAAAEFsb2hhIGhvbnVhIQ&#x3D;&#x3D;&#39; --accountId demo.testnet<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h4 id=\"JSON-包装类型\"><a href=\"#JSON-包装类型\" class=\"headerlink\" title=\"JSON 包装类型\"></a>JSON 包装类型</h4><p>为了帮助将某些类型序列化为 JSON,这些类型有意想不到或低效的默认格式,在 <code>near_sdk::json_types</code> 里有一些包装器类型可以使用<br>因为 JavaScript 只支持整数类型的值到 2^53-1,如果反序列化 JSON 整型超过了这个范围,你将丢失精度.为了抵消这种影响,你可以使用 <code>I64</code>,<code>U64</code>,<code>I128</code> 和 <code>U128</code> 类型来代替这些参数或结果的本地类型,将值序列化为字符串.默认情况下,所有整数类型都将序列化为 JSON 中的整型<br>你能使用 <code>std::convert::Into</code> 来将 <code>U64</code> 转化为 <code>u64</code></p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">mult</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">:</span> <span class=\"token constant\">U64</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token constant\">U64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token constant\">U128</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">let</span> a<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u64</span> <span class=\"token operator\">=</span> a<span class=\"token punctuation\">.</span><span class=\"token function\">into</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> b<span class=\"token punctuation\">:</span> <span class=\"token keyword\">u64</span> <span class=\"token operator\">=</span> b<span class=\"token punctuation\">.</span><span class=\"token function\">into</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> product <span class=\"token operator\">=</span> <span class=\"token keyword\">u128</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">u128</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        product<span class=\"token punctuation\">.</span><span class=\"token function\">into</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>你也可以使用<code>.0</code>来访问内部值</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">mult</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">:</span> <span class=\"token constant\">U64</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token constant\">U64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token constant\">U128</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">//let a: u64 = a.into();</span>\n        <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> a<span class=\"token number\">.0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">//let b: u64 = b.into();</span>\n        <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> b<span class=\"token number\">.0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">let</span> product <span class=\"token operator\">=</span> <span class=\"token keyword\">u128</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">u128</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        product<span class=\"token punctuation\">.</span><span class=\"token function\">into</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>同时,你还可以使用<code>U64(...)</code>和<code>U128(...)</code>来转化<code>u64</code>和<code>u128</code></p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n <span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">mult</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">:</span> <span class=\"token constant\">U64</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token constant\">U64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token constant\">U128</span> <span class=\"token punctuation\">&#123;</span>\n         <span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> a<span class=\"token number\">.0</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> b<span class=\"token number\">.0</span><span class=\"token punctuation\">;</span>\n         <span class=\"token keyword\">let</span> product <span class=\"token operator\">=</span> <span class=\"token keyword\">u128</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">u128</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token comment\">//product.into()</span>\n         <span class=\"token constant\">U128</span><span class=\"token punctuation\">(</span>product<span class=\"token punctuation\">)</span>\n     <span class=\"token punctuation\">&#125;</span>\n <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>结合起来使用:</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">mult</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> a<span class=\"token punctuation\">:</span> <span class=\"token constant\">U64</span><span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">:</span> <span class=\"token constant\">U64</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token constant\">U128</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token constant\">U128</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">u128</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>a<span class=\"token number\">.0</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">u128</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>b<span class=\"token number\">.0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>尽管JSON 包装类型只包含在 SDK 中,但是任何类型都可以使用,只要它各自实现了 serder 序列化和反序列化.所有这些类型都覆写了 JSON 格式并且与内部类型具有一致的 borsh 序列化和反序列特性</p>\n<h4 id=\"Base64VecU8\"><a href=\"#Base64VecU8\" class=\"headerlink\" title=\"Base64VecU8\"></a>Base64VecU8</h4><p>另外一个覆写默认序列化的例子是 Vec<u8>,它用来表示 Rust 中的字节.默认实现下,它将序列化为整型数组,这是不紧凑而且很难使用的.有一个包装类型Base64VecU8,它能序列化和反序列化 Base64 字符串再 JSON 的序列化中获得更多的紧凑性</p>\n<pre class=\"line-numbers language-rust\" data-language=\"rust\"><code class=\"language-rust\"><span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token attribute attr-name\">#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]</span>\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">struct</span> <span class=\"token type-definition class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// Notice, internally we store `Vec&lt;u8>` </span>\n    <span class=\"token keyword\">pub</span> data<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Vec</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">u8</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token attribute attr-name\">#[near_bindgen]</span>\n<span class=\"token keyword\">impl</span> <span class=\"token class-name\">Contract</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token attribute attr-name\">#[init]</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">new</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">:</span> <span class=\"token class-name\">Base64VecU8</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">Self</span> <span class=\"token punctuation\">&#123;</span>\n            data<span class=\"token punctuation\">:</span> data<span class=\"token punctuation\">.</span><span class=\"token function\">into</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token keyword\">pub</span> <span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">get_data</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> <span class=\"token class-name\">Base64VecU8</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span><span class=\"token function\">into</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","text":"公共方法类型基础实现在#[near_bindgen]宏包裹下的函数可以使用 pub标识符修饰,这样当它编译成WASM字节码以后就可以被外部调用 只讲能在外部调用的方法标记成public是很重要的.如果你需要合约自身来调用,你可以标记该方法为公共的但是添加#[private]修饰,...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"文档翻译","slug":"文档翻译","count":7,"path":"api/categories/文档翻译.json"}],"tags":[{"name":"NEAR","slug":"NEAR","count":8,"path":"api/tags/NEAR.json"},{"name":"near-sdk-rs","slug":"near-sdk-rs","count":7,"path":"api/tags/near-sdk-rs.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">公共方法类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">基础实现</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%AC%E5%BC%80trait%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">公开trait实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%90%88%E7%BA%A6%E7%8A%B6%E6%80%81%E5%8F%AF%E5%8F%98%E6%80%A7\"><span class=\"toc-text\">合约状态可变性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AA%E8%AF%BB%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">只读函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E5%8F%98%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">可变函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%AF%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">纯函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">私有方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%9B%9E%E8%B0%83\"><span class=\"toc-text\">何时使用回调</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BC%96%E5%86%99%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">编写内部方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E6%94%AF%E4%BB%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">可支付方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">序列化协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JSON-%E5%92%8C-Borsh-%E7%9A%84%E7%89%B9%E7%82%B9%E5%A6%82%E4%B8%8B\"><span class=\"toc-text\">JSON 和 Borsh 的特点如下:</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%87%8D%E8%BD%BD%E9%BB%98%E8%AE%A4%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">重载默认的序列化协议</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JSON-%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">JSON 包装类型</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Base64VecU8\"><span class=\"toc-text\">Base64VecU8</span></a></li></ol></li></ol>","author":{"name":"Bref","slug":"blog-author","avatar":"https://avatarfiles.alphacoders.com/700/70031.gif","link":"/","description":"Nothing is true,Everything is permitted.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"NEAR SDK - 跨合约调用","uid":"7ea6f8c776c9e4fb015c2ac37083b48f","slug":"NEAR SDK - 跨合约调用","date":"2022-03-11T12:11:22.994Z","updated":"2022-03-14T11:25:43.076Z","comments":true,"path":"api/articles/NEAR SDK - 跨合约调用.json","keywords":"区块链, NEAR-Protocol, 智能合约, 夜影协议, NEAR","cover":null,"text":"回调函数与工作量证明区块链不同,NEAR 协议是分片的,权益证明的区块链网络,当使用原生Rust(编译成 WASM)与智能合约交互时,跨合约调用是异步的.回调用来获取跨合约调用的结果或者用来获取跨合约调用是成功还是失败. 这里有两种进行跨合约调用的技术:高级调用和低级调用.本文档...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"文档翻译","slug":"文档翻译","count":7,"path":"api/categories/文档翻译.json"}],"tags":[{"name":"NEAR","slug":"NEAR","count":8,"path":"api/tags/NEAR.json"},{"name":"near-sdk-rs","slug":"near-sdk-rs","count":7,"path":"api/tags/near-sdk-rs.json"}],"author":{"name":"Bref","slug":"blog-author","avatar":"https://avatarfiles.alphacoders.com/700/70031.gif","link":"/","description":"Nothing is true,Everything is permitted.","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}