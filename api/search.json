[{"id":"0d7a924133f95db56db161e3fcf8a116","title":"NEAR SDK - 合约接口","content":"公共方法类型基础实现在#[near_bindgen]宏包裹下的函数可以使用 pub标识符修饰,这样当它编译成WASM字节码以后就可以被外部调用\n只讲能在外部调用的方法标记成public是很重要的.如果你需要合约自身来调用,你可以标记该方法为公共的但是添加#[private]修饰,这样除了合约自身的调用,任何调用都会导致panic\n基本的用法如下所示:\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn some_method(&amp;mut self) &#123;\n        // .. method logic here\n    &#125;\n&#125;\n\n这将从WASM二进制码中公开some_method,任何人都可以访问它\n\n展开显示生成的代码\n#[cfg(target_arch = \"wasm32\")]\n#[no_mangle]\npub extern \"C\" fn some_method() &#123;\n    near_sdk::env::setup_panic_hook();\n    if near_sdk::env::attached_deposit() != 0 &#123;\n        near_sdk::env::panic(\"Method some_method doesn\\'t accept deposit\".as_bytes());\n    &#125;\n    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();\n    contract.some_method();\n    near_sdk::env::state_write(&amp;contract);\n&#125;\n\n\n\n公开trait实现函数也能够公开自己的trait实现.这有助于在合约中实现共有的接口或标准.下面的代码与pub的基础用法很相似,除了#[near_bindgen]宏只需要附属在trait的实现上,而无需附属与trait本身.\npub trait MyTrait &#123;\n    fn trait_method(&amp;mut self);\n&#125;\n\n#[near_bindgen]\nimpl MyTrait for MyContractStructure &#123;\n    fn trait_method(&amp;mut self) &#123;\n        // .. method logic here\n    &#125;\n&#125;\n\n在这个例子中,生成的代码与前一个例子相同,只是方法名不一样\n\n展开显示生成的代码\n#[cfg(target_arch &#x3D; “wasm32”)]\n#[no_mangle]\npub extern “C” fn trait_method() {\n​    near_sdk::env::setup_panic_hook();\n​    if near_sdk::env::attached_deposit() !&#x3D; 0 {\n​        near_sdk::env::panic(“Method trait_method doesn&#39;t accept deposit”.as_bytes());\n​    }\n​    let mut contract: MyContractStructure &#x3D; near_sdk::env::state_read().unwrap_or_default();\n​    contract.trait_method();\n​    near_sdk::env::state_write(&amp;contract);\n}\n\n\n合约状态可变性合约状态可变性是通过函数参数中的self参数是怎样的来自动处理的.根据使用的是哪一个,#[near_bindgen]宏将生成相应的代码来加载&#x2F;反序列化任何使用self的函数的状态，序列化&#x2F;存储状态只在使用&amp;mut self时使用。\n只读函数以不可变的方式调用合约时,交易结束时不会覆写任何状态.你可以通过使用&amp;self 或者 self 作为参数.他们都将生成同样的代码去加载并反序列化状态到结构体中,然后调用函数.不同的是,self 会将变量的所有权移动进函数中,&amp;self 仅仅将 self 的引用移动进函数中.\n下面是一个例子:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct MyContractStructure &#123;\n    integer: u64,\n    message: String,\n&#125;\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn get_values(self) -> (u64, String) &#123;\n        (self.integer, self.message)\n    &#125;\n    pub fn log_state_string(&amp;self) &#123;\n        near_sdk::env::log(self.message.as_bytes());\n    &#125;\n&#125;\n\n没有适用于所有情况的通用准则,但有一些核心规则需要遵守:\n\nself (所有权)\n\n\n/// View method. More efficient, but can't be reused internally, because it consumes self.\npub fn get_owner_id(self) -> AccountId &#123;\n    self.owner_id\n&#125;\n\n&amp;self(不可变引用)\n当值需要只读的合约状态,或者函数使用了一些方法来获得了可用的所有权时使用&amp;self.如果结构体使用了大量内存,这很有用,可以避免将大量的数据转移进函数作用域中.\n/// View method. Requires cloning the account id.\npub fn get_owner_id(&amp;self) -> AccountId &#123;\n    self.owner_id.clone()\n&#125;\n\n返回派生数据\n有些少见的情况需要我们通过只读的方式来返回从存储中获取并修改的数据.如下面所示:\n/// View method that \"modifies\" state, for code structure or computational\n/// efficiency reasons. Changes state in-memory, but does NOT save the new\n/// state. If called internally by a change method, WILL result in updated\n/// contract state.\npub fn update_stats(&amp;self, account_id: AccountId, score: U64) -> Account &#123;\n    let account = self.accounts.get(&amp;account_id).unwrap_or_else(|| env::panic_str(\"ERR_ACCT_NOT_FOUND\"));\n    account.total += score;\n    account\n&#125;\n\n","slug":"NEAR SDK - 合约接口","date":"2022-03-11T08:48:13.455Z","categories_index":"","tags_index":"","author_index":"Bref"},{"id":"b468f3c3ac71ea2b71e5a5059fe38476","title":"Promise","content":"介绍合约能够通过 Promise 异步的发送交易.就像其他编程语言中的Promise 一样,它可以让代码在未来执行.”在未来”意味着交易将在下一个区块(或附近)执行,而不会在初始调用的区块执行.你可以使用 Promise实现任何跨合约调用链.它介于之前所说的高级调用和低级调用之间.查阅上面完整的 Promise 文档以获得更多细节当然,在很少的情况下,Promise 拥有特殊的能力,因为这些情况都不需要函数调用\n\n发送 NEAR 代币\n创建账户\n部署合约\n\n\n\n\n\n\n\n提示\n为什么要等待\n为什么不让交易是同步进行的.在同样的区块完成方法调用?为什么 NEAR 需要 Promise 来发送代币,创建账户和部署合约?他们需要在单独的块中进行调度,因为发送者和接收者可能位于不同的分片中,跨分片通信发生在多个块之间,通过 收据(receipts),你可以将收据理解为 NEAR 的内部交易.你能在 NEAR Explorer 中看到收据是怎么从一个块传输到另一个块中.\n\n\n发送$NEAR你可能有很多原因想要从合约发送代币:\n\n合约使用了类似存储标准的协议,需要再用户注销时返还资金\n用户支付 token 给合约,然后合约稍后支付费用给维护人员,重新分配给用户或者通过用户投票的结果支付给其他人\n更多…\n\n区块链给了我们可编程的货币,智能合约支付货币是这种能力的核心NEAR 让这变的简单,如果你想要从合约中转移代币,下面是你需要做的全部:\nlet amount: u128 = 1_000_000_000_000_000_000_000_000; // 1 $NEAR as yoctoNEAR\nlet account_id: AccountId = \"example.near\".parse().unwrap();\n\nPromise::new(account_id).transfer(amount);\n\n:::tip\n本文档描述的 AccountId 行为是 neaer-sdk-rs v4 的特性.这个功能在 v3 中依然可以使用,但如果你想使用更干净的 v4 语法,编写你的Cargo.toml\n[dependencies]\nnear-sdk = \"4.0.0-pre.2\"\n\n:::完整的合约上下文像下面这样\nuse near_sdk::&#123;json_types::U128, near_bindgen, AccountId, Promise&#125;;\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn pay(amount: U128, to: AccountId) -> Promise &#123;\n        Promise::new(to).transfer(amount.0)\n    &#125;\n&#125;\n\n\n\n其中大部分是你已经熟悉的样板.像 imports,设置 near_bindgen,borsh.下面是一些与转账有关的有趣细节:\n\n大写的 U 的 U128,这里的 pay 方法定义了接受 JSON 作为输入,但是 JSON 数字不能超过 2^53,也就是 9 后面只跟了 15 个 0,因为传输时使用的数量是以 yoctoNEAR 为单位,似乎需要比 2^53 大的多的数字  当方法接受 U128 位输入时,这意味着调用者需要将数字转化成 string.near-sdk-rs 将 string 转化为 U128,它是 Rust 原生的 u128 的包装类.底层的 u128 可以通过.0 来使用.例如 transfer(amount.0)\n\nAccountId:这个类型会自动的检查提供的 string 是否很好的匹配了 NEAR 账户 ID 的规则.当不匹配时 panic\n\n返回 Promise:这将允许 NEAR Explorer,near-cli,near-api-js.和其他工具正确的判断整个交易链是否成功.如果你的函数没有返回 Promise.类似于 near-cli 会在你的调用后立刻返回.并且即使 transfer 失败,你的函数调用也会确认为成功.这里有相关的例子.使用 near-cli 来调用函数:\nnear call $CONTRACT pay &#39;&#123;&quot;amount&quot;: &quot;1000000000000000000000000&quot;, &quot;to&quot;: &quot;example.near&quot;&#125;&#39;\n\n","slug":"Promise","date":"2022-03-10T11:08:00.000Z","categories_index":"","tags_index":"","author_index":"Bref"}]