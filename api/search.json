[{"id":"130cca4e9ec0257289a726a4fb72faf2","title":"NEAR-SDK 关于LazyOption不能与Vector,UnorderedSet和UnorderedMap搭配使用的问题研究","content":"本文是针对杨镇老师NEAR 认证开发者（23）： Octopus Network 的 NEAR 智能合约实践分享中提及的关于LazyOption搭配collection::Vector,UnorderedSet和UnorderedMap使用过程中会出现的问题的原因的详细探究.欢迎大家斧正.\n问题描述杨老师创建了个repo来专门复现这个问题,我们就按repo中举得例子来看.repo基于NEAR官方推出的rust-status-message示例做了一点修改,主要文件很简单,接下来我们看具体做了哪些修改:\nuse near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};\nuse near_sdk::collections::{LazyOption, LookupMap, UnorderedSet};\nuse near_sdk::json_types::{ValidAccountId, U64};\nuse near_sdk::{env, near_bindgen, BorshStorageKey, PanicOnDefault};\n\nnear_sdk::setup_alloc!();\n\n/// 使用enum来管理near_sdk::collection初始化所需的前缀\n#[derive(BorshSerialize, BorshStorageKey)]\npub enum StorageKey {\n    Records,\n    UniqueValues,\n    UniqueValuesSet,\n}\n\n/// 创建了新的结构体,这个结构体使用了UnorderedSet来存储String,同时持有一个u32成员记录UnorderedSet长度\n/// 用来记录添加到留言簿当中的独特的留言以及数量\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct UniqueValues {\n    pub unique_values: UnorderedSet&lt;String&gt;,\n    pub other_business_field: u32,\n}\n\n/// 添加了新的LazyOption&lt;UniqueValue&gt;类型的字段\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct StatusMessage {\n    pub records: LookupMap&lt;String, String&gt;,\n    pub unique_values: LazyOption&lt;UniqueValues&gt;,\n}\n\n/// 实现UniqueValues的初始化函数\nimpl UniqueValues {\n    pub fn new(storage_key_of_value_set: StorageKey) -&gt; Self {\n        Self {\n            unique_values: UnorderedSet::new(storage_key_of_value_set),\n            other_business_field: 0,\n        }\n    }\n}\n\n#[near_bindgen]\nimpl StatusMessage {\n    /// 添加了unique_values初始化内容\n    #[init]\n    pub fn new() -&gt; Self {\n        Self {\n            records: LookupMap::new(StorageKey::Records),\n            unique_values: LazyOption::new(\n                StorageKey::UniqueValues,\n                Some(&amp;UniqueValues::new(StorageKey::UniqueValuesSet)),\n            ),\n        }\n    }\n    /// 用户像留言簿中添加留言[这与原本的example实现一致],并且如果添加的内容是独特的,返回true,否则返回false\n    pub fn set_status(&amp;mut self, message: String) -&gt; bool {\n        let account_id = env::signer_account_id();\n        self.records.insert(&amp;account_id, &amp;message);\n        let mut unique_values = self.unique_values.get().unwrap();\n        // Without the following call of function `set`,\n        // it will cause inconsistency of the `UnorderedSet` inside `UniqueValues`.\n        // self.unique_values.set(&amp;unique_values);\n        unique_values.unique_values.insert(&amp;message)\n    }\n    /// 根据用户id获取留言簿内容[与原本example一致]\n    pub fn get_status(&amp;self, account_id: ValidAccountId) -&gt; Option&lt;String&gt; {\n        self.records.get(account_id.as_ref())\n    }\n    /// 获取独特的留言的数量\n    pub fn unique_values_count(&amp;self) -&gt; U64 {\n        self.unique_values.get().unwrap().unique_values.len().into()\n    }\n    /// 查询指定的留言是否已经在留言簿中存在\n    pub fn contains_message(&amp;self, message: String) -&gt; bool {\n        self.unique_values\n            .get()\n            .unwrap()\n            .unique_values\n            .contains(&amp;message)\n    }\n}\n\n#[cfg(not(target_arch = \"wasm32\"))]\n#[cfg(test)]\nmod tests {\n   // ...\n}\n问题出在哪呢?杨老师在README.md中对问题进行了描述:\n\n\n\n\n\n\n\n\n\n当调用set_status({\"message\":\"hello\"})成功的将消息存储到存储中后,使用pub fn unique_values_count(&amp;self)pub fn unique_values_count(&amp;self)查询unique_values_count返回的值却是0,但是,使用pub fn contains_message(&amp;self, message: String) -&gt; bool查询”hello”是否存在于self.unique_values.unique_values中时,却返回true.\n当你修改一个集合的状态,例如Vector,UnorderedSet和UnorderedMap时,当UnderedSet和UnorderedMap中 Vector的len改变是,你必须确保UnderedSet和UnorderedMap的状态被存储,否则将当值集合中的状态不一致.\n同时,杨老师也给出了解决问题的办法,就是在修改了unique_values的状态后,手动调用self.unique_values.set(&amp;unique_values)\n问题研究没有调用set? 是,但不完全是.要理解这个问题出来的原因,我们要先探讨一下LazyOption的实现,它的结构非常简单:\n/// 持久化的延迟Option,值被存储在存储器中\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct LazyOption&lt;T&gt; {\n  \t/// 存储的key\n    storage_key: Vec&lt;u8&gt;,\n    #[borsh_skip]\n    /// 告诉编译器你申明了泛型但暂时不使用它,同时borsh序列化时跳过这个值\n    el: PhantomData&lt;T&gt;,\n}\n下面是部分实现:\nimpl&lt;T&gt; LazyOption&lt;T&gt; {\n  ...\n   fn get_raw(&amp;self) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {\n        env::storage_read(&amp;self.storage_key)\n    }\n  ...\n  \n  fn set_raw(&amp;mut self, raw_value: &amp;[u8]) -&gt; bool {\n        env::storage_write(&amp;self.storage_key, &amp;raw_value)\n    }\n}\n\nimpl&lt;T&gt; LazyOption&lt;T&gt;\nwhere\n    T: BorshSerialize + BorshDeserialize,\n{\n    fn serialize_value(value: &amp;T) -&gt; Vec&lt;u8&gt; {\n    \t\tmatch value.try_to_vec() {\n              Ok(x) =&gt; x,\n              Err(_) =&gt; env::panic(ERR_VALUE_SERIALIZATION),\n        }\n    }\n\n    fn deserialize_value(raw_value: &amp;[u8]) -&gt; T {\n        match T::try_from_slice(&amp;raw_value) {\n            Ok(x) =&gt; x,\n            Err(_) =&gt; env::panic(ERR_VALUE_DESERIALIZATION),\n        }\n    }\n  \n    /// 从存储中获取值并返回一个Option\n    pub fn get(&amp;self) -&gt; Option&lt;T&gt; {\n        self.get_raw().map(|v| Self::deserialize_value(&amp;v))\n    }\n\n    /// 设置值到存储中,并返回前一个值是否存在\n    pub fn set(&amp;mut self, value: &amp;T) -&gt; bool {\n        self.set_raw(&amp;Self::serialize_value(value))\n    }\n}\n\n从代码实现很容易看出,LazyOption在合约调用执行初期,反序列化合约状态时只会反序列化出一个key,而具体的值只会在使用的时候才从存储中拿出,很适合用来包装大的且使用频率小的数据,以达到节省gas费的作用.\n那很多朋友看到这里就会说,结构体提供了pub fn set(&amp;mut self, value: &amp;T) -&gt; bool方法就肯定是要用户手动写入的啊,前面之所以出现了问题那是对sdk的使用不当.\n没错,但是我们不要忽略了这个问题真正的核心:不是数据为什么没有写入,而是在不调用set的情况下,部分数据写入但是部分数据没写入造成的不一致现象\n在near合约开发中,函数编写不当很容易处理,只需要更新wasm字节码即可.但是一旦合约数据状态被搞乱,是很难进行还原的,特别是正式合约中开发者已经放弃了合约的full_access_key的情况\n数据存储行为不一致? 是的.为什么会出现LazyOption在不调用set方法但是当中的数据有些没存储有些却存储了呢?我们先从合约的状态来说起.\n我们都知道,当我们调用一个合约时,实际上是发起了一个transaction,我们忽略NEAR中关于receipt和chunk的概念来简单理解.当块生产者执行transaction时,会从合约账户的存储中反序列化出合约的state.这也就是我们常说的state_read,在合约执行结束后序列化合约状态进存储中,这就是我们说的state_write.\n让我们通过一个例子,更清楚了看待这个过程:\n#[near_bindgen]\nimpl MyContractStructure {\n    pub fn some_method(&amp;mut self) {\n        // .. method logic here\n    }\n}\n当我们调用some_method时,实际上我们做的事情比看的更多,near_bindgen会展开我们的函数,当调用时,我们实际上调用的函数长的是这样的:\n#[cfg(target_arch = \"wasm32\")]\n#[no_mangle]\npub extern \"C\" fn some_method() {\n    near_sdk::env::setup_panic_hook();\n    if near_sdk::env::attached_deposit() != 0 {\n        near_sdk::env::panic(\"Method some_method doesn\\'t accept deposit\".as_bytes());\n    }\n    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();\n    contract.some_method();\n    near_sdk::env::state_write(&amp;contract);\n}\n我们可以看到,在执行contract.some_method()之前,我们执行了near_sdk::env::state_read(),在执行之后.我们执行了near_sdk::env::state_write(&amp;contract)\n再根据之前我们研究LazyOption时发现的特性,LazyOption反序列化的时候只需反序列化其中的key,那么当然在序列化的时候,也只会序列化它的key,所对应的数据自然不会写入到合约状态之中.所以我们能在最上面的示例中看到other_business_field并没有存储在合约状态之中.\n那么问题还在,为什么UnorderedSet类型的unique_values字段里的数据却保存下来了呢?\n其实很简单,我们先看一下合约状态是怎么序列化和反序列化的:\npub fn state_read&lt;T: borsh::BorshDeserialize&gt;() -&gt; Option&lt;T&gt; {\n    storage_read(STATE_KEY)\n        .map(|data| T::try_from_slice(&amp;data).expect(\"Cannot deserialize the contract state.\"))\n}\n\npub fn state_write&lt;T: borsh::BorshSerialize&gt;(state: &amp;T) {\n    let data = state.try_to_vec().expect(\"Cannot serialize the contract state.\");\n    storage_write(STATE_KEY, &amp;data);\n}\n\n我们可以看到.他们使用了函数storage_read和storage_write,我们再看这两个函数的实现:\npub fn storage_write(key: &amp;[u8], value: &amp;[u8]) -&gt; bool {\n    match unsafe {\n        BLOCKCHAIN_INTERFACE.with(|b| {\n            b.borrow().as_ref().expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR).storage_write(\n                key.len() as _,\n                key.as_ptr() as _,\n                value.len() as _,\n                value.as_ptr() as _,\n                EVICTED_REGISTER,\n            )\n        })\n    } {\n        0 =&gt; false,\n        1 =&gt; true,\n        _ =&gt; unreachable!(),\n    }\n}\n/// Reads the value stored under the given key.\npub fn storage_read(key: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {\n    match unsafe {\n        BLOCKCHAIN_INTERFACE.with(|b| {\n            b.borrow().as_ref().expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR).storage_read(\n                key.len() as _,\n                key.as_ptr() as _,\n                ATOMIC_OP_REGISTER,\n            )\n        })\n    } {\n        0 =&gt; None,\n        1 =&gt; Some(read_register(ATOMIC_OP_REGISTER).expect(REGISTER_EXPECTED_ERR)),\n        _ =&gt; unreachable!(),\n    }\n}\nBLOCKCHAIN_INTERFACE是区块链层提供给运行时层的接口,我们可以看到,wasm虚拟机修改账户存储时是通过BLOCKCHAIN_INTERFACE来实现的.\n我们可以猜想:UnorderedSet类型的变量unique_values之所以不经过state_write的过程却依旧可以写入合约状态,那大概率是调用的了storage_write()``\n我们从源码中找一下:\n/// 下面是UnorderedSet的实现\nimpl&lt;T&gt; UnorderedSet&lt;T&gt;\nwhere\n    T: BorshSerialize + BorshDeserialize,\n{\n  ...\n  pub fn insert(&amp;mut self, element: &amp;T) -&gt; bool {\n        self.insert_raw(&amp;Self::serialize_element(element))\n  }\n  ...\n}\nUnorderedSet实例调用insert时调用的insert_raw函数,我们来看这个函数:\nimpl&lt;T&gt; UnorderedSet&lt;T&gt; {\n\t...\n   pub fn insert_raw(&amp;mut self, element_raw: &amp;[u8]) -&gt; bool {\n        let index_lookup = self.raw_element_to_index_lookup(element_raw);\n        match env::storage_read(&amp;index_lookup) {\n            Some(_index_raw) =&gt; false,\n            None =&gt; {\n                // The element does not exist yet.\n                let next_index = self.len();\n                let next_index_raw = Self::serialize_index(next_index);\n                env::storage_write(&amp;index_lookup, &amp;next_index_raw);\n                self.elements.push_raw(element_raw);\n                true\n            }\n        }\n    }\n  ...\n}\nbingo!!!破案了,确实是调用了env::storage_write.\n总结这篇文章到这里就结束了,我们研究了当LazyOption和UnorderedSet搭配使用时,在修改了状态但未调用LazyOption的set方法时,存储行为不一致的现象.了解了LazyOption和UnorderedSet的实现机制,以及合约状态是如何序列化和反序列化的.\n","slug":"near_sdk_issues_703","date":"2022-04-01T02:11:26.300Z","categories_index":"NEAR 合约开发","tags_index":"NEAR,NEAR SDK","author_index":"Bref"},{"id":"afa5c84143f6c6cd1bcd166aafa8f4ba","title":"NEAR 协议规范 - 链规范","content":"共识定义和符号为了维护共识,交易被分组成一个个区块(block).有一个预先配置的区块被成为创世区块(genesis block).除了以外的每个区块都有一个连接点指向前一个区块 , 为当前区块.并且任何区块沿着连接最终都会到达(也就是说,不会成环).\n区块之间的连接产生了顺序:拿和举例,＜意味着并且可以沿着最终找到,而意味着＜或.\n＞和被定义为与＜和相反.同时, 定义和之间的关系为＞、＜、三者之一(即:在同一条链上),则意味着相反的含义.\n链定义为一个区块集合,集合里的每个区块都可以从区块沿追溯.所以,.对于区块和区块,仅当时,和才能同时属于一条链.在这种情况下,我们称和在同一条链上.\n每个区块都有一个整数类型的高度.它保证了区块的高度是单调的(在这里,任何非创世区块的区块,都满足＞),但他们不一定连续(存在的可能).同时,  可能不为0.每个节点都跟踪一个它知道的最大高度的有效块,这个高度被称为 .\n区块们被分组成一个个纪元.在一条链中,属于同一个纪元的区块集合形成了一个连续的范围:如果区块和区块属于同一个纪元并且满足＜,那么任何一个区块,只要满足＜＜,那么一定属于这个纪元.纪元可以使用顺序索引来标识:创世区块所属的纪元被标识为0,对于其他的区块来说,它所属的纪元索引要么和一样,要么比大一.\n每个纪元都有一组块生产者(block producer)负责在该纪元生产区块.并且纪元中的每个区块高度都分配给了专门的块生产者负责生产.负责生产区块高度h的块生产者被称为h区块提议人(block proposer at h). 索引 的纪元的信息(验证人集合和高度分配)是由索引的纪元的最后一个区块决定.对于索引为0和1的纪元,这些信息是预先配置的.因此,如果两条链共享某个纪元的最后一个块,那么它们将在两个纪元后拥有同样的验证人集合和高度分配,但在那之后就不一定了.\n共识协议定义了一个概念——确定性.简单的说,一旦区块被确定,那么未来确定的区块只能在之上构建.也就是说,和其之前的块中的交易将永远无法撤销.确定性不由区块本身决定,也就是说,一个块在它所属的链中可能是确定的,也有可能是不确定的.具体来说,当时,被定义为在链中是确定的.一个区块在一条链中确定,那么在这条链的所有延生中,它都是确定的.即:如果成立,那么在时,也成立.\n数据结构区块头中与共识相关的部分如下:\nstruct BlockHeader {\n    ...\n    prev_hash: BlockHash,\n    height: BlockHeight,\n    epoch_id: EpochId,\n    last_final_block_hash: BlockHash,\n    approvals: Vec&lt;Option&lt;Signature&gt;&gt;\n    ...\n}\n同一纪元的区块生产者交换各种各样的信息.与共识有关的两种类型是Blocks和Approvals.Approval包含下面字段:\nenum ApprovalInner {\n    Endorsement(BlockHash),\n    Skip(BlockHeight),\n}\n\nstruct Approval {\n    inner: ApprovalInner,\n    target_height: BlockHeight,\n    signature: Signature,\n    account_id: AccountId\n}\n枚举值背书(Endorsement)的参数是被许可的区块的hash,枚举值跳过(Skip)的参数是被许可的区块的高度.target_height是可以使用许可的特定高度(包含指定的target_height的许可的区块必须满足height==target_height ).account_id是创建许可的区块生产者的账户名,signature是元组(inner,target_height)的签名.\n许可要求 Approvals Requirements除创世区块以外,每个区块逻辑上必须包含一些来自区块生产者许可(其格式在下一段中进行描述),并且这些许可的批准方质押的权益超过本纪元总权益的三分之二.此外,在后面描述的纪元切换情况下,还需要获得下一个纪元的超过三分之二质押量的区块生产者的许可.\n逻辑上当且仅当时,区块包含的许可一定是带有哈希值的背书许可,否则,它一定是带有区块高度的跳过许可.关于为什么背书许可必须包含前一个块的哈希值,以及跳过许可必须包含高度的详细信息.参阅后面的许可条件小节\n请注意,由于逻辑上存储在区块的中的每个许可的字段对于每个区块生产者来说都是相同的(除了发送方的account_id和signature).因此存储完整的许可是多余的.实际上,我们只存储许可的签名.他们存储的具体方式如下:首先从当前纪元获得有序的区块生产者集合.如果区块在纪元边界上,那么需要包含下一个纪元的区块生产者的许可,则添加新的纪元的区块生产者.\ndef get_accounts_for_block_ordered(h, prev_block):\n    cur_epoch = get_next_block_epoch(prev_block)\n    next_epoch = get_next_block_next_epoch(prev_block)\n\n    account_ids = get_epoch_block_producers_ordered(cur_epoch)\n    if next_block_needs_approvals_from_next_epoch(prev_block):\n        for account_id in get_epoch_block_producers_ordered(next_epoch):\n            if account_id not in account_ids:\n                account_ids.append(account_id)\n\n    return account_ids\n然后,该区块包含可选(optional)的签名向量(vector),大小与account_ids的大小相同或更小.如果缺少某个账户的审批,那么向量中对应的元素将被置位None,反之,则为许可消息的签名.显而易见的,由区块生产者签名的许可可以很容易地从区块中可用的信息重建,这样签名就可以被验证了.如果签名向量长度小于account_ids的长度,则认为剩余的签名都为None\n消息当收到许可消息时,参与者将其存储到许可消息集合中:\ndef on_approval(self, approval):\n    self.approvals.append(approval)\n当参与者接收到一个区块时,与共识有关的操作是更新head然后初始化一个定时器来开始在连续的target_height中发送这个区块的许可给区块的生产者.定时器的延迟取决于最后一个区块的高度,所以信息将会持久化\ndef on_block(self, block):\n    header = block.header\n\n    if header.height &lt;= self.head_height:\n        return\n\n    last_final_block = store.get_block(header.last_final_block_hash)\n\n    self.head_height = header.height\n    self.head_hash = block.hash()\n    self.largest_final_height = last_final_block.height\n\n    self.timer_height = self.head_height + 1\n    self.timer_started = time.time()\n\n    self.endorsement_pending = True\n定时器需要定期检查,并且包含以下逻辑:\ndef get_delay(n):\n    min(MAX_DELAY, MIN_DELAY + DELAY_STEP * (n-2))\n\ndef process_timer(self):\n    now = time.time()\n\n    skip_delay = get_delay(self.timer_height - self.largest_final_height)\n\t\t\n    if self.endorsement_pending and now &gt; self.timer_started + ENDORSEMENT_DELAY:\n\n        if self.head_height &gt;= self.largest_target_height:\n            self.largest_target_height = self.head_height + 1\n            self.send_approval(head_height + 1)\n\n        self.endorsement_pending = False\n\n    if now &gt; self.timer_started + skip_delay:\n        assert not self.endorsement_pending\n\n        self.largest_target_height = max(self.largest_target_height, self.timer_height + 1)\n        self.send_approval(self.timer_height + 1)\n\n        self.timer_started = now\n        self.timer_height += 1\n\ndef send_approval(self, target_height):\n    if target_height == self.head_height + 1:\n        inner = Endorsement(self.head_hash)\n    else:\n        inner = Skip(self.head_height)\n\n    approval = Approval(inner, target_height)\n    send(approval, to_whom = get_block_proposer(self.head_hash, target_height))\n其中get_block_proposer根据前一个区块哈希和下一个区块的高度返回区块提议人.\nENDORSEMENT_DELAY &lt; MIN_DELAY是必须的.此外,虽然对于正确性来说不是必须的,但我们要求ENDORSEMENT_DELAY * 2 &lt;= MIN_DELAY\n区块生产者首先,我们定义了一个方便的函数来获取包含在指定高度的区块中的许可\ndef get_approvals(self, target_height):\n    return [approval for approval\n                     in self.approvals\n                     if approval.target_height == target_height and\n                        (isinstance(approval.inner, Skip) and approval.prev_height == self.head_height or\n                         isinstance(approval.inner, Endorsement) and approval.prev_hash == self.head_hash)]\n每当区块提议人使用get_approvals收到的许可的签名方的质押量超过当前纪元总质押量的三分之二时,就在该高度产生一个块.\n确定性条件当时,区块在链  中是确定的.当或者存在一个区块 ,满足 ,同时也满足  和   .也就是说,要么是创世区块,要么  至少包含了基于  的两个区块,这三个区块(和后面的两个区块)具有连续的高度.\n纪元切换有一个参数定义了纪元的最小长度.假设一个特定的纪元从高度开始.并且假设下一个纪元是假设BP(e)是纪元e的区块生产者集合假设last_{final}(T)是chain(T)$ 中最后确认的区块.\n下面是区块应该包含哪些区块生产者的许可,以及他们属于哪个纪元的规则:\n\n任何在纪元中并符合＜的区块都必须拥有超过纪元总质押量三分之二的的许可\n\n\n\n\n\n\n\n\n\n每个纪元除了最后两个区块以外的所有区块都只需要本纪元区块生产者提供的许可\n\n任何在纪元符合 并且  的区块逻辑上必须包含超过总质押量三分之二的  的许可和总质押量超过的  的许可.\n\n\n\n\n\n\n\n\n\n每个纪元的最后两个区块额外需要下一个纪元的区块生产者提供的许可\n\n任何在纪元中并符合＜的区块都必须拥有超过纪元总质押量三分之二的的许可\n\n\n安全性注意在上面的实现中,一个诚实的区块生产者不会产出两个具有相同prev_height的背书(这被称为背书冲突).它也不会产生跳过消息 s 和背书 e 同时满足s.prev_height &lt; e.prev_height并且s.target_height &gt;= e.target_height\n\n\n\n\n\n\n\n\n\n即一个诚实的参与者如果在一个背书许可之前发出了一个跳过许可,那么跳过许可的target_height必然小于背书许可的target_height\n定理:假设有区块 、和 ,使得  ,并且  ,此时,有超过三分之一的区块生产者签署过相互冲突的背书或相互冲突的跳过和背书.\n\n\n\n\n\n\n\n\n\n如果有区块   , 和  不在同一条链上(即链在他们之前进行了分叉).同时  在  后,  在  后,并且  在链  中确定,在链中确定.那么意味着超过三分之一的区块生产者做出了恶意行为.\n证明:在不丧失普遍性的情况下,我们可以假设这些区块的高度是尽可能小.明确的说,我们可以假设 并且 .同时,  是  和  共同的祖先中最高的块.我们可以确定,不存在区块  同时满足  和 ＜ 以及  和 ＜＜.\n\n\n\n\n\n\n\n\n\n现在已知  和  分叉了.那么假设一个区块  是他们分叉的那个区块,那么在该区块后,不存在一个区块同时存在于两条链中,所以不能同时满足:   和 ＜ 以及和 ＜＜.\n辅助定理:必然存在一个纪元,里面有任意区块,只要满足或,那么该区块一定包含有中超过三分之二个区块生产者的许可.\n\n\n\n\n\n\n\n\n\n说人话:如果出现了定理中假设的情况,那么肯定有一个纪元中的区块生产者中出了叛徒,而且叛徒数量超过总量的三分之一\n证明:有两种情况:\n第一种情况:区块,,在同一纪元中.\n因为在指定纪元中的指定链上的区块是连续的,所以他们之间的区块(区块  满足  ＜ X ＜ T_1或者B_c ＜ X ＜ T_2$ )也位于同一纪元.\n第二种情况:区块  、 和  不全在同一个纪元中.\n假设  和  不在同一个纪元中,设  是  所在的纪元,  之前的纪元设为  (所以  不能处于创世区块所在的纪元).假设  和  分别为 链 在中的第一个和最后一个区块.此时,中一定存在一个区块  满足 ＜.因为 ＜,我们能得到,并且因为不存在一个确定的区块满足 , 我们可以得出:. 又因为在和之间没有其他的纪元了,我们可以得出结论:在纪元中.同样因为 .这样可以得出:  之后直到  结束的所有区块都包含超过  中三分之二的区块生产者的许可.\n应用同样的参数给  ,我们能确定  同时存在于  和  中,这样在  中任何区块  只要满足  ,就都包含了  中超过三分之二的区块生产者的许可(  中的生产者集合在  和  中是一样的.因为  之前的纪元的最后一个区块一定在  之前,所以  中区块生产者由两条链共享).对于  和  在同一纪元,而  和  在不同纪元的情况,处理方法类似.这样,辅助定理就被证明了.\n现在我们回到 定理 .在不丧失普遍性的情况下.假设  .一方面,如果  不包括高度为  的区块 ,那么链中第一个区块的高度就一定比  大.并且该区块包含了  中超过三分之二的区块生产者发出的跳过许可,并且一定与  之前的一个区块冲突.所以,中超过三分之一的区块生产者签署了相互冲突的跳过许可和背书许可.同样,  不能包含高度为 的区块.那么在中有超过三分之一的区块生产者在  中签署了背书,并且在  中高度大于的第一个区块中签署了跳过.另一方面,如果  包含高度为  和 的区块.那么后者必须包括前者的背书,这与对  的背书冲突.所以,在  中有超过三分之一的区块生产者签署了冲突的背书,所以定理 成立.\n活性你可以在near.ai/doomslug看到关于活性的证明.本节中的共识与它的不同之处在于,它需要通过连续两次背书.链接文件中的证明进行了简单的拓展,通过观察发现,一旦延迟足够长,一个诚实的区块生产者总是可以收集到足够的背书,下一个区块生产者也应该有足够的时间收集背书.\n许可条件前面提到的许可条件是:\n\n\n\n\n\n\n\n\n\n任何有效的区块逻辑上必须包含超过当前纪元三分之二的区块生产者的许可.对于区块 B 和它前一个区块 B’ 来说,有且仅有B.height ==B'.height+1时, B 中的每个许可都必须是背书许可并包含有 B’ 的hash,此外的所有情况, B 中的所有许可必须是 B’ 的跳过许可\n这比预想的要复杂的多,人们经常会把这两个条件同意起来.但不幸的是,他们不能同统一.\n对于背书许可来说,每个许可的prev_hash都等于前一个区块的哈希值,这一点很关键,否则上面的安全证明就不起作用了.在上面所说的第二种情况中,和中的背书就可以是完全相同的.\n对于跳过消息,我们不要求许可中的哈希值和前一个哈希值匹配,这一点很关键.因为恶意的参与者可以创建两个高度相同的块,并将他们分别分配给一半的区块生产者.两个半区的区块生产者向未来的区块提议人发送带有不同prev_hash但是具有相同prev_height的跳过消息.如果要求跳过消息中prev_hash和区块的prev_hash完全匹配,那么没有一个区块生产者可以创建他们的区块.\n","slug":"NEAR consensus","date":"2022-03-21T05:39:34.237Z","categories_index":"NEAR协议规范","tags_index":"NEAR,NEAR Protocol","author_index":"Bref"},{"id":"4d320b648a660e01f33dcb34ec3dc14e","title":"NEAR SDK - 减小合约尺寸","content":"建议和示例本文是为熟悉低级概念的开发人员编写的,这些开发人员希望以牺牲代码可读性为代价,显著的减少合约的尺寸.\n这些方法可能有用的一些常见场景:\n\n与个人账户管理绑定的合约\n使用工厂部署的合约\n未来的发展,比如运行在NEAR上的EVM\n\nSmall wins使用标记当编译合约时,确保将-C link-arg=-s传递给rust编译器\nRUSTFLAGS&#x3D;&#39;-C link-arg&#x3D;-s&#39; cargo build --target wasm32-unknown-unknown --release\n下面是在大多数实例的Cargo.toml中使用的示例:\n[profile.release]\ncodegen-units &#x3D; 1\nopt-level &#x3D; &quot;s&quot;\nlto &#x3D; true\ndebug &#x3D; false\npanic &#x3D; &quot;abort&quot;\noverflow-checks &#x3D; true\n你可能想尝试使用opt-level = &quot;z&quot;替换opt-level = &quot;s&quot;,看是否能生成较小二进制文件.查看The Cargo Book Profiles section获得更多细节.你可能也想引用 Shrinking .wasm Size这个资源.\n从名单中删除rlib确认你的名单(Cargo.toml)没有包含rlib,除非它需要.一些NEAR的示例包含以下内容\n\n\n\n\n\n\n\n增加了不必要的膨胀\n[lib]\ncrate-type &#x3D; [&quot;cdylib&quot;, &quot;rlib&quot;]\n\n\n可以这样修改:\n\n\n\n\n\n\n提示\n[lib]\ncrate-type &#x3D; [&quot;cdylib&quot;]\n\n\n重载序列化协议当使用Rust SDK时,可以使用Borsh重载默认的JSON序列化.在这里查看更多的信息和示例\n避免使用标准的assert宏当使用断言时,避免使用标准的assert宏,像assert!,assert_eq!,或者assert_ne!,因为这些宏可能会添加关于错误行号的信息.unwrap,expect`和Rust的panic!()``宏也有这个问题\n一个标准的断言:\n\n\n\n\n\n\n\n增加不必要的膨胀\nassert_eq!(contract_owner, predecessor_account, \"ERR_NOT_OWNER\");\n\n\n可以这样修改:\n\n\n\n\n\n\n提示\nif contract_owner != predecessor_account &#123;\n  env::panic(b\"ERR_NOT_OWNER\");\n&#125;\n\n\n移除expect的示例:\n\n\n\n\n\n\n\n增加不必要的膨胀\nlet owner_id = self.owner_by_id.get(&amp;token_id).expect(\"Token not found\");\n\n\n可以这样修改:\n\n\n\n\n\n\n提示\nfn expect_token_found&lt;T>(option: Option&lt;T>) -> T &#123;\n  option.unwrap_or_else(|| env::panic_str(\"Token not found\"))\n&#125;\nlet owner_id = expect_token_found(self.owner_by_id.get(&amp;token_id));  \n\n\n修改标准的panic!()宏:\n\n\n\n\n\n\n\n增加不必要的膨胀\npanic!(\"ERR_MSG_HERE\"); \n\n\n可以这样修改:\n\n\n\n\n\n\n提示\nenv::panic_str(\"ERR_MSG_HERE\");  \n\n\n低级别方法关于使用no_std最小化合约的方法,观察以下示例:\n\nTiny contract\nNEAR ETH Gateway\nThis YouTube video](https://youtu.be/Hy4VBSCqnsE) - 关于同质化代币的示例.代码在这里example lives here.\nExamples using a project called nesdie.\n请注意,Aurora已经发现使用rjson作为轻量化的JSON序列化协议是成功.它比目前的serde占用的空间更小.请查阅Aurora存储库中的rjson示例,不过实现细节必须由读者发掘,这里不做展开.nesdie示例也使用miniserde crate,对那些避免使用Rust SDK的人来说,这是另一个选择\n\n","slug":"NEAR SDK - 减小合约尺寸","date":"2022-03-16T09:39:28.918Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"},{"id":"4de024db83e7edaabd96aab0805a6851","title":"NEAR SDK - 合约升级","content":"升级合约当你修改了合约接口并重新部署时,你可能会看到这样的错误:\nCannot deserialize the contract state.\n为什么会这样?\n当你的合约执行时,NEAR Runtime从磁盘读取序列化后的状态,并且使用当前的合约代码来加载它.当你的代码改变但是序列化后的状态保持不填时,Runtime无法判断该如何去做.\n如何避免这样的错误?\n当你还处于研发阶段,你可以构建一个原型并在本地或测试网络中部署它.当你做出了一个突破性的修改,你可以删除所有以前的合约状态.下面有几种方法可以做到这一点.\n当你准备好部署一个更稳定的合约时,有几个生产策略可以帮助你更新合约状态而不无需删除它.一旦你的合约从”可信任模式”(维护者控制一个Full Access key)过渡到社区治理模式(不再拥有Full Access key).你就需要知道如何通过DAO投票来升级你的合约代码本身.\n快速原型开发:删除所有内容这里有两种方式来删除账户状态:\n\nrm -rf neardev &amp;&amp; nearr dev-deploy\n删除并重新创建一个合约账户\n\n对于这两种情况,让我们考虑下面的示例\nrust-status-message合约示例拥有下面的结构:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct StatusMessage &#123;\n    records: LookupMap&lt;String, String>,\n&#125;\n\nimpl Default for StatusMessage &#123;\n    fn default() -> Self &#123;\n        Self &#123;\n            records: LookupMap::new(b\"r\".to_vec()),\n        &#125;\n    &#125;\n&#125;\n\n#[near_bindgen]\nimpl StatusMessage &#123;\n    pub fn set_status(&amp;mut self, message: String) &#123;\n        let account_id = env::signer_account_id();\n        self.records.insert(&amp;account_id, &amp;message);\n    &#125;\n\n    pub fn get_status(&amp;self, account_id: String) -> Option&lt;String> &#123;\n        return self.records.get(&amp;account_id);\n    &#125;\n&#125;\n我们假设你已经在测试网部署了合约,然后进行下面的调用:\nnear call [contract] set_status &#39;&#123;&quot;message&quot;: &quot;lol&quot;&#125;&#39; --accountId you.testnet\nnear view [contract] get_status &#39;&#123;&quot;account_id&quot;: &quot;you.testnet&quot;&#125;&#39;\n这将放回你通过调用set_status设置的消息,在本例中为”lol”\n此时,合约已经部署并拥有了一些状态\n现在,我们假设你修改了合约,为每个账户存储两种数据\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct StatusMessage &#123;\n    taglines: LookupMap&lt;String, String>,\n    bios: LookupMap&lt;String, String>,\n&#125;\n\nimpl Default for StatusMessage &#123;\n    fn default() -> Self &#123;\n        Self &#123;\n            taglines: LookupMap::new(b\"r\".to_vec()),\n            bios: LookupMap::new(b\"b\".to_vec()),\n        &#125;\n    &#125;\n&#125;\n\n#[near_bindgen]\nimpl StatusMessage &#123;\n    pub fn set_tagline(&amp;mut self, message: String) &#123;\n        let account_id = env::signer_account_id();\n        self.taglines.insert(&amp;account_id, &amp;message);\n    &#125;\n\n    pub fn get_tagline(&amp;self, account_id: String) -> Option&lt;String> &#123;\n        return self.taglines.get(&amp;account_id);\n    &#125;\n\n    pub fn set_bio(&amp;mut self, message: String) &#123;\n        let account_id = env::signer_account_id();\n        self.bios.insert(&amp;account_id, &amp;message);\n    &#125;\n\n    pub fn get_bio(&amp;self, account_id: String) -> Option&lt;String> &#123;\n        return self.bios.get(&amp;account_id);\n    &#125;\n&#125;\n你再次构建和部署这个合约,心想可能因为新的taglinesLookupMap集合与旧的recordLookupMap集合拥有同样的前缀(前缀r,在LookupMap::new(b&#39;r&#39;.to_vec())时设置),你在tagline中的数据应该是&quot;lol&quot; ,但当你near view这个合约时,你得到了Cannot deserialize消息.该怎么做?\n1.rm -rf neardev &amp;&amp; near dev-deploy当我们开始一个新项目时,最快的部署合约的方法是使用dev-deploy\nnear dev-deploy [--wasmFile .&#x2F;path&#x2F;to&#x2F;compiled.wasm]\n它会做下面几件事:\n\n创建一个测试网账户,名称类似于dev-1232323131231123-356645345345345\n将账户名存储项目中的neardev文件夹\n将该账户的私钥存储到~/.near-credentials文件夹中\n将你的合约代码部署到该账户\n\n下一次你使用dev-deploy时,它会检查neardev文件夹然后重新部署到相同的账户,而不是重新创建一个\n但是在上面的例子里,我们想要删除账户状态.我们该怎么做?\n最简单的方法就是删除neardev文件夹,然后再次运行near dev-deploy.这将创建一个测试网账户以及(空的)账户状态.接下来在上面部署最新的合约.\n2.删除并重新创建合约账户如果你想要相比不断变化的dev-*账户更想要一个可预测的账户,最好的方法可能是创建一个子账户\nnear create-account app-name.you.testnet --masterAccount you.testnet\n然后你可以在上面部署你的合约\nnear deploy --accountId app-name.you.testnet [--wasmFile .&#x2F;path&#x2F;to&#x2F;compiled.wasm]\n在这个例子中,你改怎么删除所有账户状态并重新开始呢?删除子账户并重新创建它\nnear delete app-name.you.testnet you.testnet\n这会将app-name.you.testnet账户的资金发送给you.testnet.并且会删除已经部署在它上面的合约已经所有的合约状态\n现在你创建了一个子账户并通过上面的命令重新部署了合约.账户的状态将是全新的,就像你第一次在上面部署一样.\n生产应用基础当新代码部署到生产合约时,你显然不能像在快速原型开发过程中那么销毁旧的账户状态.那么怎么避免这种可怕的错误呢?\nCannot deserialize the contract state.\n你有几种不同的解决方案,取决于你的合约的复杂性.\nMigration方法以前面的rust-status-message为例,你只需要一个简单的migration方法\n提醒一下,我们的目的是改变下面的合约:\npub struct StatusMessage &#123;\n    records: LookupMap&lt;String, String>,\n&#125;\n\nimpl Default for StatusMessage &#123;\n    fn default() -> Self &#123;\n        Self &#123;\n            records: LookupMap::new(b\"r\".to_vec()),\n        &#125;\n    &#125;\n&#125;\n变成:\npub struct StatusMessage &#123;\n    taglines: LookupMap&lt;String, String>,\n    bios: LookupMap&lt;String, String>,\n&#125;\n\nimpl Default for StatusMessage &#123;\n    fn default() -> Self &#123;\n        Self &#123;\n            taglines: LookupMap::new(b\"r\".to_vec()),\n            bios: LookupMap::new(b\"b\".to_vec()),\n        &#125;\n    &#125;\n&#125;\nNEAR运行时查看你序列化并保存在磁盘中的代码和合约数据.当它执行代码时,将尝试匹配他们.如果你改变了代码但是数据已经保持不变,运行时将无法理解该如何去做.之前我们通过移除旧的序列化代码”解决”了这个问题.现在让我们来看看怎么更新已经存在的数据.\n首先,在最后一次部署时保持旧的结构体\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct OldStatusMessage &#123;\n    records: LookupMap&lt;String, String>,\n&#125;\n然后在主结构体方法实现中添加一个migrate方法\n#[private]\n#[init(ignore_state)]\npub fn migrate() -> Self &#123;\n    let old_state: OldStatusMessage = env::state_read().expect(\"failed\");\n    Self &#123;\n        taglines: old_state.records,\n        bios: LookupMap::new(b\"b\".to_vec()),\n    &#125;\n&#125;\n\n点击查看合约更新前后的差别\n+#[derive(BorshDeserialize, BorshSerialize)]\n+pub struct OldStatusMessage &#123;\n+    records: LookupMap&lt;String, String>,\n+&#125;\n+\n #[near_bindgen]\n #[derive(BorshDeserialize, BorshSerialize)]\n pub struct StatusMessage &#123;\n-    records: LookupMap&lt;String, String>,\n+    taglines: LookupMap&lt;String, String>,\n+    bios: LookupMap&lt;String, String>,\n &#125;\n \n impl Default for StatusMessage &#123;\n     fn default() -> Self &#123;\n         Self &#123;\n-            records: LookupMap::new(b\"r\".to_vec()),\n+            taglines: LookupMap::new(b\"r\".to_vec()),\n+            bios: LookupMap::new(b\"b\".to_vec()),\n         &#125;\n     &#125;\n &#125;\n \n #[near_bindgen]\n impl StatusMessage &#123;\n-    pub fn set_status(&amp;mut self, message: String) &#123;\n+    pub fn set_tagline(&amp;mut self, message: String) &#123;\n         let account_id = env::signer_account_id();\n-        self.records.insert(&amp;account_id, &amp;message);\n+        self.taglines.insert(&amp;account_id, &amp;message);\n+    &#125;\n+\n+    pub fn get_tagline(&amp;self, account_id: String) -> Option&lt;String> &#123;\n+        return self.taglines.get(&amp;account_id);\n     &#125;\n\n-    pub fn get_status(&amp;self, account_id: String) -> Option&lt;String> &#123;\n-        return self.records.get(&amp;account_id);\n+    pub fn set_bio(&amp;mut self, message: String) &#123;\n+        let account_id = env::signer_account_id();\n+        self.bios.insert(&amp;account_id, &amp;message);\n+    &#125;\n+\n+    pub fn get_bio(&amp;self, account_id: String) -> Option&lt;String> &#123;\n+        return self.bios.get(&amp;account_id);\n+    &#125;\n+\n+    #[private]\n+    #[init(ignore_state)]\n+    pub fn migrate() -> Self &#123;\n+        let old_state: OldStatusMessage = env::state_read().expect(\"failed\");\n+        Self &#123;\n+            taglines: old_state.records,\n+            bios: LookupMap::new(b\"b\".to_vec()),\n+        &#125;\n     &#125;\n &#125;\n\n\n你可以在部署你的更改时,调用migrate方法\nnear deploy \\\n  --wasmFile res&#x2F;status_message.wasm \\\n  --initFunction &quot;migrate&quot; \\\n  --initArgs &quot;&#123;&#125;&quot; \\\n  --accountId app-name.you.testnet\n最终,你可以通过新的get_tagline方法查看旧的消息.\nnear view app-name.you.testnet get_tagline &#39;&#123;&quot;account_id&quot;: &quot;you.testnet&quot;&#125;&#39;\n\n\n\n\n\n\n整理合约\n此时,所有的合约状态都已经迁移,你不需要保留OldStatusMessage结构或migrate方法.你可以随意删除他们并在不调用initFunction的情况下再次部署他们.你的合约会很简洁,并为下一次迁移做好准备\n\n\n使用枚举在上面的例子里,所有的合约状态都存储在一个简单的结构体中.真实世界中的合约会更加的复杂,经常拥有其他结构体的引用.例如,一个DAO合约可能看起来是这样的:\n#[derive(BorshSerialize, BorshDeserialize)]\npub enum ProposalStatus &#123;\n    Proposed,\n    Approved,\n    Rejected,\n&#125;\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct Proposal &#123;\n    pub description: String,\n    pub status: ProposalStatus,\n&#125;\n\n#[near_bindgen]\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct DAO &#123;\n    pub proposals: LookupMap&lt;u64, Proposal>,\n&#125;\n\n\n\n\n\n\n笔记\n有关DAO示例的完整信息,查看SputnikDAO,Flux,还有其他\n\n\n假设你想要更新Proposal的结构,但是保持DAO不变\n首先要注意的是,合约中可能存储有大量Proposal数据.由于gas的限制,不可能再一个交易中迁移所有提案.在链外脚本中,你可以查询合约完整的状态,并通过多个交易更新每一个Proposal数据.但是,这可能会非常昂贵.所以您可能会选择在下一次和Proposal数据交互时更新Proposal(这将成本分散给了每个用户).\n在任何一种情况下,你的合约都可能同时使用原始的结构和新的结构来结束Proposal.并且DAO结构体需要知道如何加载这两种结构.这是怎样做到的?\n使用枚举:\n#[derive(BorshSerialize, BorshDeserialize)]\npub enum ProposalStatus &#123;\n    Proposed,\n    Approved,\n    Rejected,\n&#125;\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct ProposalV1 &#123;\n    pub description: String,\n    pub status: ProposalStatus,\n&#125;\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct Proposal &#123;\n    pub title: String,\n    pub description: String,\n    pub status: ProposalStatus,\n&#125;\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub enum UpgradableProposal &#123;\n    V1(ProposalV1),\n    V2(Proposal),\n&#125;\n\nimpl From&lt;UpgradableProposal> for Proposal &#123;\n    fn from(proposal: UpgradableProposal) -> Self &#123;\n        match proposal &#123;\n            UpgradableAccount::V2(proposal) => proposal,\n            UpgradableAccount::V1(v1) => Proposal &#123;\n                // set title to first 10 chars of description\n                title: v1.description.get(..10).map(str::to_owned).unwrap_or_default(),\n                description: v1.description,\n                status: v1.status,\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n#[near_bindgen]\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct DAO &#123;\n    pub proposals: LookupMap&lt;u64, UpgradableProposal>,\n&#125;\n\n\n\n\n\n\n\n未测试的实例\n上面的示例没有经过测试,可能是未完成或包含有bug\n需要有人创建一个完整的示例库,清楚的演示这个升级过程,并在上面的片段链接到它\n此时,你可以在下面的链接中看到工作中的实例和了解更多关于这个模式的信息\n\nhttps://github.com/evgenykuzyakov/berryclub/commit/d78491b88cbb16a79c15dfc3901e5cfb7df39fe8\nhttps://nomicon.io/ChainSpec/Upgradability.html\nhttps://github.com/mikedotexe/rust-contract-upgrades/pulls\n\n\n\n编写可升级的合约如果你计划在合约的生命周期内升级你的合约,从枚举开始.只有在决定升级之后才添加他们是可行的.但会导致难以遵循(更容易出错)的代码.\nDAO治理升级当你在主网中第一次部署一个合约,你可能会对合约的完全访问秘钥保持控制.这将置合约于”授信”模式.在这种模式下,你和其他维护者可以随意更改它(这意味着你的用户需要信任你不会窃取他们的资金,修改他们的投票或者其他恶意行为).这对于早期的合约和应用来说是不错的,但和其他区块链一样,NEAR允许你做的更好.\n当你准备好, 你可以删除所有的完全访问秘钥.这意味着任何人都不能单方面的升级合约.相反,合约只能通过DAO升级.在移除所有的完全访问秘钥之前,你需要实现两个方法:\n\n一种存储提议的合约新版本的方法(以Wasm bytes存在,以一种可检查的方式,这样DAO成员就可以验证字节是否与源代码的特定更改相匹配).这个函数是安全的,任何人都可以调用它.\n另外还需要一种实际部署新版本的方法.这个方法应该检查是否被您的DAO合约调用.DAO合约账户名可以在你的合约中用一个类似于owner_id的字段存储,这样它就可以通过相同的流程进行升级\n\n这里是Ref Finance是怎么做的,SputnikDAO是怎么做的,以及一些其他提示\n","slug":"NEAR SDK - 合约升级","date":"2022-03-15T12:01:57.814Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"},{"id":"a23d5d06f30f38065a9f935e1d761d88","title":"NEAR SDK - 构建合约","content":"基本说明你可以通过下面的命令来编译出你的合约的发行版本\ncargo build --target wasm32-unknown-unknown --release\n\n\n\n\n\n\n\n\n\n上面的build命令指定了一个target标志来创建一个WebAssembly.wasm文件\n注意你的工程目录现在增加了一点文件:\n.\n├── Cargo.lock  ⟵ created during build to lock dependencies\n├── Cargo.toml\n├── src\n│  └── lib.rs\n└── target      ⟵ created during build, holds the compiled wasm\n构建和标记我们推荐你使用下面的标记来优化你的构建产物\nenv &#39;RUSTFLAGS&#x3D;-C link-arg&#x3D;-s&#39; cargo build --target wasm32-unknown-unknown --release\n上面的命令本质上是设置了特殊的标记来优化构建产物.最终,它也只是一个个性化的cargo build --release命令罢了\nWindows用户:请像这样这样修改上面的命令:\nset RUSTFLAGS&#x3D;-C link-arg&#x3D;-s\ncargo build --target wasm32-unknown-unknown --release\n你可以将标记添加至ProjectFolder/.cargo/config.toml来简化你的命令\n[target.wasm32-unknown-unknown]\nrustflags &#x3D; [&quot;-C&quot;, &quot;link-arg&#x3D;-s&quot;]\n这里可以找到示例\n可重现的构造可重现的构造使得不同的人构造同样的程序,并得到彼此完全相同的输出.这将帮助用户信任已部署的合约是正确构造的,并且与源代码对应.要验证您的合约,用户可以自己构造它,并检查二进制文件是否相同.\n问题如果你在两台不同的机器上构建你的合约.你大概率会得到两份相似但不完全相同的二进制文件.你的构造产物会受你的换进的时区,低点,构造路径等十亿种因素的影响.Rust社区为解决这个问题已经战斗了很长的时间了.但是现在还没有解决\nCI解决方案我们建议你使用我们的Contract Builder来构造你的合约.它使用Docker,您和您的用户都可以使用相同的可控的环境.Docker镜像在这里.合约在Contract Builder中构造出的二进制文件与在其他的机器中构造出来的一样\n后期处理工具合约的大小是一个关键的特征.让它保持最小的最好方法是设计良好的极简代码,减少依赖项的数量.这在大型合约和大型多合约dApp中尤为重要,因为他们的部署会花费大量资金\n当你尽你所能优化了合约代码,通过减少合约规模来减小合约大小是值得的\n准备使用脚本我们准备了一个简单的bash脚本来修剪.wasm合约文件.你可以在这里找到它\n目前使用的缩小规模的方法如下:\n\n使用wasm-snip从标准库中删除一些已知的fat函数(如浮点格式和panic相关)\n使用wasm-gc从剪切掉的函数中排除所有可用到的函数\n去掉不需要的部分,比如使用wasm-strip\n运行binaryen wasm-opt,它会清除剩下的内容\n\n运行脚本的要求\n通过Cargo安装wasm-snip和wasm-gc:\ncargo install wasm-snip wasm-gc\n\n对于Ubuntu和其他基于Debian的Linux发行版,在你的系统中安装binaryen和wabt.\napt install binaryen wabt\n\n\n警告缩减可能是相当激进的.所以你必须测试缩减后的合约.[独立的NEAR运行时](https://www.near-sdk.io/building/post-processing-tools)可能是有用的.\n","slug":"NEAR SDK - 构建合约","date":"2022-03-14T11:55:53.530Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"},{"id":"5e99360b3a18af11a239b4863047980f","title":"NEAR SDK - 合约结构","content":"near_bindgen#[near_bindgen]宏被用于结构体和方法实现中以生成必要的代码使其成为一个可用的NEAR合约并且暴露想要公开的方法并使其能够被外部调用\n例如,下面是一个简单的计数合约,#[near_bindgen]宏被这样使用:\nuse near_sdk::borsh::&#123;self, BorshDeserialize, BorshSerialize&#125;;\nuse near_sdk::near_bindgen;\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct Counter &#123;\n    value: u64,\n&#125;\n\n#[near_bindgen]\nimpl Counter &#123;\n    pub fn increment(&amp;mut self) &#123;\n        self.value += 1;\n    &#125;\n\n    pub fn get_count(&amp;self) -> u64 &#123;\n        self.value\n    &#125;\n&#125;\n在上面的例子中,Counter结构体相当于智能合约的状态,可以包含任何实现了BorshDeserialize和BorshSerialize的成员,甚至是集合,我们将在后面讨论它.当方法被调用时,合约状态将被加载并反序列化,因此,保证加载的数据尽可能少是很重要的.\n#[near_bindgen]同样可以注释Counter的方法实现,这将生成必要的模板文件来暴露这些方法.我们必须牢记核心的交互规则:\n\n任何pub方法都能在外部被账户/合约调用.\n更多的信息,查看公共方法类型\n\n\nself有多种用法来控制合约的可变性\n使用&amp;self和self的方法将是只读的.并且不会写入和更新存储中的状态\n使用&amp;mut self的方法将允许改变状态,状态将在合约调用结束后写入存储\n\n\n如果公开的函数的参数不包括self.那么它的调用可以省略状态读写\n这对于一些静态功能或返回嵌入在合约代码中的数据可能很有用.\n\n\n如果函数有返回值,它将被序列化并且通过env::value_return作为结果附加\n\n初始化方法默认的,合约的Default::default()实现会用于合约的初始化.也可以有一个自定义的初始化函数,它接受参数并执行自定义逻辑.初始化韩式放在#[init]标注下\n#[near_bindgen]\nimpl Counter &#123;\n    #[init]\n    pub fn new(value: u64) -> Self &#123;\n        log!(\"Custom counter initialization!\");\n        Self &#123; value &#125;\n    &#125;\n&#125;\n所有合约都预先实现了Default,如果你想要禁止使用default实现,PanicOnDefault宏可以做到这一点:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Counter &#123;\n    // ...\n&#125;\n可支付方法方法可以标注为#[payable]以允许方法在调用时进行通证的转移.更多的信息,查看可支付方法\n下面的例子使用#[payable]注释宣告了函数是可支付的:\n#[payable]\npub fn my_method(&amp;mut self) &#123;\n...\n&#125;\n私有方法有些方法需要公开以允许合约通过Promise调用自身的方法,但是又不允许其他任何合约/账户调用它.为此,使用#[private]注释方法以使得外部合约/账户的调用会导致panic.更多的信息,查看私有方法\n该注释通过以下的方式应用\n#[private]\npub fn my_method(&amp;mut self) &#123;\n...\n&#125;\n集合当决定应用程序数据使用的数据结构时,重要的是尽可能减少读取和写入存储的数据量,以及反序列化和序列化的数据量,以尽可能的减少交易成本.理解智能合约中的不同数据结构的侧重点非常重要,因为随着程序的扩展,它将成为瓶颈,并且将状态迁移至新的数据结构会付出代价.\nnear-sdk中的容易被设计成将数据分割成块,并且只会在需要时才进行读取和写入.这些数据结构负责和存储的低级交互并且被设计成与std::collections具有相同的API.\n\n\n\n\n\n\n\n\n\nnear_sdk::collections将迁移至near_sdk::store并更新了API.如果你想要访问这些更新的结构体实现,启用unstable特性在near-sdk中.\n在使用std::collections时需要牢记,每次状态被加载时,数据结构中的所有数据都将被读取和反序列化.这将为使用任何非少量的数据带来巨大的开销.所以为了最小化gas使用量,大多数情况下,应该是用SDK中的集合.\nSDK中存在如下数据结构:\n\n\n\n\nSDK集合\nstd等价物\n描述\n\n\n\n\nLazyOption&lt;T&gt;\nOption&lt;T&gt;\n存储中可选的值.该类型只会在交互时才从存储中读取.当值存在于存储中时,会以 Some的类型提供,当不存在时返回 None\n\n\nVecttor&lt;T&gt;\nVec&lt;T&gt;\n可增长的数组类型.这些值在内存中分片,可以被迭代,并且索引值是可以动态调整大小的\n\n\nLookupMap&lt;K,V&gt;\nHashMap&lt;K,V&gt;\n该结构相当于一个合约可用的 map的廋包装体.该结构不包含任何关于 map 中元素的元数据,因此不可迭代\n\n\nunorderedMap&lt;K,V&gt;\nHashMap&lt;K,V&gt;\n与 LookupMap 类似,除了该结构保存能让内部元素进行迭代的额外数据\n\n\nTreeMap&lt;K,V&gt;\nBTreeMap&lt;K,V&gt;\nUnorderedMap 的有序等价物.当需要一致的顺序或者访问最小,最大键时,应该使用这个结构.底层实现基于 AVL tree\n\n\nLookupSet&lt;T&gt;\nHashSet&lt;T&gt;\n类似于 LookupMap 的 Set,但不存储和值.只被用来检查特定值是否存在.该结构不能迭代并且只能用来查找\n\n\nUnorderedSet&lt;T&gt;\nHashSet&lt;T&gt;\nLookupMap 的可迭代等价物,它存储了一些关于 Set 内部元素的额外信息\n\n\n\n\n内存中的 HashMap vs 持久化的 UnorderedMap\nHashMap 保持所有数据在内存中,为了访问它,合约需要反序列化整个 Map\nUnorderedMap 保持所有数据在存储中,访问任何元素只需要反序列化该元素.\n\n在什么时候使用 HashMap?\n\n需要在一次方法调用中迭代集合中的所有元素\n元素数量小或固定.例如小于 10 个\n\n在什么时候使用 UnorrderedMap?\n\n需要访问整个集合中有限的子集合,例如每次调用只需要访问 1 个或 2 个元素\n无法将整个集合放入内存,例如数据量过大\n\n原因是 HashMap``` 在一个存储操作中反序列化(或序列化)整个集合.比通过N`` 个存储操作访问所有元素更加节约 gas 费\n使用HashMap的示例:\n/// Using Default initialization.\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct Contract &#123;\n    pub status_updates: HashMap&lt;AccountId, String>,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn set_status(&amp;mut self, status: String) &#123;\n        self.status_updates.insert(env::predecessor_account_id(), status);\n        assert!(self.status_updates.len() &lt;= 10, \"Too many messages\");\n    &#125;\n\n    pub fn clear(&amp;mut self) &#123;\n        // Effectively iterating through all removing them.\n        self.status_updates.clear();\n    &#125;\n\n    pub fn get_all_updates(self) -> HashMap&lt;AccountId, String> &#123;\n        self.status_updates\n    &#125;\n&#125;\n使用UnorderedMap的示例:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract &#123;\n    pub status_updates: UnorderedMap&lt;AccountId, String>,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new() -> Self &#123;\n        // Initializing `status_updates` with unique key prefix.\n        Self &#123;\n            status_updates: UnorderedMap::new(b\"s\".to_vec()),\n        &#125;\n    &#125;\n\n    pub fn set_status(&amp;mut self, status: String) &#123;\n        self.status_updates.insert(&amp;env::predecessor_account_id(), &amp;status);\n        // Note, don't need to check size, since `UnorderedMap` doesn't store all data in memory.\n    &#125;\n\n    pub fn delete_status(&amp;mut self) &#123;\n        self.status_updates.remove(&amp;env::predecessor_account_id());\n    &#125;\n\n    pub fn get_status(&amp;self, account_id: AccountId) -> Option&lt;String> &#123;\n        self.status_updates.get(&amp;account_id)\n    &#125;\n&#125;\n使用持久化集合进行分页分页集合例如 UnorderedMap,UnorderedSet,和 Vector 可能包含的元素数量超过了 gas 限制下的读取数量.为了通过view调用来公开显示他们,我们可以实现分页.\nVector 通过使用.get(index)来获取指定下标的元素\n要在 UnorderedSet 使用下标来访问元素.我们可以使用.as_vector()方法,该方法将返回元素的 Vector\n关于 UnoderedMap 我们需要将 keys 和 values 转换成 Vector,分别使用.keys_as_vector()和.values_as_vector()\n使用UnorderedMap实现分页的示例:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract &#123;\n    pub status_updates: UnorderedMap&lt;AccountId, String>,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    /// Retrieves multiple elements from the `UnorderedMap`.\n    /// - `from_index` is the index to start from.\n    /// - `limit` is the maximum number of elements to return.\n    pub fn get_updates(&amp;self, from_index: u64, limit: u64) -> Vec&lt;(AccountId, String)> &#123;\n        let keys = self.status_updates.keys_as_vector();\n        let values = self.status_updates.values_as_vector();\n        (from_index..std::cmp::min(from_index + limit, self.status_updates.len()))\n            .map(|index| (keys.get(index).unwrap(), values.get(index).unwrap()))\n            .collect()\n    &#125;\n&#125;\nLookupMapvsUnorderedMap功能性\nUnorderedMap支持迭代keys和values,并且支持分页.在内部,它拥有三个存储结构\n一个存储key与index关系的map\n一个keys的数组\n一个values的数组\n\n\nLookupMap只拥有一个存储key和value关系的map.没有存储keys的数组,所以它没有能力进行keys的迭代\n\n性能LookupMap比UnorderedMap拥有更好的性能和存储更少的数据\n\nUnorderedMap获取数据时需要2次读取操作,写入或插入数据时需要3次写入操作\nLookupMap读取时需要1次读取操作,写入时需要1次写入操作\n\n存储空间UnorderedMap比LookupMap需要更多的存储空间\n\nUnorderedMap存储key两次(一次在map中,一次在数组中)和value一次.同时需要更高级别的常量来存储数组的长度和前缀\nLookupMap存储key,value各一次\n\nLazyOption这是一个只存储单个值的持久化集合,目标是阻止合约在不需要使用该值时进行反序列化.一个例子是存在一个大的元数据块,它只在view调用中使用,在大多数合约操作中不需要使用.\n它的作用类似于Option,可以保存值们也可以不保存值,同时还需要一个唯一的前缀,就像其他持久化集合一样.\n与其他集合一样,LazyOption只允许在初始化过程中初始化值.\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract &#123;\n    pub metadata: LazyOption&lt;Metadata>,\n&#125;\n\n#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]\n#[serde(crate = \"near_sdk::serde\")]\npub struct Metadata &#123;\n    data: String,\n    image: Base64Vec,\n    blobs: Vec&lt;String>,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new(metadata: Metadata) -> Self &#123;\n        Self &#123;\n            metadata: LazyOption::new(b\"m\", Some(metadata)),\n        &#125;\n    &#125;\n\n    pub fn get_metadata(&amp;self) -> Metadata &#123;\n        // `.get()` reads and deserializes the value from the storage. \n        self.metadata.get().unwrap()\n    &#125;\n&#125;\n集合嵌套使用传统方式构造唯一前缀在构造函数中使用一个硬编码的短字母前缀,该前缀将转换为字节 vector.使用嵌套集合,该前缀必须手动构造\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new() -> Self &#123;\n        Self &#123;\n            accounts: UnorderedMap::new(b\"a\"),\n            tokens: LookupMap::new(b\"t\"),\n            metadata: LazyOption::new(b\"m\"),\n        &#125;\n    &#125;\n\n    fn get_tokens(&amp;self, account_id: &amp;AccountId) -> UnorderedSet&lt;String> &#123;\n        let tokens = self.accounts.get(account_id).unwrap_or_else(|| &#123;\n            // Constructing a unique prefix for a nested UnorderedSet.\n            let mut prefix = Vec::with_capacity(33);\n            // Adding unique prefix.\n            prefix.push(b's');\n            // Adding the hash of the account_id (key of the outer map) to the prefix.\n            // This is needed to differentiate across accounts.\n            prefix.extend(env::sha256(account_id.as_bytes()));\n            UnorderedSet::new(prefix)\n        &#125;);\n        tokens\n    &#125;\n&#125;\n为持久化容器生产前缀每个持久化容器都需要一个唯一的前缀.该前缀被用于生成内部的键以持久化的存储数据.这些内部的键必须是唯一的以避免冲突(包括 STATE 的键冲突)当一个合约变的复杂,可能会有多个不同的集合,他们不是主结构的全部组成部分.而是子结构或嵌套容易,他们都需要唯一的前缀我们可以引入一个 enum 来追踪存储前缀和键.然后它们使用 borsh 序列化来为每个容器构造一个唯一的前缀.它与手工构造一样高效,因为 borsh 序列化,一个enum只需要 1 个 字节\nuse near_sdk::BorshStorageKey;\n\n#[derive(BorshStorageKey, BorshSerialize)]\npub enum StorageKeys &#123;\n    Accounts,\n    SubAccount &#123; account_hash: Vec&lt;u8> &#125;,\n    Tokens,\n    Metadata,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new() -> Self &#123;\n        Self &#123;\n            accounts: UnorderedMap::new(StorageKeys::Accounts),\n            tokens: LookupMap::new(StorageKeys::Tokens),\n            metadata: LazyOption::new(StorageKeys::Metadata),\n        &#125;\n    &#125;\n    \n    fn get_tokens(&amp;self, account_id: &amp;AccountId) -> UnorderedSet&lt;String> &#123;\n        let tokens = self.accounts.get(account_id).unwrap_or_else(|| &#123;\n            UnorderedSet::new(\n                StorageKeys::SubAccount &#123; account_hash: env::sha256(account_id.as_bytes()) &#125;\n            )\n        &#125;);\n        tokens\n    &#125;\n&#125;\n","slug":"NEAR SDK - 合约结构","date":"2022-03-14T06:18:47.231Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"},{"id":"7ea6f8c776c9e4fb015c2ac37083b48f","title":"NEAR SDK - 跨合约调用","content":"回调函数与工作量证明区块链不同,NEAR 协议是分片的,权益证明的区块链网络,当使用原生Rust(编译成 WASM)与智能合约交互时,跨合约调用是异步的.回调用来获取跨合约调用的结果或者用来获取跨合约调用是成功还是失败.\n这里有两种进行跨合约调用的技术:高级调用和低级调用.本文档将聚焦于高级调用.Rust SDK 库中有两个示例演示了这些内容.如上面的连接所示.注意这些例子使用跨合约调用他们自身.我们将使用两个示例来演示高级调用.\n计算器示例#[ext_contract(...)]宏可以帮助你创建一个跨合约调用.它将使用一个 Rust Trait 并且转化为一个具有静态方法的模块.每个静态方法都接受 Trait 定义的位置参数,然后是 receiver_id,附带的存款和 gas 数量然后返回一个 Promiss\n例如,让我们定义一个计算器合约 Trait\n#[ext_contract(ext_calculator)]\ntrait Calculator &#123;\n    fn mult(&amp;self, a: U64, b: U64) -> U128;\n\n    fn sum(&amp;self, a: U128, b: U128) -> U128;\n&#125;\n等价于:\nmod ext_calculator &#123;\n    pub fn mult(a: U64, b: U64, receiver_id: &amp;AccountId, deposit: Balance, gas: Gas) -> Promise &#123;\n        Promise::new(receiver_id.clone())\n            .function_call(\n                b\"mult\",\n                json!(&#123; \"a\": a, \"b\": b &#125;).to_string().as_bytes(),\n                deposit,\n                gas,\n            )\n    &#125;\n\n    pub fn sum(a: U128, b: U128, receiver_id: &amp;AccountId, deposit: Balance, gas: Gas) -> Promise &#123;\n        // ...\n    &#125;\n&#125;\n我们假设计算器合约已经部署在了账户calc.near上,我们接下来可以这么做:\nconst CALCULATOR_ACCOUNT_ID: &amp;str = \"calc.near\";\nconst NO_DEPOSIT: Balance = 0;\nconst BASE_GAS: Gas = 5_000_000_000_000;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn sum_a_b(&amp;mut self, a: U128, b: U128) -> Promise &#123;\n        let calculator_account_id: AccountId = CALCULATOR_ACCOUNT_ID.to_string();\n        ext_calculator::sum(a, b, &amp;calculator_account_id, NO_DEPOSIT, BASE_GAS)\n    &#125;\n&#125;\n白名单示例接下来我来看白名单智能合约的一个简单的跨合约调用,返回给定的用户是否在白名单里.跨合约调用的常见模式是首先调用外部智能合约的方法.然后使用.then 语法来标记一个回调.最后在 promiss 中取回数据或状态.回调将在同样的环境中调用只能合约.回调函数使用了特殊的宏#[privette].我们将在下面看到这个模式下面的示例演示两个使用高级调用进行跨和调用的方式.当编写高级跨合约调用时,被调用的智能合约接口被设置为特殊的 trait .并且(通常的)由当前合约进行这个调用(在那里存在回调逻辑).按照惯例,第二个 trait 被称为 ext_self.\n下面我们会看到一个简单的使用了两个 trait的示例:\n#[ext_contract(ext_self)]\npub trait ExtSelf &#123;\n    fn callback_promise_result() -> bool;\n    fn callback_arg_macro(#[callback] val: bool) -> bool;\n&#125;\n\n#[ext_contract(ext_whitelist)]\npub trait ExtWhitelist &#123;\n    fn is_whitelisted(staking_pool_account_id: AccountId) -> bool;\n&#125;\n在创建这些 trait 后,我们展示两个简单的函数,他们将进行白名单合约的跨合约调用.询问账户 mike.testnet 是否在白名单中.这两个方法都返回 bool 值.首先我们来看看方法,然后让我们来看看回调函数的区别.注意,简单起见,本例中的值是硬编码的.\npub const XCC_GAS: Gas = 20000000000000;\nfn get_whitelist_contract() -> AccountId &#123;\n    \"whitelist.demo.testnet\".to_string()\n&#125;\nfn get_account_to_check() -> AccountId &#123;\n    \"mike.testnet\".to_string()\n&#125;\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn xcc_use_promise_result(&amp;mut self) -> Promise &#123;\n        ext_whitelist::is_whitelisted(get_account_to_check(), &amp;get_whitelist_contract(), 0, XCC_GAS).then(\n            ext_self::callback_promise_result(\n                &amp;env::current_account_id(),\n                0,\n                XCC_GAS,\n            ),\n        )\n    &#125;\n\n    pub fn xcc_use_arg_macro(&amp;mut self) -> Promise &#123;\n        ext_whitelist::is_whitelisted(get_account_to_check(), &amp;get_whitelist_contract(), 0, XCC_GAS).then(\n            ext_self::callback_arg_macro(\n                &amp;env::current_account_id(),\n                0,\n                XCC_GAS,\n            ),\n        )\n    &#125;\n从ext_whitelist::is_whitelisted..开始的语法给我们展示了如何使用 trait 来调用方法is_whitelisted.然而,该 trait 只有一个参数,我们却传入了 4 个参数.其中后面 3 个参数将在幕后使用:\n\n目标合约账户(例如:whitelist.demo.testnet)\n附带的 Ⓝ存款,单位为 yocto Ⓝ(1 Ⓝ = 1000000000000000000000000 yoctoⓃ.)\ngas 数量\n\n代码片段中的两个方法非常相似,除了他们各自使用了不同的回调 callback_promise_result 和 callback_arg_macro\n#[private]\npub fn callback_promise_result(&amp;mut self) -> bool &#123;\n    assert_eq!(env::promise_results_count(), 1, \"ERR_TOO_MANY_RESULTS\");\n    match env::promise_result(0) &#123;\n        PromiseResult::NotReady => unreachable!(),\n        PromiseResult::Successful(val) => &#123;\n            if let Ok(is_whitelisted) = near_sdk::serde_json::from_slice::&lt;bool>(&amp;val) &#123;\n                is_whitelisted\n            &#125; else &#123;\n                env::panic(b\"ERR_WRONG_VAL_RECEIVED\")\n            &#125;\n        &#125;,\n        PromiseResult::Failed => env::panic(b\"ERR_CALL_FAILED\"),\n    &#125;\n&#125;\n\n#[private]\npub fn callback_arg_macro(&amp;mut self, #[callback] val: bool) -> bool &#123;\n    val\n&#125;\n这两个回调展示了如何获得值.第一个方法从 promise result 中获取值,第二个在参数中使用了宏来将值转化为所需的值.请注意,第二种方式没有第一种方式那么容易捕获错误.\n这两种方式最大的不同是参数是如何定义的.\n这就是所有的内容了.理解如何创建一个跨合约调用并且接收返回值是在 NEAR 上开发智能合约非常重要的一部分.\n","slug":"NEAR SDK - 跨合约调用","date":"2022-03-11T12:11:22.994Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"},{"id":"0d7a924133f95db56db161e3fcf8a116","title":"NEAR SDK - 合约接口","content":"公共方法类型基础实现在#[near_bindgen]宏包裹下的函数可以使用 pub标识符修饰,这样当它编译成WASM字节码以后就可以被外部调用 \n只讲能在外部调用的方法标记成public是很重要的.如果你需要合约自身来调用,你可以标记该方法为公共的但是添加#[private]修饰,这样除了合约自身的调用,任何调用都会导致panic\n基本的用法如下所示:\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn some_method(&amp;mut self) &#123;\n        // .. method logic here\n    &#125;\n&#125;\n这将从WASM二进制码中公开some_method,任何人都可以访问它\n\n展开显示生成的代码\n#[cfg(target_arch = \"wasm32\")]\n#[no_mangle]\npub extern \"C\" fn some_method() &#123;\n    near_sdk::env::setup_panic_hook();\n    if near_sdk::env::attached_deposit() != 0 &#123;\n        near_sdk::env::panic(\"Method some_method doesn\\'t accept deposit\".as_bytes());\n    &#125;\n    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();\n    contract.some_method();\n    near_sdk::env::state_write(&amp;contract);\n&#125;\n\n\n公开trait实现函数也能够公开自己的trait实现.这有助于在合约中实现共有的接口或标准.下面的代码与pub的基础用法很相似,除了#[near_bindgen]宏只需要附属在trait的实现上,而无需附属与trait本身.\npub trait MyTrait &#123;\n    fn trait_method(&amp;mut self);\n&#125;\n\n#[near_bindgen]\nimpl MyTrait for MyContractStructure &#123;\n    fn trait_method(&amp;mut self) &#123;\n        // .. method logic here\n    &#125;\n&#125;\n在这个例子中,生成的代码与前一个例子相同,只是方法名不一样\n\n展开显示生成的代码\n#[cfg(target_arch = \"wasm32\")]\n#[no_mangle]\npub extern \"C\" fn trait_method() &#123;\n    near_sdk::env::setup_panic_hook();\n    if near_sdk::env::attached_deposit() != 0 &#123;\n        near_sdk::env::panic(\"Method trait_method doesn\\'t accept deposit\".as_bytes());\n    &#125;\n    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();\n    contract.trait_method();\n    near_sdk::env::state_write(&amp;contract);\n&#125;\n\n\n合约状态可变性合约状态可变性是通过函数参数中的self参数是怎样的来自动处理的.根据使用的是哪一个,#[near_bindgen]宏将生成相应的代码来加载/反序列化任何使用self的函数的状态，序列化/存储状态只在使用&amp;mut self时使用。\n只读函数以不可变的方式调用合约时,交易结束时不会覆写任何状态.你可以通过使用&amp;self 或者 self 作为参数.他们都将生成同样的代码去加载并反序列化状态到结构体中,然后调用函数.不同的是,self 会将变量的所有权移动进函数中,&amp;self 仅仅将 self 的引用移动进函数中.\n下面是一个例子:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct MyContractStructure &#123;\n    integer: u64,\n    message: String,\n&#125;\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn get_values(self) -> (u64, String) &#123;\n        (self.integer, self.message)\n    &#125;\n    pub fn log_state_string(&amp;self) &#123;\n        near_sdk::env::log(self.message.as_bytes());\n    &#125;\n&#125;\n没有适用于所有情况的通用准则,但有一些核心规则需要遵守:\n\nself 如果在函数中移动了 self 的值或者其包含的值时使用 self 作为参数是很有用的,因为这样减少了 copy 和 clone 的操作\n/// View method. More efficient, but can't be reused internally, because it consumes self.\npub fn get_owner_id(self) -> AccountId &#123;\n    self.owner_id\n&#125;\n\n&amp;self当值需要只读的合约状态,或者函数使用了一些方法来获得了可用的所有权时使用&amp;self.如果结构体使用了大量内存,这很有用,可以避免将大量的数据转移进函数作用域中.\n/// View method. Requires cloning the account id.\npub fn get_owner_id(&amp;self) -> AccountId &#123;\n    self.owner_id.clone()\n&#125;\n\n返回派生数据\n有些少见的情况需要我们通过只读的方式来返回从存储中获取并修改的数据.如下面所示:\n/// View method that \"modifies\" state, for code structure or computational\n/// efficiency reasons. Changes state in-memory, but does NOT save the new\n/// state. If called internally by a change method, WILL result in updated\n/// contract state.\npub fn update_stats(&amp;self, account_id: AccountId, score: U64) -> Account &#123;\n    let account = self.accounts.get(&amp;account_id).unwrap_or_else(|| env::panic_str(\"ERR_ACCT_NOT_FOUND\"));\n    account.total += score;\n    account\n&#125;\n\n\n可变函数可变的函数允许加载存在的状态,然后对它进行修改,最后当方法调用结束后重新将状态写入\n这应该用于任何修改合约状态的交易中.注意,序列化的合约数据存在键 STATE 下持久化存储中.\n一个可变函数的例子:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct MyContractStructure &#123;\n    integer: u64,\n&#125;\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn modify_value(&amp;mut self, new_value: u64) &#123;\n        self.integer = new_value;\n    &#125;\n    pub fn increment_value(&amp;mut self) &#123;\n        self.integer += 1;\n    &#125;\n&#125;\n纯函数这一类函数根本不使用 self,也不需要从存储中读取或者写入合约状态\n使用公共的纯函数的情况很少,但是返回嵌入到合约代码中的数据或执行一些不依赖合约状态的静态共享逻辑时可能很有用\n一个纯函数的例子:\nconst SOME_VALUE: u64 = 8;\n\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn log_message(/* Parameters here */) &#123;\n        near_sdk::log!(\"inside log message\");\n    &#125;\n    pub fn log_u64(value: u64) &#123;\n        near_sdk::log!(\"&#123;&#125;\", value);\n    &#125;\n    pub fn return_static_u64() -> u64 &#123;\n        SOME_VALUE\n    &#125;\n&#125;\n私有方法何时使用回调通常,当合约必须为一个远程交叉合约调用进行回调时,这个回调方法必须只能被合约自身调用.这能避免有人直接调用它而搞乱合约状态.更常见的模式是使用断言来验证直接调用者(predecessor account ID)是否是合约自己的账户(current account ID).#[private]宏会简化这个操作,提高代码可读性.\n在near_bindgen宏包裹的代码里使用这个标注,例如:\n#[private]\npub fn my_method(&amp;mut self) &#123;\n    …\n&#125;\n上面的代码等价于\npub fn my_method(&amp;mut self ) &#123;\n    if env::current_account_id() != env::predecessor_account_id() &#123;\n        near_sdk::env::panic(\"Method method is private\".as_bytes());\n    &#125;\n...\n&#125;\n现在通过这个标注,只有合约账户本身可以调用这个方法,可以直接调用也可以通过哦Promise\n编写内部方法不是所有的方法都需要暴露为公开的,为 helper 或 uility 函数编写私有的方法也许更加有益.下面是三种编写内部方法的途径\n\n使用 fn 替换 pub fn\nfn helper_method(a: u8, b: u8) &#123;\n  …\n&#125;\n\n使用pub(crate) fn.这将有助于在不同的模块中使用内部函数\n// Function that can be called in another Rust file\npub(crate) fn get_first_name(account: Account) &#123;\n  …\n&#125;\n\n分散的impl块\n另外一种不暴露方法的方式是有一个单独的impl Contract部分,并且这部分不使用#[near_bindgen]宏\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn increment(&amp;mut self) &#123;\n        self.internal_increment();\n    &#125;\n&#125;\nimpl Contract &#123;\n    /// This methods is still not exported.\n    pub fn internal_increment(&amp;mut self) &#123;\n        self.counter += 1;\n    &#125;\n&#125;\n\n\n可支付方法我们可以允许方法在函数调用时接受代币转移.这样做是为了让合约能够使用的时候定义其需要的代币费用.默认的方法是不可支付的,如果调用时尝试转移代币会导致 panic.这样做是因为安全原因,以免有人在函数调用时意外地转移代币\n使用#[payable]标注来申明方法是可支付的.\n#[payable]\npub fn my_method(&amp;mut self) &#123;\n...\n&#125;\n这将允许通过调用my_method方法来转移资产给合约\n例子:\n#[near_bindgen]\nimpl Contract &#123;\n    #[payable]\n    pub fn take_my_money(&amp;mut self) &#123;\n        env::log_str(\"Thanks!\");\n    &#125;\n    pub fn do_not_take_my_money(&amp;mut self) &#123;\n        env::log_str(\"Thanks!\");\n    &#125;\n&#125;\n等价于:\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn take_my_money(&amp;mut self) &#123;\n        env::log_str(\"Thanks!\");\n    &#125;\n    pub fn do_not_take_my_money(&amp;mut self) &#123;\n        if near_sdk::env::attached_deposit() != 0 &#123;\n            near_sdk::env::panic(b\"Method do_not_take_my_money doesn't accept deposit\");\n        &#125;\n        env::log_str(\"Thanks!\");\n    &#125;\n&#125;\n序列化协议SDK 中的序列化规则定义了结构体数据如何转化成字节,当需要传输数据到合约方法中或存储数据到状态中时.对于方法参数,SDK 接受JSON(默认)和 Borsh,对于存储数据在链上,使用 Borsh.\nJSON 和 Borsh 的特点如下:JSON:\n\n人类可读\n自解释样式(不需要知道底层类型)\n与 JavaScript 的易互操作性\n低效率的(反)序列化Borsh\n紧凑的二进制格式可以高效率的进行数据的序列化和反序列化\n需要知道数据格式或者有一个模板来反序列化数据\n严格规范的二进制表示\n在大多数情况下,快速并且开销更小通常来说,JSON 用于合约调用和交叉合约调用以实现更好的适用性,Borsh 被用于优化合约中更小的参数序列化和更少的反序列化计算开销,以减少 gas 使用.\n\n重载默认的序列化协议结果和参数的序列化可以分开选择.但是所有的参数必须使用同样的样式(不能使用 borsh 序列化一部分参数,另外的参数使用 JSON 序列化).下面的例子是同时使用 borsh 来序列化返回值和参数\n#[result_serializer(borsh)]\npub fn sum_borsh(#[serializer(borsh)] a: u32, #[serializer(borsh)] b: u32) -> u32 &#123;\n    a + b\n&#125;\nJSON 重载为 borsh,```serializer(borsh)```标注将重载参数的序列化协议\n下面是在单元测试中使用 Borsh 序列化,并且使用 base64 编码的方法\n\n&#96;&#96;&#96;rust\n&#x2F;&#x2F;&#x2F; This test is simply a helper to print out the base64 value.\n#[test]\nfn borsh_simple() &#123;\n    let status_message &#x3D; &quot;Aloha honua!&quot;.to_string();\n    let borsh_input &#x3D; SetMessageInput &#123;\n        msg: status_message.clone()\n    &#125;;\n\n    let borsh_serialized: Vec&lt;u8&gt; &#x3D; borsh_input.try_to_vec().unwrap();\n    let base64_encoded &#x3D; near_primitives::serialize::to_base64(borsh_serialized.as_slice());\n    println!(&quot;Using NEAR CLI, this is the base64-encoded value to use: &#123;:?&#125;&quot;, base64_encoded);\n&#125;\n下面展示了在 CLI 中使用这个值的代码片段.注意,该方法没有返回值,所以不需要使用#[result_serializer(borsh)]来标注返回值\npub fn set_status_borsh(&amp;mut self, #[serializer(borsh)] message: SetMessageInput) &#123;\n    self.records.insert(&amp;env::signer_account_id(), &amp;String::from(message.msg));\n&#125;\n他们使用了这个简单的结构体:\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct SetMessageInput &#123;\n    // Note that the key does not have to be \"message\" like the argument name.\n    msg: String,\n&#125;\n在NEAR CLI中调用方法如下:\nnear call rust-status-message.demo.testnet set_status_borsh --base64 &#39;DAAAAEFsb2hhIGhvbnVhIQ&#x3D;&#x3D;&#39; --accountId demo.testnet\nJSON 包装类型为了帮助将某些类型序列化为 JSON,这些类型有意想不到或低效的默认格式,在 near_sdk::json_types 里有一些包装器类型可以使用因为 JavaScript 只支持整数类型的值到 2^53-1,如果反序列化 JSON 整型超过了这个范围,你将丢失精度.为了抵消这种影响,你可以使用 I64,U64,I128 和 U128 类型来代替这些参数或结果的本地类型,将值序列化为字符串.默认情况下,所有整数类型都将序列化为 JSON 中的整型你能使用 std::convert::Into 来将 U64 转化为 u64\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n        let a: u64 = a.into();\n        let b: u64 = b.into();\n        let product = u128::from(a) * u128::from(b);\n        product.into()\n    &#125;\n&#125;\n你也可以使用.0来访问内部值\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n        //let a: u64 = a.into();\n        let a = a.0;\n        //let b: u64 = b.into();\n        let b = b.0;\n        let product = u128::from(a) * u128::from(b);\n        product.into()\n    &#125;\n&#125;\n同时,你还可以使用U64(...)和U128(...)来转化u64和u128\n#[near_bindgen]\n impl Contract &#123;\n     pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n         let a = a.0;\n         let b = b.0;\n         let product = u128::from(a) * u128::from(b);\n         //product.into()\n         U128(product)\n     &#125;\n &#125;\n结合起来使用:\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n        U128(u128::from(a.0) * u128::from(b.0))\n    &#125;\n&#125;\n尽管JSON 包装类型只包含在 SDK 中,但是任何类型都可以使用,只要它各自实现了 serder 序列化和反序列化.所有这些类型都覆写了 JSON 格式并且与内部类型具有一致的 borsh 序列化和反序列特性\nBase64VecU8另外一个覆写默认序列化的例子是 Vec,它用来表示 Rust 中的字节.默认实现下,它将序列化为整型数组,这是不紧凑而且很难使用的.有一个包装类型Base64VecU8,它能序列化和反序列化 Base64 字符串再 JSON 的序列化中获得更多的紧凑性\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract &#123;\n    // Notice, internally we store `Vec&lt;u8>` \n    pub data: Vec&lt;u8>,\n&#125;\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new(data: Base64VecU8) -> Self &#123;\n        Self &#123;\n            data: data.into(),\n        &#125;\n    &#125;\n    pub fn get_data(self) -> Base64VecU8 &#123;\n        self.data.into()\n    &#125;\n&#125;\n","slug":"NEAR SDK - 合约接口","date":"2022-03-11T08:48:13.455Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"},{"id":"816461eb926cfc8059f79248c7c4915a","title":"NEAR SDK Promise","content":"介绍合约能够通过 Promise 异步的发送交易.就像其他编程语言中的Promise 一样,它可以让代码在未来执行.”在未来”意味着交易将在下一个区块(或附近)执行,而不会在初始调用的区块执行.你可以使用 Promise实现任何跨合约调用链.它介于之前所说的高级调用和低级调用之间.查阅上面完整的 Promise 文档以获得更多细节当然,在很少的情况下,Promise 拥有特殊的能力,因为这些情况都不需要函数调用\n\n发送 NEAR 代币\n创建账户\n部署合约\n\n\n\n\n\n\n\n提示\n为什么要等待\n为什么不让交易是同步进行的.在同样的区块完成方法调用?为什么 NEAR 需要 Promise 来发送代币,创建账户和部署合约?他们需要在单独的块中进行调度,因为发送者和接收者可能位于不同的分片中,跨分片通信发生在多个块之间,通过 收据(receipts),你可以将收据理解为 NEAR 的内部交易.你能在 NEAR Explorer 中看到收据是怎么从一个块传输到另一个块中.\n\n\n发送$NEAR你可能有很多原因想要从合约发送代币:\n\n合约使用了类似存储标准的协议,需要再用户注销时返还资金\n用户支付 token 给合约,然后合约稍后支付费用给维护人员,重新分配给用户或者通过用户投票的结果支付给其他人\n更多…\n\n区块链给了我们可编程的货币,智能合约支付货币是这种能力的核心NEAR 让这变的简单,如果你想要从合约中转移代币,下面是你需要做的全部:\nlet amount: u128 = 1_000_000_000_000_000_000_000_000; // 1 $NEAR as yoctoNEAR\nlet account_id: AccountId = \"example.near\".parse().unwrap();\n\nPromise::new(account_id).transfer(amount);\n\n\n\n\n\n\n提示\n本文档描述的 AccountId 行为是 neaer-sdk-rs v4 的特性.这个功能在 v3 中依然可以使用,但如果你想使用更干净的 v4 语法,编写你的Cargo.toml\n[dependencies]\nnear-sdk = \"4.0.0-pre.2\"\n\n\n完整的合约上下文像下面这样\nuse near_sdk::&#123;json_types::U128, near_bindgen, AccountId, Promise&#125;;\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn pay(amount: U128, to: AccountId) -> Promise &#123;\n        Promise::new(to).transfer(amount.0)\n    &#125;\n&#125;\n其中大部分是你已经熟悉的样板.像 imports,设置 near_bindgen,borsh.下面是一些与转账有关的有趣细节:\n\n大写的 U 的 U128,这里的 pay 方法定义了接受 JSON 作为输入,但是 JSON 数字不能超过 2^53,也就是 9 后面只跟了 15 个 0,因为传输时使用的数量是以 yoctoNEAR 为单位,似乎需要比 2^53 大的多的数字  当方法接受 U128 位输入时,这意味着调用者需要将数字转化成 string.near-sdk-rs 将 string 转化为 U128,它是 Rust 原生的 u128 的包装类.底层的 u128 可以通过.0 来使用.例如 transfer(amount.0)\n\nAccountId:这个类型会自动的检查提供的 string 是否很好的匹配了 NEAR 账户 ID 的规则.当不匹配时 panic\n\n返回 Promise:这将允许 NEAR Explorer,near-cli,near-api-js.和其他工具正确的判断整个交易链是否成功.如果你的函数没有返回 Promise.类似于 near-cli 会在你的调用后立刻返回.并且即使 transfer 失败,你的函数调用也会确认为成功.这里有相关的例子.使用 near-cli 来调用函数:\nnear call $CONTRACT pay &#39;&#123;&quot;amount&quot;: &quot;1000000000000000000000000&quot;, &quot;to&quot;: &quot;example.near&quot;&#125;&#39;\n\n\n发送$NEAR你可能有很多原因想要从合约发送代币:\n\n合约使用了类似存储标准的协议,需要再用户注销时返还资金\n用户支付 token 给合约,然后合约稍后支付费用给维护人员,重新分配给用户或者通过用户投票的结果支付给其他人\n更多…\n\n区块链给了我们可编程的货币,智能合约支付货币是这种能力的核心NEAR 让这变的简单,如果你想要从合约中转移代币,你只需要:\nlet amount: u128 = 1_000_000_000_000_000_000_000_000; // 1 $NEAR as yoctoNEAR\nlet account_id: AccountId = \"example.near\".parse().unwrap();\n\nPromise::new(account_id).transfer(amount);\n在一个完整的合约和函数上下文中,你可以这样发送$NEAR\nuse near_sdk::&#123;json_types::U128, near_bindgen, AccountId, Promise&#125;;\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn pay(amount: U128, to: AccountId) -> Promise &#123;\n        Promise::new(to).transfer(amount.0)\n    &#125;\n&#125;\n例子中的大部分内容你应该已经很熟悉了.比如near_bindgen,borsh,下面是一些与$NEAR的发送有关的细节:\n\n大写的 U 的 U128,这里的 pay 方法定义了接受 JSON 作为输入,但是 JSON 数字不能超过 2^53,也就是 9 后面跟15 个 0,因为传输时使用的数量是以 yoctoNEAR 为单位,我们似乎需要比 2^53 大的多的数字  当方法接受 U128 位输入时,这意味着调用者需要将数字转化成 string.near-sdk-rs 将 string 转化为 U128,它是 Rust 原生的 u128 的包装类.底层的 u128 可以通过.0 来使用.例如 transfer(amount.0)\nAccountId:这个类型会自动的检查提供的 string 是否很好的匹配了 NEAR 账户 ID 的规则.当不匹配时 panic\n返回 Promise:这将允许 NEAR Explorer,near-cli,near-api-js.和其他工具正确的判断整个交易链是否成功.如果你的函数没有返回 Promise.near-cli这样的工具 会在你的调用后立刻返回.并且即使 transfer 失败,你的函数调用也会确认为成功.你能看到相关例子在这里\n\n使用 near-cli 来调用函数:\nnear call $CONTRACT pay &#39;&#123;&quot;amount&quot;: &quot;1000000000000000000000000&quot;, &quot;to&quot;: &quot;example.near&quot;&#125;&#39;\n创建账户你可能会有很多原因需要从合约中创建账户.一个例子;你想要用户渐进式的参与,在一开始时隐藏 NEAR 的概念,然后自动为他们创建账户(可能是你的账户的子账户,类似于 user123.some-cool-game.near).因为没有余额的账户几乎不能使用,你可能想要将其与上一页中的代币转移结合使用.你需要给定这个账户一个访问秘钥.就像下面做的这样\nPromise::new(\"subaccount.example.near\".parse().unwrap())\n    .create_account()\n    .add_full_access_key(env::signer_account_pk())\n    .transfer(250_000_000_000_000_000_000_000); // 2.5e23yN, 0.25N\n完整的合约上下文如下:\nuse near_sdk::&#123;env, near_bindgen, AccountId, Balance, Promise&#125;;\n\nconst INITIAL_BALANCE: Balance = 250_000_000_000_000_000_000_000; // 2.5e23yN, 0.25N\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[private]\n    pub fn create_subaccount(prefix: AccountId) -> Promise &#123;\n        let subaccount_id = AccountId::new_unchecked(\n          format!(\"&#123;&#125;.&#123;&#125;\", prefix, env::current_account_id())\n        );\n        Promise::new(subaccount_id)\n            .create_account()\n            .add_full_access_key(env::signer_account_pk())\n            .transfer(INITIAL_BALANCE)\n    &#125;\n&#125;\n需要注意的事:\n\nadd_full_access_key - 该示例使用了进行方法调用并签署了原始交易的人或app的公钥(singner_account_pk),你也可以使用add_access_key来添加Function Call访问键,该访问键允许用户调用预先定义好的一组合约方法.\n#[private] - 如果你有一个方法将会使用你的合约存款.你可能希望以某种方式保护它不被攻击.这里例子用了一个过于简单的方法—标注#[private]宏\nINITTIAL_BALANCE使用near-sdk-rs中的Balance类型.现在它简单的等价于u128,但它将来可能会扩展出额外的方法,就像最近对Gas类型做的那样类型做的那样\n\n部署合约出于一下几种原因,你可能希望你的智能合约能部署后续的智能合约代码:\n\n该合约使用工厂模式,在这个模式中,父合约创建很多子合约(Mintbase使用这种模式为任何想要创建NFT商店的人创建一个NFT商店,彩虹桥也使用这种模式为每个桥接代币创建特定的代币合约)\n合约等待投票通过后更新其自身的代码\n你可以实现一个”合约用户化”系统为每个用户创建特定应用的子账户并且为他们部署同样的合约.因为NEAR存储费的原因,这样的系统是非常昂贵的,但在未来可能会进行优化.如果优化实现了,那么这种”应用分片设计”可能会有更好的伸缩性和以用户为中心的合约标准和应用机制.这种范式的早期实现被称为Meta NEAR\n\n如果你的目标是像Mintbase或彩虹桥一样需要在主合约中部署子合约账户.你还需要创建账户.所以,你需要合并前面提高的概念.下面是你需要的:\nconst CODE: &amp;[u8] = include_bytes!(\"./path/to/compiled.wasm\");\n\nPromise::new(\"subaccount.example.near\".parse().unwrap())\n    .create_account()\n    .add_full_access_key(env::signer_account_pk())\n    .transfer(3_000_000_000_000_000_000_000_000) // 3e24yN, 3N\n    .deploy_contract(CODE.to_vec())\n下面是完整的合约的可能的样子,使用了一种天真的方式来传递code而不是使用include_bytes!硬编码它\nuse near_sdk::&#123;env, near_bindgen, AccountId, Balance, Promise&#125;;\n\nconst INITIAL_BALANCE: Balance = 3_000_000_000_000_000_000_000_000; // 3e24yN, 3N\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[private]\n    pub fn create_child_contract(prefix: AccountId, code: Vec&lt;u8>) -> Promise &#123;\n        let subaccount_id = AccountId::new_unchecked(\n          format!(\"&#123;&#125;.&#123;&#125;\", prefix, env::current_account_id())\n        );\n        Promise::new(subaccount_id)\n            .create_account()\n            .add_full_access_key(env::signer_account_pk())\n            .transfer(INITIAL_BALANCE)\n            .deploy_contract(code)\n    &#125;\n&#125;\n为什么这是一种天真的方法?因为4MB的交易大小限制.(上面的函数将对整个合约进行反序列化和堆分配).在许多情况下,include_bytes!方法是可取的.如果确实需要附加已编译的WASM作为参数,可以参考Sputnik DAO v2使用的方法\n","slug":"NEAR SDK - Promise","date":"2022-03-11T04:02:42.641Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"}]