[{"id":"9520473b9d226eac24e0870f8d1ab299","title":"NEAR SDK - 回调函数","content":"与工作量证明区块链不同,NEAR 协议是分片的,权益证明的区块链网络,当使用原生Rust(编译成 WASM)与智能合约交互时,跨合约调用是异步的.回调用来获取跨合约调用的结果或者用来获取跨合约调用是成功还是失败.\n这里有两种进行跨合约调用的技术:高级调用和低级调用.本文档将聚焦于高级调用.Rust SDK 库中有两个示例演示了这些内容.如上面的连接所示.注意这些例子使用跨合约调用他们自身.我们将使用两个示例来演示高级调用.\n计算器示例#[ext_contract(...)]宏可以帮助你创建一个跨合约调用.它将使用一个 Rust Trait 并且转化为一个具有静态方法的模块.每个静态方法都接受 Trait 定义的位置参数,然后是 receiver_id,附带的存款和 gas 数量然后返回一个 Promiss\n例如,让我们定义一个计算器合约 Trait\n#[ext_contract(ext_calculator)]\ntrait Calculator &#123;\n    fn mult(&amp;self, a: U64, b: U64) -> U128;\n\n    fn sum(&amp;self, a: U128, b: U128) -> U128;\n&#125;\n\n等价于:\nmod ext_calculator &#123;\n    pub fn mult(a: U64, b: U64, receiver_id: &amp;AccountId, deposit: Balance, gas: Gas) -> Promise &#123;\n        Promise::new(receiver_id.clone())\n            .function_call(\n                b\"mult\",\n                json!(&#123; \"a\": a, \"b\": b &#125;).to_string().as_bytes(),\n                deposit,\n                gas,\n            )\n    &#125;\n\n    pub fn sum(a: U128, b: U128, receiver_id: &amp;AccountId, deposit: Balance, gas: Gas) -> Promise &#123;\n        // ...\n    &#125;\n&#125;\n\n我们假设计算器合约已经部署在了账户calc.near上,我们接下来可以这么做:\nconst CALCULATOR_ACCOUNT_ID: &amp;str = \"calc.near\";\nconst NO_DEPOSIT: Balance = 0;\nconst BASE_GAS: Gas = 5_000_000_000_000;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn sum_a_b(&amp;mut self, a: U128, b: U128) -> Promise &#123;\n        let calculator_account_id: AccountId = CALCULATOR_ACCOUNT_ID.to_string();\n        ext_calculator::sum(a, b, &amp;calculator_account_id, NO_DEPOSIT, BASE_GAS)\n    &#125;\n&#125;\n\n\n\n白名单示例接下来我来看白名单智能合约的一个简单的跨合约调用,返回给定的用户是否在白名单里.跨合约调用的常见模式是首先调用外部智能合约的方法.然后使用.then 语法来标记一个回调.最后在 promiss 中取回数据或状态.回调将在同样的环境中调用只能合约.回调函数使用了特殊的宏#[privette].我们将在下面看到这个模式下面的示例演示两个使用高级调用进行跨和调用的方式.当编写高级跨合约调用时,被调用的智能合约接口被设置为特殊的 trait .并且(通常的)由当前合约进行这个调用(在那里存在回调逻辑).按照惯例,第二个 trait 被称为 ext_self.\n下面我们会看到一个简单的使用了两个 trait的示例:\n#[ext_contract(ext_self)]\npub trait ExtSelf &#123;\n    fn callback_promise_result() -> bool;\n    fn callback_arg_macro(#[callback] val: bool) -> bool;\n&#125;\n\n#[ext_contract(ext_whitelist)]\npub trait ExtWhitelist &#123;\n    fn is_whitelisted(staking_pool_account_id: AccountId) -> bool;\n&#125;\n\n在创建这些 trait 后,我们展示两个简单的函数,他们将进行白名单合约的跨合约调用.询问账户 mike.testnet 是否在白名单中.这两个方法都返回 bool 值.首先我们来看看方法,然后让我们来看看回调函数的区别.注意,简单起见,本例中的值是硬编码的.\npub const XCC_GAS: Gas = 20000000000000;\nfn get_whitelist_contract() -> AccountId &#123;\n    \"whitelist.demo.testnet\".to_string()\n&#125;\nfn get_account_to_check() -> AccountId &#123;\n    \"mike.testnet\".to_string()\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn xcc_use_promise_result(&amp;mut self) -> Promise &#123;\n        ext_whitelist::is_whitelisted(get_account_to_check(), &amp;get_whitelist_contract(), 0, XCC_GAS).then(\n            ext_self::callback_promise_result(\n                &amp;env::current_account_id(),\n                0,\n                XCC_GAS,\n            ),\n        )\n    &#125;\n\n    pub fn xcc_use_arg_macro(&amp;mut self) -> Promise &#123;\n        ext_whitelist::is_whitelisted(get_account_to_check(), &amp;get_whitelist_contract(), 0, XCC_GAS).then(\n            ext_self::callback_arg_macro(\n                &amp;env::current_account_id(),\n                0,\n                XCC_GAS,\n            ),\n        )\n    &#125;\n\n从ext_whitelist::is_whitelisted..开始的语法给我们展示了如何使用 trait 来调用方法is_whitelisted.然而,该 trait 只有一个参数,我们却传入了 4 个参数.其中后面 3 个参数将在幕后使用:\n\n目标合约账户(例如:whitelist.demo.testnet)\n附带的 Ⓝ存款,单位为 yocto Ⓝ(1 Ⓝ &#x3D; 1000000000000000000000000 yoctoⓃ.)\ngas 数量\n\n代码片段中的两个方法非常相似,除了他们各自使用了不同的回调 callback_promise_result 和 callback_arg_macro\n#[private]\npub fn callback_promise_result(&amp;mut self) -> bool &#123;\n    assert_eq!(env::promise_results_count(), 1, \"ERR_TOO_MANY_RESULTS\");\n    match env::promise_result(0) &#123;\n        PromiseResult::NotReady => unreachable!(),\n        PromiseResult::Successful(val) => &#123;\n            if let Ok(is_whitelisted) = near_sdk::serde_json::from_slice::&lt;bool>(&amp;val) &#123;\n                is_whitelisted\n            &#125; else &#123;\n                env::panic(b\"ERR_WRONG_VAL_RECEIVED\")\n            &#125;\n        &#125;,\n        PromiseResult::Failed => env::panic(b\"ERR_CALL_FAILED\"),\n    &#125;\n&#125;\n\n#[private]\npub fn callback_arg_macro(&amp;mut self, #[callback] val: bool) -> bool &#123;\n    val\n&#125;\n\n这两个回调展示了如何获得值.第一个方法从 promise result 中获取值,第二个在参数中使用了宏来将值转化为所需的值.请注意,第二种方式没有第一种方式那么容易捕获错误.\n这两种方式最大的不同是参数是如何定义的.\n这就是所有的内容了.理解如何创建一个跨合约调用并且接收返回值是在 NEAR 上开发智能合约非常重要的一部分.\n","slug":"NEAR SDK - 回调函数","date":"2022-03-11T12:11:22.994Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"},{"id":"0d7a924133f95db56db161e3fcf8a116","title":"NEAR SDK - 合约接口","content":"公共方法类型基础实现在#[near_bindgen]宏包裹下的函数可以使用 pub标识符修饰,这样当它编译成WASM字节码以后就可以被外部调用 \n只讲能在外部调用的方法标记成public是很重要的.如果你需要合约自身来调用,你可以标记该方法为公共的但是添加#[private]修饰,这样除了合约自身的调用,任何调用都会导致panic\n基本的用法如下所示:\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn some_method(&amp;mut self) &#123;\n        // .. method logic here\n    &#125;\n&#125;\n\n这将从WASM二进制码中公开some_method,任何人都可以访问它\n\n展开显示生成的代码\n#[cfg(target_arch = \"wasm32\")]\n#[no_mangle]\npub extern \"C\" fn some_method() &#123;\n    near_sdk::env::setup_panic_hook();\n    if near_sdk::env::attached_deposit() != 0 &#123;\n        near_sdk::env::panic(\"Method some_method doesn\\'t accept deposit\".as_bytes());\n    &#125;\n    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();\n    contract.some_method();\n    near_sdk::env::state_write(&amp;contract);\n&#125;\n\n\n\n公开trait实现函数也能够公开自己的trait实现.这有助于在合约中实现共有的接口或标准.下面的代码与pub的基础用法很相似,除了#[near_bindgen]宏只需要附属在trait的实现上,而无需附属与trait本身.\npub trait MyTrait &#123;\n    fn trait_method(&amp;mut self);\n&#125;\n\n#[near_bindgen]\nimpl MyTrait for MyContractStructure &#123;\n    fn trait_method(&amp;mut self) &#123;\n        // .. method logic here\n    &#125;\n&#125;\n\n在这个例子中,生成的代码与前一个例子相同,只是方法名不一样\n\n展开显示生成的代码\n#[cfg(target_arch = \"wasm32\")]\n#[no_mangle]\npub extern \"C\" fn trait_method() &#123;\n    near_sdk::env::setup_panic_hook();\n    if near_sdk::env::attached_deposit() != 0 &#123;\n        near_sdk::env::panic(\"Method trait_method doesn\\'t accept deposit\".as_bytes());\n    &#125;\n    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();\n    contract.trait_method();\n    near_sdk::env::state_write(&amp;contract);\n&#125;\n\n\n\n合约状态可变性合约状态可变性是通过函数参数中的self参数是怎样的来自动处理的.根据使用的是哪一个,#[near_bindgen]宏将生成相应的代码来加载&#x2F;反序列化任何使用self的函数的状态，序列化&#x2F;存储状态只在使用&amp;mut self时使用。\n只读函数以不可变的方式调用合约时,交易结束时不会覆写任何状态.你可以通过使用&amp;self 或者 self 作为参数.他们都将生成同样的代码去加载并反序列化状态到结构体中,然后调用函数.不同的是,self 会将变量的所有权移动进函数中,&amp;self 仅仅将 self 的引用移动进函数中.\n下面是一个例子:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct MyContractStructure &#123;\n    integer: u64,\n    message: String,\n&#125;\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn get_values(self) -> (u64, String) &#123;\n        (self.integer, self.message)\n    &#125;\n    pub fn log_state_string(&amp;self) &#123;\n        near_sdk::env::log(self.message.as_bytes());\n    &#125;\n&#125;\n\n没有适用于所有情况的通用准则,但有一些核心规则需要遵守:\n\nself 如果在函数中移动了 self 的值或者其包含的值时使用 self 作为参数是很有用的,因为这样减少了 copy 和 clone 的操作\n/// View method. More efficient, but can't be reused internally, because it consumes self.\npub fn get_owner_id(self) -> AccountId &#123;\n    self.owner_id\n&#125;\n\n&amp;self当值需要只读的合约状态,或者函数使用了一些方法来获得了可用的所有权时使用&amp;self.如果结构体使用了大量内存,这很有用,可以避免将大量的数据转移进函数作用域中.\n/// View method. Requires cloning the account id.\npub fn get_owner_id(&amp;self) -> AccountId &#123;\n    self.owner_id.clone()\n&#125;\n\n返回派生数据\n有些少见的情况需要我们通过只读的方式来返回从存储中获取并修改的数据.如下面所示:\n/// View method that \"modifies\" state, for code structure or computational\n/// efficiency reasons. Changes state in-memory, but does NOT save the new\n/// state. If called internally by a change method, WILL result in updated\n/// contract state.\npub fn update_stats(&amp;self, account_id: AccountId, score: U64) -> Account &#123;\n    let account = self.accounts.get(&amp;account_id).unwrap_or_else(|| env::panic_str(\"ERR_ACCT_NOT_FOUND\"));\n    account.total += score;\n    account\n&#125;\n\n可变函数可变的函数允许加载存在的状态,然后对它进行修改,最后当方法调用结束后重新将状态写入\n这应该用于任何修改合约状态的交易中.注意,序列化的合约数据存在键 STATE 下持久化存储中.\n一个可变函数的例子:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct MyContractStructure &#123;\n    integer: u64,\n&#125;\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn modify_value(&amp;mut self, new_value: u64) &#123;\n        self.integer = new_value;\n    &#125;\n    pub fn increment_value(&amp;mut self) &#123;\n        self.integer += 1;\n    &#125;\n&#125;\n\n\n\n纯函数这一类函数根本不使用 self,也不需要从存储中读取或者写入合约状态\n使用公共的纯函数的情况很少,但是返回嵌入到合约代码中的数据或执行一些不依赖合约状态的静态共享逻辑时可能很有用\n一个纯函数的例子:\nconst SOME_VALUE: u64 = 8;\n\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn log_message(/* Parameters here */) &#123;\n        near_sdk::log!(\"inside log message\");\n    &#125;\n    pub fn log_u64(value: u64) &#123;\n        near_sdk::log!(\"&#123;&#125;\", value);\n    &#125;\n    pub fn return_static_u64() -> u64 &#123;\n        SOME_VALUE\n    &#125;\n&#125;\n\n\n\n私有方法何时使用回调通常,当合约必须为一个远程交叉合约调用进行回调时,这个回调方法必须只能被合约自身调用.这能避免有人直接调用它而搞乱合约状态.更常见的模式是使用断言来验证直接调用者(predecessor account ID)是否是合约自己的账户(current account ID).#[private]宏会简化这个操作,提高代码可读性.\n在near_bindgen宏包裹的代码里使用这个标注,例如:\n#[private]\npub fn my_method(&amp;mut self) &#123;\n    …\n&#125;\n\n上面的代码等价于\npub fn my_method(&amp;mut self ) &#123;\n    if env::current_account_id() != env::predecessor_account_id() &#123;\n        near_sdk::env::panic(\"Method method is private\".as_bytes());\n    &#125;\n...\n&#125;\n\n现在通过这个标注,只有合约账户本身可以调用这个方法,可以直接调用也可以通过哦Promise\n编写内部方法不是所有的方法都需要暴露为公开的,为 helper 或 uility 函数编写私有的方法也许更加有益.下面是三种编写内部方法的途径\n\n使用 fn 替换 pub fn\nfn helper_method(a: u8, b: u8) &#123;\n  …\n&#125;\n\n使用pub(crate) fn.这将有助于在不同的模块中使用内部函数\n// Function that can be called in another Rust file\npub(crate) fn get_first_name(account: Account) &#123;\n  …\n&#125;\n\n分散的impl块\n另外一种不暴露方法的方式是有一个单独的impl Contract部分,并且这部分不使用#[near_bindgen]宏\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn increment(&amp;mut self) &#123;\n        self.internal_increment();\n    &#125;\n&#125;\nimpl Contract &#123;\n    /// This methods is still not exported.\n    pub fn internal_increment(&amp;mut self) &#123;\n        self.counter += 1;\n    &#125;\n&#125;\n\n可支付方法我们可以允许方法在函数调用时接受代币转移.这样做是为了让合约能够使用的时候定义其需要的代币费用.默认的方法是不可支付的,如果调用时尝试转移代币会导致 panic.这样做是因为安全原因,以免有人在函数调用时意外地转移代币\n使用#[payable]标注来申明方法是可支付的.\n#[payable]\npub fn my_method(&amp;mut self) &#123;\n...\n&#125;\n\n这将允许通过调用my_method方法来转移资产给合约\n例子:\n#[near_bindgen]\nimpl Contract &#123;\n    #[payable]\n    pub fn take_my_money(&amp;mut self) &#123;\n        env::log_str(\"Thanks!\");\n    &#125;\n    pub fn do_not_take_my_money(&amp;mut self) &#123;\n        env::log_str(\"Thanks!\");\n    &#125;\n&#125;\n\n等价于:\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn take_my_money(&amp;mut self) &#123;\n        env::log_str(\"Thanks!\");\n    &#125;\n    pub fn do_not_take_my_money(&amp;mut self) &#123;\n        if near_sdk::env::attached_deposit() != 0 &#123;\n            near_sdk::env::panic(b\"Method do_not_take_my_money doesn't accept deposit\");\n        &#125;\n        env::log_str(\"Thanks!\");\n    &#125;\n&#125;\n\n\n\n序列化协议SDK 中的序列化规则定义了结构体数据如何转化成字节,当需要传输数据到合约方法中或存储数据到状态中时.对于方法参数,SDK 接受JSON(默认)和 Borsh,对于存储数据在链上,使用 Borsh.\nJSON 和 Borsh 的特点如下:JSON:\n\n人类可读\n自解释样式(不需要知道底层类型)\n与 JavaScript 的易互操作性\n低效率的(反)序列化Borsh\n紧凑的二进制格式可以高效率的进行数据的序列化和反序列化\n需要知道数据格式或者有一个模板来反序列化数据\n严格规范的二进制表示\n在大多数情况下,快速并且开销更小通常来说,JSON 用于合约调用和交叉合约调用以实现更好的适用性,Borsh 被用于优化合约中更小的参数序列化和更少的反序列化计算开销,以减少 gas 使用.\n\n重载默认的序列化协议结果和参数的序列化可以分开选择.但是所有的参数必须使用同样的样式(不能使用 borsh 序列化一部分参数,另外的参数使用 JSON 序列化).下面的例子是同时使用 borsh 来序列化返回值和参数\n#[result_serializer(borsh)]\npub fn sum_borsh(#[serializer(borsh)] a: u32, #[serializer(borsh)] b: u32) -> u32 &#123;\n    a + b\n&#125;\n\nJSON 重载为 borsh,```serializer(borsh)```标注将重载参数的序列化协议\n下面是在单元测试中使用 Borsh 序列化,并且使用 base64 编码的方法\n\n&#96;&#96;&#96;rust\n&#x2F;&#x2F;&#x2F; This test is simply a helper to print out the base64 value.\n#[test]\nfn borsh_simple() &#123;\n    let status_message &#x3D; &quot;Aloha honua!&quot;.to_string();\n    let borsh_input &#x3D; SetMessageInput &#123;\n        msg: status_message.clone()\n    &#125;;\n\n    let borsh_serialized: Vec&lt;u8&gt; &#x3D; borsh_input.try_to_vec().unwrap();\n    let base64_encoded &#x3D; near_primitives::serialize::to_base64(borsh_serialized.as_slice());\n    println!(&quot;Using NEAR CLI, this is the base64-encoded value to use: &#123;:?&#125;&quot;, base64_encoded);\n&#125;\n\n下面展示了在 CLI 中使用这个值的代码片段.注意,该方法没有返回值,所以不需要使用#[result_serializer(borsh)]来标注返回值\npub fn set_status_borsh(&amp;mut self, #[serializer(borsh)] message: SetMessageInput) &#123;\n    self.records.insert(&amp;env::signer_account_id(), &amp;String::from(message.msg));\n&#125;\n\n他们使用了这个简单的结构体:\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct SetMessageInput &#123;\n    // Note that the key does not have to be \"message\" like the argument name.\n    msg: String,\n&#125;\n\n在NEAR CLI中调用方法如下:\nnear call rust-status-message.demo.testnet set_status_borsh --base64 &#39;DAAAAEFsb2hhIGhvbnVhIQ&#x3D;&#x3D;&#39; --accountId demo.testnet\n\n\n\nJSON 包装类型为了帮助将某些类型序列化为 JSON,这些类型有意想不到或低效的默认格式,在 near_sdk::json_types 里有一些包装器类型可以使用因为 JavaScript 只支持整数类型的值到 2^53-1,如果反序列化 JSON 整型超过了这个范围,你将丢失精度.为了抵消这种影响,你可以使用 I64,U64,I128 和 U128 类型来代替这些参数或结果的本地类型,将值序列化为字符串.默认情况下,所有整数类型都将序列化为 JSON 中的整型你能使用 std::convert::Into 来将 U64 转化为 u64\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n        let a: u64 = a.into();\n        let b: u64 = b.into();\n        let product = u128::from(a) * u128::from(b);\n        product.into()\n    &#125;\n&#125;\n\n你也可以使用.0来访问内部值\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n        //let a: u64 = a.into();\n        let a = a.0;\n        //let b: u64 = b.into();\n        let b = b.0;\n        let product = u128::from(a) * u128::from(b);\n        product.into()\n    &#125;\n&#125;\n\n同时,你还可以使用U64(...)和U128(...)来转化u64和u128\n#[near_bindgen]\n impl Contract &#123;\n     pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n         let a = a.0;\n         let b = b.0;\n         let product = u128::from(a) * u128::from(b);\n         //product.into()\n         U128(product)\n     &#125;\n &#125;\n\n结合起来使用:\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n        U128(u128::from(a.0) * u128::from(b.0))\n    &#125;\n&#125;\n\n尽管JSON 包装类型只包含在 SDK 中,但是任何类型都可以使用,只要它各自实现了 serder 序列化和反序列化.所有这些类型都覆写了 JSON 格式并且与内部类型具有一致的 borsh 序列化和反序列特性\nBase64VecU8另外一个覆写默认序列化的例子是 Vec,它用来表示 Rust 中的字节.默认实现下,它将序列化为整型数组,这是不紧凑而且很难使用的.有一个包装类型Base64VecU8,它能序列化和反序列化 Base64 字符串再 JSON 的序列化中获得更多的紧凑性\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract &#123;\n    // Notice, internally we store `Vec&lt;u8>` \n    pub data: Vec&lt;u8>,\n&#125;\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new(data: Base64VecU8) -> Self &#123;\n        Self &#123;\n            data: data.into(),\n        &#125;\n    &#125;\n    pub fn get_data(self) -> Base64VecU8 &#123;\n        self.data.into()\n    &#125;\n&#125;\n\n","slug":"NEAR SDK - 合约接口","date":"2022-03-11T08:48:13.455Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"},{"id":"fd582b9cf79ff995a8e18c9302c7c404","title":"NEAR-SDK Promise","content":"介绍合约能够通过 Promise 异步的发送交易.就像其他编程语言中的Promise 一样,它可以让代码在未来执行.”在未来”意味着交易将在下一个区块(或附近)执行,而不会在初始调用的区块执行.你可以使用 Promise实现任何跨合约调用链.它介于之前所说的高级调用和低级调用之间.查阅上面完整的 Promise 文档以获得更多细节当然,在很少的情况下,Promise 拥有特殊的能力,因为这些情况都不需要函数调用\n\n发送 NEAR 代币\n创建账户\n部署合约\n\n\n\n\n\n\n\n提示\n为什么要等待\n为什么不让交易是同步进行的.在同样的区块完成方法调用?为什么 NEAR 需要 Promise 来发送代币,创建账户和部署合约?他们需要在单独的块中进行调度,因为发送者和接收者可能位于不同的分片中,跨分片通信发生在多个块之间,通过 收据(receipts),你可以将收据理解为 NEAR 的内部交易.你能在 NEAR Explorer 中看到收据是怎么从一个块传输到另一个块中.\n\n\n发送$NEAR你可能有很多原因想要从合约发送代币:\n\n合约使用了类似存储标准的协议,需要再用户注销时返还资金\n用户支付 token 给合约,然后合约稍后支付费用给维护人员,重新分配给用户或者通过用户投票的结果支付给其他人\n更多…\n\n区块链给了我们可编程的货币,智能合约支付货币是这种能力的核心NEAR 让这变的简单,如果你想要从合约中转移代币,下面是你需要做的全部:\nlet amount: u128 = 1_000_000_000_000_000_000_000_000; // 1 $NEAR as yoctoNEAR\nlet account_id: AccountId = \"example.near\".parse().unwrap();\n\nPromise::new(account_id).transfer(amount);\n\n\n\n\n\n\n\n提示\n本文档描述的 AccountId 行为是 neaer-sdk-rs v4 的特性.这个功能在 v3 中依然可以使用,但如果你想使用更干净的 v4 语法,编写你的Cargo.toml\n[dependencies]\nnear-sdk = \"4.0.0-pre.2\"\n\n\n\n完整的合约上下文像下面这样\nuse near_sdk::&#123;json_types::U128, near_bindgen, AccountId, Promise&#125;;\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn pay(amount: U128, to: AccountId) -> Promise &#123;\n        Promise::new(to).transfer(amount.0)\n    &#125;\n&#125;\n\n\n\n其中大部分是你已经熟悉的样板.像 imports,设置 near_bindgen,borsh.下面是一些与转账有关的有趣细节:\n\n大写的 U 的 U128,这里的 pay 方法定义了接受 JSON 作为输入,但是 JSON 数字不能超过 2^53,也就是 9 后面只跟了 15 个 0,因为传输时使用的数量是以 yoctoNEAR 为单位,似乎需要比 2^53 大的多的数字  当方法接受 U128 位输入时,这意味着调用者需要将数字转化成 string.near-sdk-rs 将 string 转化为 U128,它是 Rust 原生的 u128 的包装类.底层的 u128 可以通过.0 来使用.例如 transfer(amount.0)\n\nAccountId:这个类型会自动的检查提供的 string 是否很好的匹配了 NEAR 账户 ID 的规则.当不匹配时 panic\n\n返回 Promise:这将允许 NEAR Explorer,near-cli,near-api-js.和其他工具正确的判断整个交易链是否成功.如果你的函数没有返回 Promise.类似于 near-cli 会在你的调用后立刻返回.并且即使 transfer 失败,你的函数调用也会确认为成功.这里有相关的例子.使用 near-cli 来调用函数:\nnear call $CONTRACT pay &#39;&#123;&quot;amount&quot;: &quot;1000000000000000000000000&quot;, &quot;to&quot;: &quot;example.near&quot;&#125;&#39;\n\n发送$NEAR你可能有很多原因想要从合约发送代币:\n\n合约使用了类似存储标准的协议,需要再用户注销时返还资金\n用户支付 token 给合约,然后合约稍后支付费用给维护人员,重新分配给用户或者通过用户投票的结果支付给其他人\n更多…\n\n区块链给了我们可编程的货币,智能合约支付货币是这种能力的核心NEAR 让这变的简单,如果你想要从合约中转移代币,你只需要:\nlet amount: u128 = 1_000_000_000_000_000_000_000_000; // 1 $NEAR as yoctoNEAR\nlet account_id: AccountId = \"example.near\".parse().unwrap();\n\nPromise::new(account_id).transfer(amount);\n\n在一个完整的合约和函数上下文中,你可以这样发送$NEAR\nuse near_sdk::&#123;json_types::U128, near_bindgen, AccountId, Promise&#125;;\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn pay(amount: U128, to: AccountId) -> Promise &#123;\n        Promise::new(to).transfer(amount.0)\n    &#125;\n&#125;\n\n例子中的大部分内容你应该已经很熟悉了.比如near_bindgen,borsh,下面是一些与$NEAR的发送有关的细节:\n\n大写的 U 的 U128,这里的 pay 方法定义了接受 JSON 作为输入,但是 JSON 数字不能超过 2^53,也就是 9 后面跟15 个 0,因为传输时使用的数量是以 yoctoNEAR 为单位,我们似乎需要比 2^53 大的多的数字  当方法接受 U128 位输入时,这意味着调用者需要将数字转化成 string.near-sdk-rs 将 string 转化为 U128,它是 Rust 原生的 u128 的包装类.底层的 u128 可以通过.0 来使用.例如 transfer(amount.0)\nAccountId:这个类型会自动的检查提供的 string 是否很好的匹配了 NEAR 账户 ID 的规则.当不匹配时 panic\n返回 Promise:这将允许 NEAR Explorer,near-cli,near-api-js.和其他工具正确的判断整个交易链是否成功.如果你的函数没有返回 Promise.near-cli这样的工具 会在你的调用后立刻返回.并且即使 transfer 失败,你的函数调用也会确认为成功.你能看到相关例子在这里\n\n使用 near-cli 来调用函数:\nnear call $CONTRACT pay &#39;&#123;&quot;amount&quot;: &quot;1000000000000000000000000&quot;, &quot;to&quot;: &quot;example.near&quot;&#125;&#39;\n\n\n\n\n\n创建账户你可能会有很多原因需要从合约中创建账户.一个例子;你想要用户渐进式的参与,在一开始时隐藏 NEAR 的概念,然后自动为他们创建账户(可能是你的账户的子账户,类似于 user123.some-cool-game.near).因为没有余额的账户几乎不能使用,你可能想要将其与上一页中的代币转移结合使用.你需要给定这个账户一个访问秘钥.就像下面做的这样\nPromise::new(\"subaccount.example.near\".parse().unwrap())\n    .create_account()\n    .add_full_access_key(env::signer_account_pk())\n    .transfer(250_000_000_000_000_000_000_000); // 2.5e23yN, 0.25N\n\n完整的合约上下文如下:\nuse near_sdk::&#123;env, near_bindgen, AccountId, Balance, Promise&#125;;\n\nconst INITIAL_BALANCE: Balance = 250_000_000_000_000_000_000_000; // 2.5e23yN, 0.25N\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[private]\n    pub fn create_subaccount(prefix: AccountId) -> Promise &#123;\n        let subaccount_id = AccountId::new_unchecked(\n          format!(\"&#123;&#125;.&#123;&#125;\", prefix, env::current_account_id())\n        );\n        Promise::new(subaccount_id)\n            .create_account()\n            .add_full_access_key(env::signer_account_pk())\n            .transfer(INITIAL_BALANCE)\n    &#125;\n&#125;\n\n需要注意的事:\n\nadd_full_access_key - 该示例使用了进行方法调用并签署了原始交易的人或app的公钥(singner_account_pk),你也可以使用add_access_key来添加Function Call访问键,该访问键允许用户调用预先定义好的一组合约方法.\n#[private] - 如果你有一个方法将会使用你的合约存款.你可能希望以某种方式保护它不被攻击.这里例子用了一个过于简单的方法–标注#[private]宏\nINITTIAL_BALANCE使用near-sdk-rs中的Balance类型.现在它简单的等价于u128,但它将来可能会扩展出额外的方法,就像最近对Gas类型做的那样类型做的那样\n\n部署合约出于一下几种原因,你可能希望你的智能合约能部署后续的智能合约代码:\n\n该合约使用工厂模式,在这个模式中,父合约创建很多子合约(Mintbase使用这种模式为任何想要创建NFT商店的人创建一个NFT商店,彩虹桥也使用这种模式为每个桥接代币创建特定的代币合约)\n合约等待投票通过后更新其自身的代码\n你可以实现一个”合约用户化”系统为每个用户创建特定应用的子账户并且为他们部署同样的合约\n\n","slug":"NEAR SDK - Promise","date":"2022-03-10T11:08:00.000Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"}]