[{"id":"5e99360b3a18af11a239b4863047980f","title":"NEAR SDK - 合约结构","content":"near_bindgen\n例如,下面是一个简单的计数合约,&#96;&#96;&#96;#[near_bindgen]&#96;&#96;&#96;宏被这样使用:\n\n&#96;&#96;&#96;rust\nuse near_sdk::borsh::&#123;self, BorshDeserialize, BorshSerialize&#125;;\nuse near_sdk::near_bindgen;\n\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct Counter &#123;\n    value: u64,\n&#125;\n\n#[near_bindgen]\nimpl Counter &#123;\n    pub fn increment(&amp;mut self) &#123;\n        self.value +&#x3D; 1;\n    &#125;\n\n    pub fn get_count(&amp;self) -&gt; u64 &#123;\n        self.value\n    &#125;\n&#125;\n\n\n\n在上面的例子中,Counter结构体相当于智能合约的状态,可以包含任何实现了BorshDeserialize和BorshSerialize的成员,甚至是集合,我们将在后面讨论它.当方法被调用时,合约状态将被加载并反序列化,因此,保证加载的数据尽可能少是很重要的.\n\n* 任何&#96;&#96;&#96;pub&#96;&#96;&#96;方法都能在外部被账户&#x2F;合约调用.\n  * 更多的信息,查看[公共方法类型](https:&#x2F;&#x2F;www.near-sdk.io&#x2F;contract-interface&#x2F;public-methods)\n* &#96;&#96;&#96;self&#96;&#96;&#96;有多种用法来控制合约的可变性\n  * 使用&#96;&#96;&#96;&amp;self&#96;&#96;&#96;和&#96;&#96;&#96;self&#96;&#96;&#96;的方法将是只读的.并且不会写入和更新存储中的状态\n  * 使用&#96;&#96;&#96;&amp;mut self&#96;&#96;&#96;的方法将允许改变状态,状态将在合约调用结束后写入存储\n* 如果公开的函数的参数不包括&#96;&#96;&#96;self&#96;&#96;&#96;.那么它的调用可以省略状态读写\n  * 这对于一些静态功能或返回嵌入在合约代码中的数据可能很有用.\n* 如果函数有返回值,它将被序列化并且通过&#96;&#96;&#96;env::value_return&#96;&#96;&#96;作为结果附加\n\n#### 初始化方法\n\n默认的,合约的&#96;&#96;&#96;Default::default()&#96;&#96;&#96;实现会用于合约的初始化.也可以有一个自定义的初始化函数,它接受参数并执行自定义逻辑.初始化韩式放在&#96;&#96;&#96;#[init]&#96;&#96;&#96;标注下\n\n&#96;&#96;&#96;rust\n#[near_bindgen]\nimpl Counter &#123;\n    #[init]\n    pub fn new(value: u64) -&gt; Self &#123;\n        log!(&quot;Custom counter initialization!&quot;);\n        Self &#123; value &#125;\n    &#125;\n&#125;\n\n所有合约都预先实现了Default,如果你想要禁止使用default实现,PanicOnDefault宏可以做到这一点:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Counter &#123;\n    // ...\n&#125;\n\n\n\n可支付方法方法可以标注为#[payable]以允许方法在调用时进行通证的转移.更多的信息,查看可支付方法\n下面的例子使用#[payable]注释宣告了函数是可支付的:\n#[payable]\npub fn my_method(&amp;mut self) &#123;\n...\n&#125;\n\n\n\n私有方法有些方法需要公开以允许合约通过Promise调用自身的方法,但是又不允许其他任何合约&#x2F;账户调用它.为此,使用#[private]注释方法以使得外部合约&#x2F;账户的调用会导致panic.更多的信息,查看私有方法\n该注释通过以下的方式应用\n#[private]\npub fn my_method(&amp;mut self) &#123;\n...\n&#125;\n\n\n\n集合当决定应用程序数据使用的数据结构时,重要的是尽可能减少读取和写入存储的数据量,以及反序列化和序列化的数据量,以尽可能的减少交易成本.理解智能合约中的不同数据结构的侧重点非常重要,因为随着程序的扩展,它将成为瓶颈,并且将状态迁移至新的数据结构会付出代价.\n\n&gt; &#96;&#96;&#96;near_sdk::collections&#96;&#96;&#96;将迁移至&#96;&#96;&#96;near_sdk::store&#96;&#96;&#96;并更新了API.如果你想要访问这些更新的结构体实现,启用&#96;&#96;&#96;unstable&#96;&#96;&#96;特性在&#96;&#96;&#96;near-sdk&#96;&#96;&#96;中.\n\n在使用&#96;&#96;&#96;std::collections&#96;&#96;&#96;时需要牢记,每次状态被加载时,数据结构中的所有数据都将被读取和反序列化.这将为使用任何非少量的数据带来巨大的开销.所以为了最小化gas使用量,大多数情况下,应该是用SDK中的集合.\n\nSDK中存在如下数据结构:\n\n| SDK集合                 | &#96;&#96;&#96;std&#96;&#96;&#96;等价物     | 描述                                                         |\n| ----------------------- | ------------------- | ------------------------------------------------------------ |\n| &#96;&#96;&#96;LazyOption&lt;T&gt;&#96;&#96;&#96;     | &#96;&#96;&#96;Option&lt;T&gt;&#96;&#96;&#96;     | 存储中可选的值.该类型只会在交互时才从存储中读取.当值存在于存储中时,会以 Some&lt;T&gt;的类型提供,当不存在时返回 None |\n| &#96;&#96;&#96;Vecttor&lt;T&gt;&#96;&#96;&#96;        | &#96;&#96;&#96;Vec&lt;T&gt;&#96;&#96;&#96;        | 可增长的数组类型.这些值在内存中分片,可以被迭代,并且索引值是可以动态调整大小的 |\n| &#96;&#96;&#96;LookupMap&lt;K,V&gt;&#96;&#96;&#96;    | &#96;&#96;&#96;HashMap&lt;K,V&gt;&#96;&#96;&#96;  | 该结构相当于一个合约可用的 map的廋包装体.该结构不包含任何关于 map 中元素的元数据,因此不可迭代 |\n| &#96;&#96;&#96;unorderedMap&lt;K,V&gt;&#96;&#96;&#96; | &#96;&#96;&#96;HashMap&lt;K,V&gt;&#96;&#96;&#96;  | 与 LookupMap 类似,除了该结构保存能让内部元素进行迭代的额外数据 |\n| &#96;&#96;&#96;TreeMap&lt;K,V&gt;&#96;&#96;&#96;      | &#96;&#96;&#96;BTreeMap&lt;K,V&gt;&#96;&#96;&#96; | UnorderedMap 的有序等价物.当需要一致的顺序或者访问最小,最大键时,应该使用这个结构.底层实现基于 AVL tree |\n| &#96;&#96;&#96;LookupSet&lt;T&gt;&#96;&#96;&#96;      | &#96;&#96;&#96;HashSet&lt;T&gt;&#96;&#96;&#96;    | 类似于 LookupMap 的 Set,但不存储和值.只被用来检查特定值是否存在.该结构不能迭代并且只能用来查找 |\n| &#96;&#96;&#96;UnorderedSet&lt;T&gt;&#96;&#96;&#96;   | &#96;&#96;&#96;HashSet&lt;T&gt;&#96;&#96;&#96;    | LookupMap 的可迭代等价物,它存储了一些关于 Set 内部元素的额外信息 |\n\n\n\n#### 内存中的 &#96;&#96;&#96;HashMap&#96;&#96;&#96; vs 持久化的 &#96;&#96;&#96;UnorderedMap&#96;&#96;&#96;\n\n* &#96;&#96;&#96;HashMap&#96;&#96;&#96; 保持所有数据在内存中,为了访问它,合约需要反序列化整个 Map\n* &#96;&#96;&#96;UnorderedMap&#96;&#96;&#96; 保持所有数据在存储中,访问任何元素只需要反序列化该元素.\n\n在什么时候使用 &#96;&#96;&#96;HashMap&#96;&#96;&#96;?\n\n* 需要在一次方法调用中迭代集合中的所有元素\n* 元素数量小或固定.例如小于 10 个\n\n在什么时候使用 &#96;&#96;&#96;UnorrderedMap&#96;&#96;&#96;?\n\n* 需要访问整个集合中有限的子集合,例如每次调用只需要访问 1 个或 2 个元素\n* 无法将整个集合放入内存,例如数据量过大\n\n原因是 &#96;&#96;&#96;HashMap&#96;&#96;&#96;&#96; 在一个存储操作中反序列化(或序列化)整个集合.比通过 &#96;&#96;&#96;N&#96;&#96;&#96; 个存储操作访问所有元素更加节约 gas 费\n\n使用&#96;&#96;&#96;HashMap&#96;&#96;&#96;的示例:\n\n&#96;&#96;&#96;rust\n&#x2F;&#x2F;&#x2F; Using Default initialization.\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct Contract &#123;\n    pub status_updates: HashMap&lt;AccountId, String&gt;,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn set_status(&amp;mut self, status: String) &#123;\n        self.status_updates.insert(env::predecessor_account_id(), status);\n        assert!(self.status_updates.len() &lt;&#x3D; 10, &quot;Too many messages&quot;);\n    &#125;\n\n    pub fn clear(&amp;mut self) &#123;\n        &#x2F;&#x2F; Effectively iterating through all removing them.\n        self.status_updates.clear();\n    &#125;\n\n    pub fn get_all_updates(self) -&gt; HashMap&lt;AccountId, String&gt; &#123;\n        self.status_updates\n    &#125;\n&#125;\n\n使用UnorderedMap的示例:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract &#123;\n    pub status_updates: UnorderedMap&lt;AccountId, String>,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new() -> Self &#123;\n        // Initializing `status_updates` with unique key prefix.\n        Self &#123;\n            status_updates: UnorderedMap::new(b\"s\".to_vec()),\n        &#125;\n    &#125;\n\n    pub fn set_status(&amp;mut self, status: String) &#123;\n        self.status_updates.insert(&amp;env::predecessor_account_id(), &amp;status);\n        // Note, don't need to check size, since `UnorderedMap` doesn't store all data in memory.\n    &#125;\n\n    pub fn delete_status(&amp;mut self) &#123;\n        self.status_updates.remove(&amp;env::predecessor_account_id());\n    &#125;\n\n    pub fn get_status(&amp;self, account_id: AccountId) -> Option&lt;String> &#123;\n        self.status_updates.get(&amp;account_id)\n    &#125;\n&#125;\n\n\n\n使用持久化集合进行分页分页集合例如 UnorderedMap,UnorderedSet,和 Vector 可能包含的元素数量超过了 gas 限制下的读取数量.为了通过view调用来公开显示他们,我们可以实现分页.\n通过使用```.get(index)```来获取指定下标的元素\n要在 &#96;&#96;&#96;UnorderedSet&#96;&#96;&#96; 使用下标来访问元素.我们可以使用&#96;&#96;&#96; .as_vector()&#96;&#96;&#96;方法,该方法将返回元素的 &#96;&#96;&#96;Vector&#96;&#96;&#96;\n\n关于 &#96;&#96;&#96;UnoderedMap&#96;&#96;&#96; 我们需要将 keys 和 values 转换成 &#96;&#96;&#96;Vector&#96;&#96;&#96;,分别使用&#96;&#96;&#96;.keys_as_vector()&#96;&#96;&#96;和&#96;&#96;&#96;.values_as_vector()&#96;&#96;&#96;\n\n使用&#96;&#96;&#96;UnorderedMap&#96;&#96;&#96;实现分页的示例:\n\n&#96;&#96;&#96;rust\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract &#123;\n    pub status_updates: UnorderedMap&lt;AccountId, String&gt;,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    &#x2F;&#x2F;&#x2F; Retrieves multiple elements from the &#96;UnorderedMap&#96;.\n    &#x2F;&#x2F;&#x2F; - &#96;from_index&#96; is the index to start from.\n    &#x2F;&#x2F;&#x2F; - &#96;limit&#96; is the maximum number of elements to return.\n    pub fn get_updates(&amp;self, from_index: u64, limit: u64) -&gt; Vec&lt;(AccountId, String)&gt; &#123;\n        let keys &#x3D; self.status_updates.keys_as_vector();\n        let values &#x3D; self.status_updates.values_as_vector();\n        (from_index..std::cmp::min(from_index + limit, self.status_updates.len()))\n            .map(|index| (keys.get(index).unwrap(), values.get(index).unwrap()))\n            .collect()\n    &#125;\n&#125;\n\n\n\nLookupMapvsUnorderedMap功能性\nUnorderedMap支持迭代keys和values,并且支持分页.在内部,它拥有三个存储结构\n一个存储key与index关系的map\n一个keys的数组\n一个values的数组\n\n\nLookupMap只拥有一个存储key和value关系的map.没有存储keys的数组,所以它没有能力进行keys的迭代\n\n性能\n* &#96;&#96;&#96;UnorderedMap&#96;&#96;&#96;获取数据时需要2次读取操作,写入或插入数据时需要3次写入操作\n* &#96;&#96;&#96;LookupMap&#96;&#96;&#96;读取时需要1次读取操作,写入时需要1次写入操作\n\n##### 存储空间\n\n&#96;&#96;&#96;UnorderedMap&#96;&#96;&#96;比&#96;&#96;&#96;LookupMap&#96;&#96;&#96;需要更多的存储空间\n\n* &#96;&#96;&#96;UnorderedMap&#96;&#96;&#96;存储key两次(一次在map中,一次在数组中)和value一次.同时需要更高级别的常量来存储数组的长度和前缀\n* &#96;&#96;&#96;LookupMap&#96;&#96;&#96;存储key,value各一次\n\n\n\n#### &#96;&#96;&#96;LazyOption&#96;&#96;&#96;\n\n这是一个只存储单个值的持久化集合,目标是阻止合约在不需要使用该值时进行反序列化.一个例子是存在一个大的元数据块,它只在&#96;&#96;&#96;view&#96;&#96;&#96;调用中使用,在大多数合约操作中不需要使用.\n\n它的作用类似于&#96;&#96;&#96;Option&#96;&#96;&#96;,可以保存值们也可以不保存值,同时还需要一个唯一的前缀,就像其他持久化集合一样.\n\n与其他集合一样,LazyOption只允许在初始化过程中初始化值.\n\n&#96;&#96;&#96;rust\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract &#123;\n    pub metadata: LazyOption&lt;Metadata&gt;,\n&#125;\n\n#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize)]\n#[serde(crate &#x3D; &quot;near_sdk::serde&quot;)]\npub struct Metadata &#123;\n    data: String,\n    image: Base64Vec,\n    blobs: Vec&lt;String&gt;,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new(metadata: Metadata) -&gt; Self &#123;\n        Self &#123;\n            metadata: LazyOption::new(b&quot;m&quot;, Some(metadata)),\n        &#125;\n    &#125;\n\n    pub fn get_metadata(&amp;self) -&gt; Metadata &#123;\n        &#x2F;&#x2F; &#96;.get()&#96; reads and deserializes the value from the storage. \n        self.metadata.get().unwrap()\n    &#125;\n&#125;\n\n\n\n集合嵌套使用传统方式构造唯一前缀在构造函数中使用一个硬编码的短字母前缀,该前缀将转换为字节 vector.使用嵌套集合,该前缀必须手动构造\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new() -> Self &#123;\n        Self &#123;\n            accounts: UnorderedMap::new(b\"a\"),\n            tokens: LookupMap::new(b\"t\"),\n            metadata: LazyOption::new(b\"m\"),\n        &#125;\n    &#125;\n\n    fn get_tokens(&amp;self, account_id: &amp;AccountId) -> UnorderedSet&lt;String> &#123;\n        let tokens = self.accounts.get(account_id).unwrap_or_else(|| &#123;\n            // Constructing a unique prefix for a nested UnorderedSet.\n            let mut prefix = Vec::with_capacity(33);\n            // Adding unique prefix.\n            prefix.push(b's');\n            // Adding the hash of the account_id (key of the outer map) to the prefix.\n            // This is needed to differentiate across accounts.\n            prefix.extend(env::sha256(account_id.as_bytes()));\n            UnorderedSet::new(prefix)\n        &#125;);\n        tokens\n    &#125;\n&#125;\n\n为持久化容器生产前缀每个持久化容器都需要一个唯一的前缀.该前缀被用于生成内部的键以持久化的存储数据.这些内部的键必须是唯一的以避免冲突(包括 STATE 的键冲突)当一个合约变的复杂,可能会有多个不同的集合,他们不是主结构的全部组成部分.而是子结构或嵌套容易,他们都需要唯一的前缀我们可以引入一个 enum 来追踪存储前缀和键.然后它们使用 borsh 序列化来为每个容器构造一个唯一的前缀.它与手工构造一样高效,因为 borsh 序列化,一个enum只需要 1 个 字节\nuse near_sdk::BorshStorageKey;\n\n#[derive(BorshStorageKey, BorshSerialize)]\npub enum StorageKeys &#123;\n    Accounts,\n    SubAccount &#123; account_hash: Vec&lt;u8> &#125;,\n    Tokens,\n    Metadata,\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new() -> Self &#123;\n        Self &#123;\n            accounts: UnorderedMap::new(StorageKeys::Accounts),\n            tokens: LookupMap::new(StorageKeys::Tokens),\n            metadata: LazyOption::new(StorageKeys::Metadata),\n        &#125;\n    &#125;\n    \n    fn get_tokens(&amp;self, account_id: &amp;AccountId) -> UnorderedSet&lt;String> &#123;\n        let tokens = self.accounts.get(account_id).unwrap_or_else(|| &#123;\n            UnorderedSet::new(\n                StorageKeys::SubAccount &#123; account_hash: env::sha256(account_id.as_bytes()) &#125;\n            )\n        &#125;);\n        tokens\n    &#125;\n&#125;\n\n\n\n","slug":"NEAR SDK - 合约结构","date":"2022-03-14T06:18:47.231Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"},{"id":"9520473b9d226eac24e0870f8d1ab299","title":"NEAR SDK - 回调函数","content":"与工作量证明区块链不同,NEAR 协议是分片的,权益证明的区块链网络,当使用原生Rust(编译成 WASM)与智能合约交互时,跨合约调用是异步的.回调用来获取跨合约调用的结果或者用来获取跨合约调用是成功还是失败.\n这里有两种进行跨合约调用的技术:高级调用和低级调用.本文档将聚焦于高级调用.Rust SDK 库中有两个示例演示了这些内容.如上面的连接所示.注意这些例子使用跨合约调用他们自身.我们将使用两个示例来演示高级调用.\n计算器示例#[ext_contract(...)]宏可以帮助你创建一个跨合约调用.它将使用一个 Rust Trait 并且转化为一个具有静态方法的模块.每个静态方法都接受 Trait 定义的位置参数,然后是 receiver_id,附带的存款和 gas 数量然后返回一个 Promiss\n例如,让我们定义一个计算器合约 Trait\n#[ext_contract(ext_calculator)]\ntrait Calculator &#123;\n    fn mult(&amp;self, a: U64, b: U64) -> U128;\n\n    fn sum(&amp;self, a: U128, b: U128) -> U128;\n&#125;\n\n等价于:\nmod ext_calculator &#123;\n    pub fn mult(a: U64, b: U64, receiver_id: &amp;AccountId, deposit: Balance, gas: Gas) -> Promise &#123;\n        Promise::new(receiver_id.clone())\n            .function_call(\n                b\"mult\",\n                json!(&#123; \"a\": a, \"b\": b &#125;).to_string().as_bytes(),\n                deposit,\n                gas,\n            )\n    &#125;\n\n    pub fn sum(a: U128, b: U128, receiver_id: &amp;AccountId, deposit: Balance, gas: Gas) -> Promise &#123;\n        // ...\n    &#125;\n&#125;\n\n我们假设计算器合约已经部署在了账户calc.near上,我们接下来可以这么做:\nconst CALCULATOR_ACCOUNT_ID: &amp;str = \"calc.near\";\nconst NO_DEPOSIT: Balance = 0;\nconst BASE_GAS: Gas = 5_000_000_000_000;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn sum_a_b(&amp;mut self, a: U128, b: U128) -> Promise &#123;\n        let calculator_account_id: AccountId = CALCULATOR_ACCOUNT_ID.to_string();\n        ext_calculator::sum(a, b, &amp;calculator_account_id, NO_DEPOSIT, BASE_GAS)\n    &#125;\n&#125;\n\n\n\n白名单示例接下来我来看白名单智能合约的一个简单的跨合约调用,返回给定的用户是否在白名单里.跨合约调用的常见模式是首先调用外部智能合约的方法.然后使用.then 语法来标记一个回调.最后在 promiss 中取回数据或状态.回调将在同样的环境中调用只能合约.回调函数使用了特殊的宏#[privette].我们将在下面看到这个模式下面的示例演示两个使用高级调用进行跨和调用的方式.当编写高级跨合约调用时,被调用的智能合约接口被设置为特殊的 trait .并且(通常的)由当前合约进行这个调用(在那里存在回调逻辑).按照惯例,第二个 trait 被称为 ext_self.\n下面我们会看到一个简单的使用了两个 trait的示例:\n#[ext_contract(ext_self)]\npub trait ExtSelf &#123;\n    fn callback_promise_result() -> bool;\n    fn callback_arg_macro(#[callback] val: bool) -> bool;\n&#125;\n\n#[ext_contract(ext_whitelist)]\npub trait ExtWhitelist &#123;\n    fn is_whitelisted(staking_pool_account_id: AccountId) -> bool;\n&#125;\n\n在创建这些 trait 后,我们展示两个简单的函数,他们将进行白名单合约的跨合约调用.询问账户 mike.testnet 是否在白名单中.这两个方法都返回 bool 值.首先我们来看看方法,然后让我们来看看回调函数的区别.注意,简单起见,本例中的值是硬编码的.\npub const XCC_GAS: Gas = 20000000000000;\nfn get_whitelist_contract() -> AccountId &#123;\n    \"whitelist.demo.testnet\".to_string()\n&#125;\nfn get_account_to_check() -> AccountId &#123;\n    \"mike.testnet\".to_string()\n&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn xcc_use_promise_result(&amp;mut self) -> Promise &#123;\n        ext_whitelist::is_whitelisted(get_account_to_check(), &amp;get_whitelist_contract(), 0, XCC_GAS).then(\n            ext_self::callback_promise_result(\n                &amp;env::current_account_id(),\n                0,\n                XCC_GAS,\n            ),\n        )\n    &#125;\n\n    pub fn xcc_use_arg_macro(&amp;mut self) -> Promise &#123;\n        ext_whitelist::is_whitelisted(get_account_to_check(), &amp;get_whitelist_contract(), 0, XCC_GAS).then(\n            ext_self::callback_arg_macro(\n                &amp;env::current_account_id(),\n                0,\n                XCC_GAS,\n            ),\n        )\n    &#125;\n\n从ext_whitelist::is_whitelisted..开始的语法给我们展示了如何使用 trait 来调用方法is_whitelisted.然而,该 trait 只有一个参数,我们却传入了 4 个参数.其中后面 3 个参数将在幕后使用:\n\n目标合约账户(例如:whitelist.demo.testnet)\n附带的 Ⓝ存款,单位为 yocto Ⓝ(1 Ⓝ &#x3D; 1000000000000000000000000 yoctoⓃ.)\ngas 数量\n\n代码片段中的两个方法非常相似,除了他们各自使用了不同的回调 callback_promise_result 和 callback_arg_macro\n#[private]\npub fn callback_promise_result(&amp;mut self) -> bool &#123;\n    assert_eq!(env::promise_results_count(), 1, \"ERR_TOO_MANY_RESULTS\");\n    match env::promise_result(0) &#123;\n        PromiseResult::NotReady => unreachable!(),\n        PromiseResult::Successful(val) => &#123;\n            if let Ok(is_whitelisted) = near_sdk::serde_json::from_slice::&lt;bool>(&amp;val) &#123;\n                is_whitelisted\n            &#125; else &#123;\n                env::panic(b\"ERR_WRONG_VAL_RECEIVED\")\n            &#125;\n        &#125;,\n        PromiseResult::Failed => env::panic(b\"ERR_CALL_FAILED\"),\n    &#125;\n&#125;\n\n#[private]\npub fn callback_arg_macro(&amp;mut self, #[callback] val: bool) -> bool &#123;\n    val\n&#125;\n\n这两个回调展示了如何获得值.第一个方法从 promise result 中获取值,第二个在参数中使用了宏来将值转化为所需的值.请注意,第二种方式没有第一种方式那么容易捕获错误.\n这两种方式最大的不同是参数是如何定义的.\n这就是所有的内容了.理解如何创建一个跨合约调用并且接收返回值是在 NEAR 上开发智能合约非常重要的一部分.\n","slug":"NEAR SDK - 回调函数","date":"2022-03-11T12:11:22.994Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"},{"id":"0d7a924133f95db56db161e3fcf8a116","title":"NEAR SDK - 合约接口","content":"公共方法类型基础实现在#[near_bindgen]宏包裹下的函数可以使用 pub标识符修饰,这样当它编译成WASM字节码以后就可以被外部调用 \n只讲能在外部调用的方法标记成public是很重要的.如果你需要合约自身来调用,你可以标记该方法为公共的但是添加#[private]修饰,这样除了合约自身的调用,任何调用都会导致panic\n基本的用法如下所示:\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn some_method(&amp;mut self) &#123;\n        // .. method logic here\n    &#125;\n&#125;\n\n这将从WASM二进制码中公开some_method,任何人都可以访问它\n\n展开显示生成的代码\n#[cfg(target_arch = \"wasm32\")]\n#[no_mangle]\npub extern \"C\" fn some_method() &#123;\n    near_sdk::env::setup_panic_hook();\n    if near_sdk::env::attached_deposit() != 0 &#123;\n        near_sdk::env::panic(\"Method some_method doesn\\'t accept deposit\".as_bytes());\n    &#125;\n    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();\n    contract.some_method();\n    near_sdk::env::state_write(&amp;contract);\n&#125;\n\n\n\n公开trait实现函数也能够公开自己的trait实现.这有助于在合约中实现共有的接口或标准.下面的代码与pub的基础用法很相似,除了#[near_bindgen]宏只需要附属在trait的实现上,而无需附属与trait本身.\npub trait MyTrait &#123;\n    fn trait_method(&amp;mut self);\n&#125;\n\n#[near_bindgen]\nimpl MyTrait for MyContractStructure &#123;\n    fn trait_method(&amp;mut self) &#123;\n        // .. method logic here\n    &#125;\n&#125;\n\n在这个例子中,生成的代码与前一个例子相同,只是方法名不一样\n\n展开显示生成的代码\n#[cfg(target_arch = \"wasm32\")]\n#[no_mangle]\npub extern \"C\" fn trait_method() &#123;\n    near_sdk::env::setup_panic_hook();\n    if near_sdk::env::attached_deposit() != 0 &#123;\n        near_sdk::env::panic(\"Method trait_method doesn\\'t accept deposit\".as_bytes());\n    &#125;\n    let mut contract: MyContractStructure = near_sdk::env::state_read().unwrap_or_default();\n    contract.trait_method();\n    near_sdk::env::state_write(&amp;contract);\n&#125;\n\n\n\n合约状态可变性合约状态可变性是通过函数参数中的self参数是怎样的来自动处理的.根据使用的是哪一个,#[near_bindgen]宏将生成相应的代码来加载&#x2F;反序列化任何使用self的函数的状态，序列化&#x2F;存储状态只在使用&amp;mut self时使用。\n只读函数以不可变的方式调用合约时,交易结束时不会覆写任何状态.你可以通过使用&amp;self 或者 self 作为参数.他们都将生成同样的代码去加载并反序列化状态到结构体中,然后调用函数.不同的是,self 会将变量的所有权移动进函数中,&amp;self 仅仅将 self 的引用移动进函数中.\n下面是一个例子:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct MyContractStructure &#123;\n    integer: u64,\n    message: String,\n&#125;\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn get_values(self) -> (u64, String) &#123;\n        (self.integer, self.message)\n    &#125;\n    pub fn log_state_string(&amp;self) &#123;\n        near_sdk::env::log(self.message.as_bytes());\n    &#125;\n&#125;\n\n没有适用于所有情况的通用准则,但有一些核心规则需要遵守:\n\nself 如果在函数中移动了 self 的值或者其包含的值时使用 self 作为参数是很有用的,因为这样减少了 copy 和 clone 的操作\n/// View method. More efficient, but can't be reused internally, because it consumes self.\npub fn get_owner_id(self) -> AccountId &#123;\n    self.owner_id\n&#125;\n\n&amp;self当值需要只读的合约状态,或者函数使用了一些方法来获得了可用的所有权时使用&amp;self.如果结构体使用了大量内存,这很有用,可以避免将大量的数据转移进函数作用域中.\n/// View method. Requires cloning the account id.\npub fn get_owner_id(&amp;self) -> AccountId &#123;\n    self.owner_id.clone()\n&#125;\n\n返回派生数据\n有些少见的情况需要我们通过只读的方式来返回从存储中获取并修改的数据.如下面所示:\n/// View method that \"modifies\" state, for code structure or computational\n/// efficiency reasons. Changes state in-memory, but does NOT save the new\n/// state. If called internally by a change method, WILL result in updated\n/// contract state.\npub fn update_stats(&amp;self, account_id: AccountId, score: U64) -> Account &#123;\n    let account = self.accounts.get(&amp;account_id).unwrap_or_else(|| env::panic_str(\"ERR_ACCT_NOT_FOUND\"));\n    account.total += score;\n    account\n&#125;\n\n可变函数可变的函数允许加载存在的状态,然后对它进行修改,最后当方法调用结束后重新将状态写入\n这应该用于任何修改合约状态的交易中.注意,序列化的合约数据存在键 STATE 下持久化存储中.\n一个可变函数的例子:\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, Default)]\npub struct MyContractStructure &#123;\n    integer: u64,\n&#125;\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn modify_value(&amp;mut self, new_value: u64) &#123;\n        self.integer = new_value;\n    &#125;\n    pub fn increment_value(&amp;mut self) &#123;\n        self.integer += 1;\n    &#125;\n&#125;\n\n\n\n纯函数这一类函数根本不使用 self,也不需要从存储中读取或者写入合约状态\n使用公共的纯函数的情况很少,但是返回嵌入到合约代码中的数据或执行一些不依赖合约状态的静态共享逻辑时可能很有用\n一个纯函数的例子:\nconst SOME_VALUE: u64 = 8;\n\n#[near_bindgen]\nimpl MyContractStructure &#123;\n    pub fn log_message(/* Parameters here */) &#123;\n        near_sdk::log!(\"inside log message\");\n    &#125;\n    pub fn log_u64(value: u64) &#123;\n        near_sdk::log!(\"&#123;&#125;\", value);\n    &#125;\n    pub fn return_static_u64() -> u64 &#123;\n        SOME_VALUE\n    &#125;\n&#125;\n\n\n\n私有方法何时使用回调通常,当合约必须为一个远程交叉合约调用进行回调时,这个回调方法必须只能被合约自身调用.这能避免有人直接调用它而搞乱合约状态.更常见的模式是使用断言来验证直接调用者(predecessor account ID)是否是合约自己的账户(current account ID).#[private]宏会简化这个操作,提高代码可读性.\n在near_bindgen宏包裹的代码里使用这个标注,例如:\n#[private]\npub fn my_method(&amp;mut self) &#123;\n    …\n&#125;\n\n上面的代码等价于\npub fn my_method(&amp;mut self ) &#123;\n    if env::current_account_id() != env::predecessor_account_id() &#123;\n        near_sdk::env::panic(\"Method method is private\".as_bytes());\n    &#125;\n...\n&#125;\n\n现在通过这个标注,只有合约账户本身可以调用这个方法,可以直接调用也可以通过哦Promise\n编写内部方法不是所有的方法都需要暴露为公开的,为 helper 或 uility 函数编写私有的方法也许更加有益.下面是三种编写内部方法的途径\n\n使用 fn 替换 pub fn\nfn helper_method(a: u8, b: u8) &#123;\n  …\n&#125;\n\n使用pub(crate) fn.这将有助于在不同的模块中使用内部函数\n// Function that can be called in another Rust file\npub(crate) fn get_first_name(account: Account) &#123;\n  …\n&#125;\n\n分散的impl块\n另外一种不暴露方法的方式是有一个单独的impl Contract部分,并且这部分不使用#[near_bindgen]宏\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn increment(&amp;mut self) &#123;\n        self.internal_increment();\n    &#125;\n&#125;\nimpl Contract &#123;\n    /// This methods is still not exported.\n    pub fn internal_increment(&amp;mut self) &#123;\n        self.counter += 1;\n    &#125;\n&#125;\n\n可支付方法我们可以允许方法在函数调用时接受代币转移.这样做是为了让合约能够使用的时候定义其需要的代币费用.默认的方法是不可支付的,如果调用时尝试转移代币会导致 panic.这样做是因为安全原因,以免有人在函数调用时意外地转移代币\n使用#[payable]标注来申明方法是可支付的.\n#[payable]\npub fn my_method(&amp;mut self) &#123;\n...\n&#125;\n\n这将允许通过调用my_method方法来转移资产给合约\n例子:\n#[near_bindgen]\nimpl Contract &#123;\n    #[payable]\n    pub fn take_my_money(&amp;mut self) &#123;\n        env::log_str(\"Thanks!\");\n    &#125;\n    pub fn do_not_take_my_money(&amp;mut self) &#123;\n        env::log_str(\"Thanks!\");\n    &#125;\n&#125;\n\n等价于:\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn take_my_money(&amp;mut self) &#123;\n        env::log_str(\"Thanks!\");\n    &#125;\n    pub fn do_not_take_my_money(&amp;mut self) &#123;\n        if near_sdk::env::attached_deposit() != 0 &#123;\n            near_sdk::env::panic(b\"Method do_not_take_my_money doesn't accept deposit\");\n        &#125;\n        env::log_str(\"Thanks!\");\n    &#125;\n&#125;\n\n\n\n序列化协议SDK 中的序列化规则定义了结构体数据如何转化成字节,当需要传输数据到合约方法中或存储数据到状态中时.对于方法参数,SDK 接受JSON(默认)和 Borsh,对于存储数据在链上,使用 Borsh.\nJSON 和 Borsh 的特点如下:JSON:\n\n人类可读\n自解释样式(不需要知道底层类型)\n与 JavaScript 的易互操作性\n低效率的(反)序列化Borsh\n紧凑的二进制格式可以高效率的进行数据的序列化和反序列化\n需要知道数据格式或者有一个模板来反序列化数据\n严格规范的二进制表示\n在大多数情况下,快速并且开销更小通常来说,JSON 用于合约调用和交叉合约调用以实现更好的适用性,Borsh 被用于优化合约中更小的参数序列化和更少的反序列化计算开销,以减少 gas 使用.\n\n重载默认的序列化协议结果和参数的序列化可以分开选择.但是所有的参数必须使用同样的样式(不能使用 borsh 序列化一部分参数,另外的参数使用 JSON 序列化).下面的例子是同时使用 borsh 来序列化返回值和参数\n#[result_serializer(borsh)]\npub fn sum_borsh(#[serializer(borsh)] a: u32, #[serializer(borsh)] b: u32) -> u32 &#123;\n    a + b\n&#125;\n\nJSON 重载为 borsh,```serializer(borsh)```标注将重载参数的序列化协议\n下面是在单元测试中使用 Borsh 序列化,并且使用 base64 编码的方法\n\n&#96;&#96;&#96;rust\n&#x2F;&#x2F;&#x2F; This test is simply a helper to print out the base64 value.\n#[test]\nfn borsh_simple() &#123;\n    let status_message &#x3D; &quot;Aloha honua!&quot;.to_string();\n    let borsh_input &#x3D; SetMessageInput &#123;\n        msg: status_message.clone()\n    &#125;;\n\n    let borsh_serialized: Vec&lt;u8&gt; &#x3D; borsh_input.try_to_vec().unwrap();\n    let base64_encoded &#x3D; near_primitives::serialize::to_base64(borsh_serialized.as_slice());\n    println!(&quot;Using NEAR CLI, this is the base64-encoded value to use: &#123;:?&#125;&quot;, base64_encoded);\n&#125;\n\n下面展示了在 CLI 中使用这个值的代码片段.注意,该方法没有返回值,所以不需要使用#[result_serializer(borsh)]来标注返回值\npub fn set_status_borsh(&amp;mut self, #[serializer(borsh)] message: SetMessageInput) &#123;\n    self.records.insert(&amp;env::signer_account_id(), &amp;String::from(message.msg));\n&#125;\n\n他们使用了这个简单的结构体:\n#[derive(BorshDeserialize, BorshSerialize)]\npub struct SetMessageInput &#123;\n    // Note that the key does not have to be \"message\" like the argument name.\n    msg: String,\n&#125;\n\n在NEAR CLI中调用方法如下:\nnear call rust-status-message.demo.testnet set_status_borsh --base64 &#39;DAAAAEFsb2hhIGhvbnVhIQ&#x3D;&#x3D;&#39; --accountId demo.testnet\n\n\n\nJSON 包装类型为了帮助将某些类型序列化为 JSON,这些类型有意想不到或低效的默认格式,在 near_sdk::json_types 里有一些包装器类型可以使用因为 JavaScript 只支持整数类型的值到 2^53-1,如果反序列化 JSON 整型超过了这个范围,你将丢失精度.为了抵消这种影响,你可以使用 I64,U64,I128 和 U128 类型来代替这些参数或结果的本地类型,将值序列化为字符串.默认情况下,所有整数类型都将序列化为 JSON 中的整型你能使用 std::convert::Into 来将 U64 转化为 u64\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n        let a: u64 = a.into();\n        let b: u64 = b.into();\n        let product = u128::from(a) * u128::from(b);\n        product.into()\n    &#125;\n&#125;\n\n你也可以使用.0来访问内部值\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n        //let a: u64 = a.into();\n        let a = a.0;\n        //let b: u64 = b.into();\n        let b = b.0;\n        let product = u128::from(a) * u128::from(b);\n        product.into()\n    &#125;\n&#125;\n\n同时,你还可以使用U64(...)和U128(...)来转化u64和u128\n#[near_bindgen]\n impl Contract &#123;\n     pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n         let a = a.0;\n         let b = b.0;\n         let product = u128::from(a) * u128::from(b);\n         //product.into()\n         U128(product)\n     &#125;\n &#125;\n\n结合起来使用:\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn mult(&amp;self, a: U64, b: U64) -> U128 &#123;\n        U128(u128::from(a.0) * u128::from(b.0))\n    &#125;\n&#125;\n\n尽管JSON 包装类型只包含在 SDK 中,但是任何类型都可以使用,只要它各自实现了 serder 序列化和反序列化.所有这些类型都覆写了 JSON 格式并且与内部类型具有一致的 borsh 序列化和反序列特性\nBase64VecU8另外一个覆写默认序列化的例子是 Vec,它用来表示 Rust 中的字节.默认实现下,它将序列化为整型数组,这是不紧凑而且很难使用的.有一个包装类型Base64VecU8,它能序列化和反序列化 Base64 字符串再 JSON 的序列化中获得更多的紧凑性\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct Contract &#123;\n    // Notice, internally we store `Vec&lt;u8>` \n    pub data: Vec&lt;u8>,\n&#125;\n#[near_bindgen]\nimpl Contract &#123;\n    #[init]\n    pub fn new(data: Base64VecU8) -> Self &#123;\n        Self &#123;\n            data: data.into(),\n        &#125;\n    &#125;\n    pub fn get_data(self) -> Base64VecU8 &#123;\n        self.data.into()\n    &#125;\n&#125;\n\n","slug":"NEAR SDK - 合约接口","date":"2022-03-11T08:48:13.455Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"},{"id":"816461eb926cfc8059f79248c7c4915a","title":"NEAR SDK Promise","content":"介绍合约能够通过 Promise 异步的发送交易.就像其他编程语言中的Promise 一样,它可以让代码在未来执行.”在未来”意味着交易将在下一个区块(或附近)执行,而不会在初始调用的区块执行.你可以使用 Promise实现任何跨合约调用链.它介于之前所说的高级调用和低级调用之间.查阅上面完整的 Promise 文档以获得更多细节当然,在很少的情况下,Promise 拥有特殊的能力,因为这些情况都不需要函数调用\n\n发送 NEAR 代币\n创建账户\n部署合约\n\n\n\n\n\n\n\n提示\n为什么要等待\n为什么不让交易是同步进行的.在同样的区块完成方法调用?为什么 NEAR 需要 Promise 来发送代币,创建账户和部署合约?他们需要在单独的块中进行调度,因为发送者和接收者可能位于不同的分片中,跨分片通信发生在多个块之间,通过 收据(receipts),你可以将收据理解为 NEAR 的内部交易.你能在 NEAR Explorer 中看到收据是怎么从一个块传输到另一个块中.\n\n\n发送$NEAR你可能有很多原因想要从合约发送代币:\n\n合约使用了类似存储标准的协议,需要再用户注销时返还资金\n用户支付 token 给合约,然后合约稍后支付费用给维护人员,重新分配给用户或者通过用户投票的结果支付给其他人\n更多…\n\n区块链给了我们可编程的货币,智能合约支付货币是这种能力的核心NEAR 让这变的简单,如果你想要从合约中转移代币,下面是你需要做的全部:\nlet amount: u128 = 1_000_000_000_000_000_000_000_000; // 1 $NEAR as yoctoNEAR\nlet account_id: AccountId = \"example.near\".parse().unwrap();\n\nPromise::new(account_id).transfer(amount);\n\n\n\n\n\n\n\n提示\n本文档描述的 AccountId 行为是 neaer-sdk-rs v4 的特性.这个功能在 v3 中依然可以使用,但如果你想使用更干净的 v4 语法,编写你的Cargo.toml\n[dependencies]\nnear-sdk = \"4.0.0-pre.2\"\n\n\n\n完整的合约上下文像下面这样\nuse near_sdk::&#123;json_types::U128, near_bindgen, AccountId, Promise&#125;;\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn pay(amount: U128, to: AccountId) -> Promise &#123;\n        Promise::new(to).transfer(amount.0)\n    &#125;\n&#125;\n\n\n\n其中大部分是你已经熟悉的样板.像 imports,设置 near_bindgen,borsh.下面是一些与转账有关的有趣细节:\n\n大写的 U 的 U128,这里的 pay 方法定义了接受 JSON 作为输入,但是 JSON 数字不能超过 2^53,也就是 9 后面只跟了 15 个 0,因为传输时使用的数量是以 yoctoNEAR 为单位,似乎需要比 2^53 大的多的数字  当方法接受 U128 位输入时,这意味着调用者需要将数字转化成 string.near-sdk-rs 将 string 转化为 U128,它是 Rust 原生的 u128 的包装类.底层的 u128 可以通过.0 来使用.例如 transfer(amount.0)\n\nAccountId:这个类型会自动的检查提供的 string 是否很好的匹配了 NEAR 账户 ID 的规则.当不匹配时 panic\n\n返回 Promise:这将允许 NEAR Explorer,near-cli,near-api-js.和其他工具正确的判断整个交易链是否成功.如果你的函数没有返回 Promise.类似于 near-cli 会在你的调用后立刻返回.并且即使 transfer 失败,你的函数调用也会确认为成功.这里有相关的例子.使用 near-cli 来调用函数:\nnear call $CONTRACT pay &#39;&#123;&quot;amount&quot;: &quot;1000000000000000000000000&quot;, &quot;to&quot;: &quot;example.near&quot;&#125;&#39;\n\n发送$NEAR你可能有很多原因想要从合约发送代币:\n\n合约使用了类似存储标准的协议,需要再用户注销时返还资金\n用户支付 token 给合约,然后合约稍后支付费用给维护人员,重新分配给用户或者通过用户投票的结果支付给其他人\n更多…\n\n区块链给了我们可编程的货币,智能合约支付货币是这种能力的核心NEAR 让这变的简单,如果你想要从合约中转移代币,你只需要:\nlet amount: u128 = 1_000_000_000_000_000_000_000_000; // 1 $NEAR as yoctoNEAR\nlet account_id: AccountId = \"example.near\".parse().unwrap();\n\nPromise::new(account_id).transfer(amount);\n\n在一个完整的合约和函数上下文中,你可以这样发送$NEAR\nuse near_sdk::&#123;json_types::U128, near_bindgen, AccountId, Promise&#125;;\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    pub fn pay(amount: U128, to: AccountId) -> Promise &#123;\n        Promise::new(to).transfer(amount.0)\n    &#125;\n&#125;\n\n例子中的大部分内容你应该已经很熟悉了.比如near_bindgen,borsh,下面是一些与$NEAR的发送有关的细节:\n\n大写的 U 的 U128,这里的 pay 方法定义了接受 JSON 作为输入,但是 JSON 数字不能超过 2^53,也就是 9 后面跟15 个 0,因为传输时使用的数量是以 yoctoNEAR 为单位,我们似乎需要比 2^53 大的多的数字  当方法接受 U128 位输入时,这意味着调用者需要将数字转化成 string.near-sdk-rs 将 string 转化为 U128,它是 Rust 原生的 u128 的包装类.底层的 u128 可以通过.0 来使用.例如 transfer(amount.0)\nAccountId:这个类型会自动的检查提供的 string 是否很好的匹配了 NEAR 账户 ID 的规则.当不匹配时 panic\n返回 Promise:这将允许 NEAR Explorer,near-cli,near-api-js.和其他工具正确的判断整个交易链是否成功.如果你的函数没有返回 Promise.near-cli这样的工具 会在你的调用后立刻返回.并且即使 transfer 失败,你的函数调用也会确认为成功.你能看到相关例子在这里\n\n使用 near-cli 来调用函数:\nnear call $CONTRACT pay &#39;&#123;&quot;amount&quot;: &quot;1000000000000000000000000&quot;, &quot;to&quot;: &quot;example.near&quot;&#125;&#39;\n\n\n\n\n\n创建账户你可能会有很多原因需要从合约中创建账户.一个例子;你想要用户渐进式的参与,在一开始时隐藏 NEAR 的概念,然后自动为他们创建账户(可能是你的账户的子账户,类似于 user123.some-cool-game.near).因为没有余额的账户几乎不能使用,你可能想要将其与上一页中的代币转移结合使用.你需要给定这个账户一个访问秘钥.就像下面做的这样\nPromise::new(\"subaccount.example.near\".parse().unwrap())\n    .create_account()\n    .add_full_access_key(env::signer_account_pk())\n    .transfer(250_000_000_000_000_000_000_000); // 2.5e23yN, 0.25N\n\n完整的合约上下文如下:\nuse near_sdk::&#123;env, near_bindgen, AccountId, Balance, Promise&#125;;\n\nconst INITIAL_BALANCE: Balance = 250_000_000_000_000_000_000_000; // 2.5e23yN, 0.25N\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[private]\n    pub fn create_subaccount(prefix: AccountId) -> Promise &#123;\n        let subaccount_id = AccountId::new_unchecked(\n          format!(\"&#123;&#125;.&#123;&#125;\", prefix, env::current_account_id())\n        );\n        Promise::new(subaccount_id)\n            .create_account()\n            .add_full_access_key(env::signer_account_pk())\n            .transfer(INITIAL_BALANCE)\n    &#125;\n&#125;\n\n需要注意的事:\n\nadd_full_access_key - 该示例使用了进行方法调用并签署了原始交易的人或app的公钥(singner_account_pk),你也可以使用add_access_key来添加Function Call访问键,该访问键允许用户调用预先定义好的一组合约方法.\n#[private] - 如果你有一个方法将会使用你的合约存款.你可能希望以某种方式保护它不被攻击.这里例子用了一个过于简单的方法–标注#[private]宏\nINITTIAL_BALANCE使用near-sdk-rs中的Balance类型.现在它简单的等价于u128,但它将来可能会扩展出额外的方法,就像最近对Gas类型做的那样类型做的那样\n\n部署合约出于一下几种原因,你可能希望你的智能合约能部署后续的智能合约代码:\n\n该合约使用工厂模式,在这个模式中,父合约创建很多子合约(Mintbase使用这种模式为任何想要创建NFT商店的人创建一个NFT商店,彩虹桥也使用这种模式为每个桥接代币创建特定的代币合约)\n合约等待投票通过后更新其自身的代码\n你可以实现一个”合约用户化”系统为每个用户创建特定应用的子账户并且为他们部署同样的合约.因为NEAR存储费的原因,这样的系统是非常昂贵的,但在未来可能会进行优化.如果优化实现了,那么这种”应用分片设计”可能会有更好的伸缩性和以用户为中心的合约标准和应用机制.这种范式的早期实现被称为Meta NEAR\n\n如果你的目标是像Mintbase或彩虹桥一样需要在主合约中部署子合约账户.你还需要创建账户.所以,你需要合并前面提高的概念.下面是你需要的:\nconst CODE: &amp;[u8] = include_bytes!(\"./path/to/compiled.wasm\");\n\nPromise::new(\"subaccount.example.near\".parse().unwrap())\n    .create_account()\n    .add_full_access_key(env::signer_account_pk())\n    .transfer(3_000_000_000_000_000_000_000_000) // 3e24yN, 3N\n    .deploy_contract(CODE.to_vec())\n\n下面是完整的合约的可能的样子,使用了一种天真的方式来传递code而不是使用include_bytes!硬编码它\nuse near_sdk::&#123;env, near_bindgen, AccountId, Balance, Promise&#125;;\n\nconst INITIAL_BALANCE: Balance = 3_000_000_000_000_000_000_000_000; // 3e24yN, 3N\n\n#[near_bindgen]\npub struct Contract &#123;&#125;\n\n#[near_bindgen]\nimpl Contract &#123;\n    #[private]\n    pub fn create_child_contract(prefix: AccountId, code: Vec&lt;u8>) -> Promise &#123;\n        let subaccount_id = AccountId::new_unchecked(\n          format!(\"&#123;&#125;.&#123;&#125;\", prefix, env::current_account_id())\n        );\n        Promise::new(subaccount_id)\n            .create_account()\n            .add_full_access_key(env::signer_account_pk())\n            .transfer(INITIAL_BALANCE)\n            .deploy_contract(code)\n    &#125;\n&#125;\n\n为什么这是一种天真的方法?因为4MB的交易大小限制.(上面的函数将对整个合约进行反序列化和堆分配).在许多情况下,include_bytes!方法是可取的.如果确实需要附加已编译的WASM作为参数,可以参考Sputnik DAO v2使用的方法\n","slug":"NEAR SDK - Promise","date":"2022-03-11T04:02:42.641Z","categories_index":"文档翻译","tags_index":"NEAR,near-sdk-rs","author_index":"Bref"}]